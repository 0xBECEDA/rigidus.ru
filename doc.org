#+TITLE: rigidus
#+HTML_HEAD: <!-- -*- fill-column: 86 -*- -->

#+NAME: css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Интро

  Это сайт http://rigidus.ru

* Шаблонные контейнеры
** Корневой контейнер

   Корневой контейнер - это кусок html-кода, который на всех страницах
   одинаковый. Он содержит в себе контейнер страниц =tpl_base=.

   Заголовок страницы помещается в переменную =headtitle=.

   #+NAME: tpl_root
   #+BEGIN_SRC html
     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">{\n}
     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">{\n}
         <head>{\n}
             <title>{$headtitle}</title>{\n}
             <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />{\n}
             <meta name="viewport" content="width=device-width, initial-scale=1">
             <link rel="stylesheet" type="text/css" media="screen" href="/css/style.css" />{\n}
             <link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico" />{\n}
             <script type="text/javascript" src="/js/jquery-1.5.2.min.js"></script>
             <script type="text/javascript" src="/js/comment.js"></script>
         </head>{\n}
         <body id="top">{\n}
             <<tpl_base>>
         </body>{\n}
     </html>{\n}
   #+END_SRC

** Контейнер страниц

   Этот контейнер содержит элементы, общие для всех страниц:
   - ссылку на главную страницу сайта
   - заголовок страницы
   - навигацию
   - footer

   Изменяемое содержимое помещается в переменную =columns=,
   h1-заголовок - в переменную =title=

   #+NAME: tpl_base
   #+BEGIN_SRC html
     <div id="container">{\n}
         <div id="header">{\n}
             <div id="avatar">{\n}
                 <a id="logo" href="/">{\n}
                     <img src="http://www.gravatar.com/avatar/d8a986606b9d5e4769ba062779e95d9f?s=45"{\n}
                          style="border: 1px solid #7F7F7F"/>{\n}
                 </a>{\n}
             </div>{\n}
             <div id="afor">{\n}
                 <h1>{$title}</h1>{\n}
             </div>{\n}
             <div id="clear"></div>{\n}
         </div>{\n}

         <div id="navigation">{\n}
             <ul>{\n}
                 {foreach $elt in $navpoints}{\n}
                 {call navelt data="$elt" /}{\n}
                 {/foreach}{\n}
             </ul>{\n}
         </div>{\n}

         <div id="clear"></div>{\n}

         {$columns | noAutoescape}{\n}

     </div>{\n}

     <div id="footer-container">{\n}
         <div id="footer">{\n}
             <p>{\n}
                 {$stat |noAutoescape}{\n}
             </p>{\n}
             <p id="back-top"><a href="#">Back to top</a></p>{\n}
         </div>{\n}
     </div>{\n}
   #+END_SRC

* Главная страница

  Главная страница состоит из нескольких блоков
  - блог
  - категории
  - social
  - latest
  - поиск
  - проекты
  - книги
  - доклады

  #+NAME: tpl_main
  #+BEGIN_SRC html
    <div id="content">
        <<tpl_blog>>
    </div>

    <div id="sidebar">
        <<tpl_about>>
        <<tpl_categoryes>>
        <<tpl_social>>
        <<tpl_latest>>
        <<tpl_search>>
        <img align="center" src="/img/john-mccarthy.jpg" />
    </div>

    <div id="sidebar">
        <<tpl_projects>>
    </div>

    <div id="sidebar">
        <<tpl_books>>
    </div>

    <div id="sidebar">
        <<tpl_lecture>>
    </div>
  #+END_SRC

  А вот маршрут, который все это использует

  #+NAME: route_main
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (restas:define-route main ("/")
      (let* ((lines (iter (for line in-file "afor.txt" using #'read-line) (collect line)))
             (line (nth (random (length lines)) lines))
             (data (list "Программирование - как искусство"
                         (menu)
                         (tpl:main (list :title line :links "")))))
        (destructuring-bind (headtitle navpoints content)
            data
          (tpl:root (list :headtitle headtitle
                          :stat (tpl:stat)
                          :navpoints navpoints
                          :title line
                          :columns
                          (tpl:main
                           (list
                            :articles
                            (tpl:mainposts
                             (list
                              :posts (sort (iter (for filename in (hash-table-keys *blogs*))
                                                 (let* ((orgdata     (gethash filename *blogs*))
                                                        (directives  (orgdata-directives orgdata))
                                                        (date        (getf directives :date)))
                                                   (when (null date) ;; Если даты нет - ставим самую большую
                                                     (setf date "31.12.9999"))
                                                   (setf (getf directives :timestamp) ;; Разбираем дату в timestamp
                                                         (cl-ppcre:register-groups-bind ((#'parse-integer date month year))
                                                             ("(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})" date)
                                                           (encode-universal-time  0 0 0 date month year 0)))
                                                   (setf (getf directives :content)
                                                         (orgdata-content orgdata))
                                                   (collect directives)))
                                           #'(lambda (a b) ;; сортировка - последние - вверху
                                               (> (getf a :timestamp)
                                                  (getf b :timestamp)))))))))))))

  #+END_SRC

** Блог

   Блог на главной странице представляет собой несколько последни
   постов, содержимое которых лежит в org-файлах в папке
   /content/blogs/*.org

   Мы должны выбрать оттуда все файлы, распарсить их и закешировать в
   хэш-таблице =*blogs*=

   #+NAME: declare_blogs
   #+BEGIN_SRC lisp
     (defparameter *blogs* (make-hash-table :test #'equal))
   #+END_SRC

   Для кеширования мы используем функцию =cache-section=:

   #+NAME: cache_blogs
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (cache-section *blogs* "content/blogs/")
   #+END_SRC

   #+NAME: tpl_post_main
   #+BEGIN_SRC html
     <article>
         <ul class="postinfo">
             <li>{$date |noAutoescape}</li>
             <li>Posted in <a href="#">Articles</a></li>
             <li><a href="#">Continue Reading &raquo;</a></li>
         </ul>
         <h2><a href="#">{$title |noAutoescape}</a></h2>
         {$content |noAutoescape}
     </article>
   #+END_SRC

   #+NAME: tpl_blog
   #+BEGIN_SRC html

     {$articles |noAutoescape}

     <div id="pagination">
         <ul>
             <li class="older"><a href="#">&laquo; Older posts</a></li>
             <li class="newer"><a href="#">Newer posts &raquo;</a></li>
         </ul>
     </div>
   #+END_SRC

** About

   #+NAME: tpl_about
   #+BEGIN_SRC html
     <section id="about">
         <h3>About me</h3>
         <p class="paragraph">
             Меня зовут Михаил Rigidus Глухов и я системный
             архитектор. На этом сайте я собираю материалы
             по интересующим меня темам.
         </p>
         <p class="paragraph">
             Мне интересна теория языков программирования, алгоритмика,
             робототехника и все что связано с интернетом вещей.
         </p>
         <p class="paragraph">
             <a href="#" class="bio">&laquo; Биография</a>
             <a href="#" class="contacts">Контакты &raquo;</a>
         </p>
     </section>
   #+END_SRC

** Categoryes

   #+NAME: tpl_categoryes
   #+BEGIN_SRC html
     <section id="categories">
         <h3>Categories</h3>
         <ul>
             <li><a href="#">Articles</a></li>
             <li><a href="#">Design</a></li>
             <li><a href="#">Graphics</a></li>
             <li><a href="#">Inspiration</a></li>
             <li><a href="#">Retro</a></li>
         </ul>
     </section>
   #+END_SRC

** Social

   #+NAME: tpl_social
   #+BEGIN_SRC html
     <section id="social">
         <h3>Social</h3>
         <ul>
             <li><a href="#">Twitter</a></li>
             <li><a href="#">Facebook</a></li>
             <li><a href="#">Flickr</a></li>
             <li><a href="#">Behance</a></li>
             <li><a href="#">Last.FM</a></li>
             <li><a href="#">YouTube</a></li>
         </ul>
     </section>
   #+END_SRC

** Latest

   #+NAME: tpl_latest
   #+BEGIN_SRC html
     <section id="latest">
         <h3>Latest posts</h3>
         <ul>
             <li><a href="#">Небольшой анонс</a></li>
             <li><a href="#">МиниКанрен</a></li>
         </ul>
     </section>
   #+END_SRC

** Search

   #+NAME: tpl_search
   #+BEGIN_SRC html
     <section id="search">
         <h3>Search</h3>

         <form method="get" action="#">
             <fieldset>
                 <input type="text" id="searchbar" placeholder="I'm looking for&hellip;" />
                 <input type="submit" id="searchsubmit" value="Search" />
             </fieldset>
         </form>
     </section>
   #+END_SRC

** Проекты

   #+NAME: tpl_projects
   #+BEGIN_SRC html
     <section id="about">
         <h3>Проекты</h3>

         <h4>Автоматический поиск работы <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Все программисты
             ищут (или искали) работу на профильных сайтах и каждый из них
             хоть раз задумывался об автоматизации рутинных операций.
         </p>
         <p class="paragraph">
             Я решил
             пойти дальше и разработал экспертную систему с элементами
             искусственного интеллекта, которая ищет работу за меня в полностью
             автоматическом режиме - от подбора вакансий до автоматической
             адаптации резюме.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Система автоматизированного тестирования <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Это как раз тот случай, когда Возможностей "селениума" не хватает
             для полноценного тестирования. Однажды мне захотелось тестировать
             не только web но и gui-приложения.
         </p>
         <p class="paragraph">
             Я решил написать маленький скрипт, способный действовать от имени
             пользователя, как если бы он сам манипулировал мышью и клавиатурой,
             считывая картинку на экране.
         </p>
         <p class="paragraph">
             Аппетит приходит во время еды и довольно скоро скрипт оброс
             распознованием экранных изображений, текстовых строк, их
             геометрического положения друг относительно друга и возможностями
             по построению тестовых сценариев прямо по тестируемому приложению
         </p>
         <p class="paragraph">
             Тут стало понятно, что инструмент стал достаточно универсальным,
             чтобы делать на нем совершенно разные приложения - от автоматических
             "извлекателей данных" до "проходилок игр".
         </p>
         <p class="paragraph">
             Тогда я решил привести его в порядок и выложить в open-source
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Моделирование электронных схем <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Задача моделирования цифровых электронных схем оказалась
             черезвычайно увлекательной, если подойти к ней не с инженерной
             точки зрения, а с точки зрения программиста.
         </p>
         <p class="paragraph">
             Распространение
             сигнала внутри схемы дает возможность иначе взглянуть на процесс
             программирования и отладки и применить очень необычные и мощные
             идеи.
         </p>
         <p class="paragraph">
             Я написал язык предметной области (DSL) для построения
             схем и виртуальную машину в которой он исполняется, чтобы получать
             результаты распространения сигнала в моделируемой схеме.
         </p>
         <p class="paragraph">
             Однако
             этого оказалось недостаточно для обеспечения наглядности, поэтому
             я изучил Tcl/Tk и запрограммировал визуализатор распространения
             сигнала, чтобы прямо на экране видеть, как высокие и низкие уровни
             двигаются от одного элемента к другому.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>

         <h4>Умный гараж с нуля <span>(хобби-проект)</span></h4>

         <p class="paragraph">
             Не первый опыт в автоматике и робототехнике, но пожалуй
             первый настолько масштабный проект.
         </p>
         <p class="paragraph">
             Ядром системы является платформа BeagleBoneBlack, остальная
             часть большей частью самодельная, с помощью ЛУТ и гремучей смеси
             современных микроконтроллеров и старых советских комплектующих,
             найденных непонятно где.
         </p>
         <p class="paragraph">
             Содержит систему автономного питания, вентиляции, освещения
             электронный замок и видеоконтроль периметра с элементами
             машинного зрения. Планируется добавить систему сопротивления
             вторжению в виде пейнтбольного маркера с наведением на движуюся
             цель.
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>
     </section>
   #+END_SRC

** Books

   #+NAME: tpl_books
   #+BEGIN_SRC html
     <section id="books">
         <h3>Книги</h3>

         <h4>Структура и интерпретация компьюетрных программ (SICP) <span>(книга)</span></h4>
         <p class="paragraph">
             Материал этой книги был основой вводного курса по информатике в MIT начиная с
             1980 года. К тому времени, как было выпущено первое издание, этот материал
             преподавался в течение четырех лет, и прошло еще двенадцать лет до появления второго
             издания.
         </p>
         <p class="paragraph">
             <a href="http://rigidus.ru/resources/sicp.pdf">Структура и интерпретация
                 компьютерных программ. Абельсон, Сассман (перевод: Ю. Бронников)</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Впечатления &raquo;</a>
         </p>

         <h4>Типы в языках программирования (TAPL) <span>(книга)</span></h4>
         <p class="paragraph">
             Книга о теории типов. Рассматриваются вопросы
             проверки и автоматического вывода типов в языках
             программирования со статической типизацией. Для каждой темы
             сначала дается теория, а затем приводится реализация на OCaml.
         </p>
         <p class="paragraph">
             TAPL — это, бесспорно, настоящий кладезь знаний для
             разработчиков языков программирования со статической
             типизацией.
         </p>
         <p class="paragraph">
             <a href="http://rigidus.ru/resources/tapl.pdf">Типы в языках программирования. Бенджамин Пирс</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more"></a>
         </p>
     </section>

   #+END_SRC

** Lecture

   #+NAME: tpl_lecture
   #+BEGIN_SRC html
     <section id="lecture">
         <h3>Доклады</h3>

         <h4>Литературное программирование <span>(доклад)</span></h4>
         <p class="paragraph">
             Слайды с лекции "Грамотное  программирование" (literate programming),
             которую я читал 22 января 2015 доступны
             здесь: <a href="http://slides.com/rigidusrigidus/deck#/">http://slides.com/rigidusrigidus/deck/</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>
         <h4>Макросы в Lisp<span>(доклад)</span></h4>
         <p class="paragraph">
             Видео, с доклада на ноябрьском FProg Meetup "Макросы в лиспе" опубликовано на youtube:
             <a href="https://www.youtube.com/watch?v=i1lD2J7qLLM">https://www.youtube.com/watch?v=i1lD2J7qLLM</a>
         </p>
         <p class="paragraph">
             <a href="#" class="more">Подробнее &raquo;</a>
         </p>


         <h4>Как проектируюттся IP-блоки и системы на кристалле <span style="display: block">(конспект лекции)</span></h4>
         <p class="paragraph">
             Юрий Панчул прочитал эту лекцию в Алма-Ате и я подготовил
             небольшой конспект. Осталось немного довести его до ума
             и я выложу его на сайт, а пока доступно
             <a href="https://www.youtube.com/watch?v=sPaMiEunT_M">видео</a>,
             <a href="http://www.silicon-russia.com/public_materials/2016_09_01_kazakhstan/day_1_industry/03_slides/03_extra_eda_flow_2015_10_25.pdf">слайды</a> и его
             <a href="https://habrahabr.ru/post/309570/">отчетный пост</a>
             на хабре.
         </p>
     </section>

   #+END_SRC

* Конечный автомат разбора орг-файлов

  #+NAME: orgdata_fsm
  #+BEGIN_SRC emacs-lisp
    (setf *fsm*
          '((start (setf space-cnt 0)
                   ((spc         space         (incf space-cnt))
                    (tire        minus         )
                    (star        headstar      (setf head-cnt 0))
                    (at          dirkey        (set-empty dirkey-content))
                    (word        paragraph     (start-paragraph) (setf paragraph cur))
                    ;; (ret         start         (start-paragraph) (end-paragraph))
                    ))
            (space
             ((spc        space          (incf space-cnt))
              (ret        start          (out empty-paragraph))
              (tire       minus          )
              ))
            (minus
             ((star       mode           )
              (spc        ul             (open-list))
              ))
            (ul
             ((not-ret    li             )
              (ret        start          (close-list))
              ))
            (li (setf li-content cur)
                ((not-ret    li             (cur+ li-content))
                 (ret        ul             (out li-content))
                 ))
            (mode
             ((not-ret    mode           )
              (ret         start          )
              ))
            (headstar
             ((star       headstar       (incf head-cnt))
              (space      heading        )
              ))
            (heading
             ((not-ret    heading        (cur+ head-content))
              (ret        start          (out head-content head-cnt))
              ))
            (dirkey
             ((word       dirkey         (cur+ dirkey-content))
              (space      dirval         (set-empty dirval-content))
              ))
            (dirval
             ((word       dirval         (cur+ dirval-content))
              (ret        start          (out dirkey dirval))
              ))
            (paragraph
             ((word-or-space  paragraph  (cur+ paragraph))
              (ret       par_ret         )
              ))
            (par_ret
             ((space     par_ret         (cur+ paragraph))
              (ret       start           (out paragraph))
              (word      paragraph       (cur+ paragrah))
              ))
            ))
  #+END_SRC

  #+NAME: orgdata_fsm
  #+BEGIN_SRC emacs-lisp :results output
    (let ((pre-actions))
      (mapcar #'(lambda (record)
                  (let ((src (car record)))
                    ;; Если у состояния есть входное действие - записываем pre-action
                    (if (equal 3 (length record))
                        (progn
                          (push src pre-actions)
                          (princ (format "%s [label=\"%s | %s\" shape=\"record\"];\n" src (cadr record) src)))
                      (princ (format "%s [label=\"%s\" shape=\"box\"];\n" src src)))
                    (mapcar #'(lambda (edge)
                                (let ((op (cddr edge))
                                      (dst (nth 1 edge)))
                                  (case (length op)
                                    ((0) (setf op ""))
                                    ((1) (setf op (car op)))
                                    (otherwise (setf op (append '(progn ) op))))
                                  ;; Рисуем переход
                                  (princ (format "%s -> %s [label =\"%s\" taillabel=\"%s\" labelfontcolor=\"red\" labelfontsize=\"12\"];\n"
                                                 src dst op (nth 0 edge)))))
                            (car (last record)))))
              ,*fsm*))
  #+END_SRC

  #+BEGIN_SRC dot :file zzz.png :var input=orgdata_fsm :exports results
    digraph G {
      rankdir = LR;
      $input
    }
  #+END_SRC

  #+results:
  [[file:zzz.png]]


  #+NAME: gen_parser
  #+BEGIN_SRC emacs-lisp :exports none :results code pp
    ;; Тут можно генерировать код по языку
    *fsm*
  #+END_SRC

  #+NAME: event_entity
  #+BEGIN_SRC lisp :tangle entityes.lisp :noweb tangle :exports none :padline no :comments link
    ;; А тут мы вызываем генератор кода и записываем результат в файл
    <<gen_parser()>>
  #+END_SRC


* Работа с org-файлами

  OrgMode - это режим редактирования и организации заметок,
  планирования, и разработки в свободном текстовом редакторе Emacs.

  Файлы *.org включают в себя простые метки для обозначения уровней
  иерархии, блоков кода, списков и других элементов.

  Для отображения содержимого org-файлов мы будем использовать
  специальные render-функции и парсеры.

  Начнем с того, что опредилим класс для хранения содержимого
  org-файла. Он будет иметь слоты для содержимого, списка секций и
  специальных директив.

  #+NAME: orgdata_class
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defclass orgdata ()
      ((content    :accessor orgdata-content)
       (sections   :accessor orgdata-sections)
       (directives :accessor orgdata-directives)))
  #+END_SRC

  Теперь определим парсер для орг-файлов:

  #+NAME: org_parser
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defgeneric parse-org (src)
      (:documentation "Transform org markup into orgdata object"))

    (defmethod parse-org ((file pathname))
      (parse-org (alexandria:read-file-into-string file)))

    (defmethod parse-org ((org-content string))
      ;; Разбиваем входный текст по строкам
      (let ((strings (split-sequence:split-sequence #\NewLine org-content))
            (sections)    ;; Информация о заголовках секций
            (mode nil)    ;; Режим в котором мы находимся
            (directives)  ;; Директивы, например @category
            (br 0)        ;; Счетчик переводов строки для вывода обычного текста
            (save)        ;; Внутренняя переменная для сохранения и последующего вывода в файл
            (result (make-instance 'orgdata)))
        ;; Возвратим html
        (setf (orgdata-content result)
              (format nil "~{~A~%~}"
                      (remove-if #'(lambda (line)
                                     (search "ℕ" line))
                                 ;; Для каждой строки из списка строк
                                 (loop :for line :in strings
                                    :collect
                                    (progn
                                      ;; Удаляем директиву -*-
                                      (when (search "-*-" line)
                                        (setf line "ℕ"))
                                      ;; Директивы
                                      (find-directive "@title")
                                      (find-directive "@category")
                                      (find-directive "@sort")
                                      (find-directive "@date")
                                      ;; *
                                      (when (ppcre:scan "\\A\\*+\\s+" line)
                                        (setf line
                                              (let ((cnt 1)) ;; Подcчитаем количество звездочек
                                                (loop :for item :across line :do
                                                   (if (char= #\* item)
                                                       (incf cnt)
                                                       (return)))
                                                (let ((headline (subseq line cnt)))
                                                  (push (list cnt headline) sections)
                                                  (format nil "<h~a><a name=\"anchor-~a\">~a</a></h~a>"
                                                          cnt (length sections) headline cnt)))))
                                      ;; @/code
                                      (find-command "@/code" (setf (getf mode :code) nil) (setf line "</pre>"))
                                      (find-command "</source" (setf (getf mode :code) nil) (setf line "</pre>"))
                                      ;; ;; @store
                                      ;; (find-command "@store"
                                      ;;               (with-open-file (fstream (path tail) :direction :output :if-exists :supersede)
                                      ;;                 (format fstream "~{~a~%~}"
                                      ;;                         (loop :for i :in (reverse save)
                                      ;;                            :unless (search "ℕ" i)
                                      ;;                            :collect i))))
                                      ;; ;; @append
                                      ;; (find-command "@append"
                                      ;;               (with-open-file (fstream (path tail) :direction :output :if-exists :append)
                                      ;;                 (format fstream "~{~a~%~}"
                                      ;;                         (loop :for i :in (reverse save)
                                      ;;                            :unless (search "ℕ" i)
                                      ;;                            :collect i))))
                                      ;; mode:code
                                      (when (getf mode :code)
                                        (push line save)
                                        (setf line (format nil "~a" (ppcre:regex-replace-all "<" line "&lt;"))))
                                      ;; Проверка на малый разделитель
                                      (when (ppcre:scan "\\A\\-{3,}" line)
                                        (setf line "<div class=\"divider\">.</div>"))
                                      ;; Проверка на большой разделитель
                                      (when (ppcre:scan "\\A\\={3,}(.*)" line)
                                        (setf line
                                              (cl-ppcre:regex-replace "\\A\\={3,}(.*)" line
                                                                      (list #'(lambda (match reg)
                                                                                (declare (ignore match))
                                                                                (format nil "~a<div ~a ~a>~a~a"
                                                                                        "<div class=\"divider\">.</div>"
                                                                                        "class=\"guideNum\""
                                                                                        "id=\"config-options\""
                                                                                        reg
                                                                                        "<a href=\"#top\">top</a></div>")))
                                                                      :simple-calls t)))
                                      ;; default
                                      (setf line
                                            (if (not (string= "" line))
                                                line
                                                (progn
                                                  (incf br)
                                                  (if (> br 1)
                                                      (progn
                                                        (setf br 0)
                                                        "<p>")
                                                      "</p>"))))
                                      ;; @code
                                      (if (or (equal 0 (search "@code" line))
                                              (equal 0 (search "<source" line)))
                                          (prog1
                                              "<pre>"
                                            (setf save nil)
                                            (setf (getf mode :code) t))
                                          ;; else
                                          line))))))
        ;; заголовки секций (в обратном порядке)
        (setf (orgdata-sections result)
              (reverse sections))
        ;; директивы
        (setf (orgdata-directives result)
              directives)
        result))
  #+END_SRC

  Этот парсер использует макросы для поиска комманд и директив в
  разбираемой строке. Определим их:

  #+NAME: org_macro
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    ;; Макрос использует внешние символы line и tail
    (defmacro find-command (str body &optional (replace '(setf line "ℕ")))
      `(when (equal 0 (search ,str line))
         (let ((tail (handler-case (subseq line (+ 1 (length ,str)))
                       (SB-KERNEL:BOUNDING-INDICES-BAD-ERROR () ,str))))
           ,body
           ,replace)))

    ;; Макрос использует внешние символы directives и tail
    (defmacro find-directive (directive)
      `(find-command ,directive
                     (setf (getf directives (intern (string-upcase (subseq ,directive 1)) :keyword))
                           (string-trim '(#\  #\tab #\Newline) tail))))
  #+END_SRC

  Также определим функцию =find-articles-by-category= которая
  понадобится нам, чтобы получить все статьи категории.

  Эта функция принимает =global-var-hash= в котором ищет все статьи, у
  которых @category соотвествует параметру =category=.

  #+NAME: find_articles_by_category
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun find-articles-by-category (category global-var-hash subst)
      "Возвращает все статьи, у которых @category соотвествует параметру"
      (sort (iter (for filename in (hash-table-keys global-var-hash))
                  (let ((directives (orgdata-directives (gethash filename global-var-hash))))
                    (when (string= category (getf directives :category))
                      (collect (list :title (getf directives :title)
                                     :link  (concatenate 'string subst filename)
                                     :sort  (getf directives :sort))))))
            #'string<
            :key #'(lambda (x) (getf x :title))))
  #+END_SRC

  Теперь соберем все это в один файл

  #+NAME: orgmode
  #+BEGIN_SRC lisp :tangle orgmode.lisp :noweb tangle :exports code :padline no :comments link
    (in-package #:rigidus)

    <<org_macro>>

    <<find_articles_by_category>>

    <<org_parser>>
  #+END_SRC

* Шаблон для orgdata

  Этот шаблон предназначен для использования в рендеринге
  org-файлов. Он содержит переменную =contents= которая заменяется на
  содержимое orgdata-content и переменную =guideNav= которая содержит
  иерархическое оглавление org-sections. Еще он содержить заголовок
  =title=.

  #+NAME: tpl_org
  #+BEGIN_SRC html
    <div id="content">
        <ul class="postinfo">
            <li>17th October 2016</li>
            <li>Posted in <a href="#">Articles</a></li>
            <li><a href="#">Continue Reading &raquo;</a></li>
        </ul>
        <article>
            <h2>{$title | noAutoescape}</h2>
            {$content | noAutoescape}
        </article>
    </div>

    <div id="sidebar">
        <section id="about">
            <h3>Содержание</h3>
            <div id="guideNav">
                 <ul>
                     {foreach $elt in $sections}
                         {call sectelt data="$elt" /}
                     {/foreach}
                 </ul>
             </div>
        </section>
    </div>

    <div id="sidebar">
        <section id="tags">
            <h3>Tags</h3>
            <ul>
                <li><a href="#">Articles</a></li>
                <li><a href="#">Design</a></li>
                <li><a href="#">Graphics</a></li>
                <li><a href="#">Inspiration</a></li>
                <li><a href="#">Retro</a></li>
            </ul>
        </section>
    </div>

    <div id="sidebar">
        <section id="categories">
            <h3>Categories</h3>
            <ul>
                <li><a href="#">Сети доверия</a></li>
                <li><a href="#">Articles</a></li>
                <li><a href="#">Design</a></li>
                <li><a href="#">Graphics</a></li>
                <li><a href="#">Inspiration</a></li>
                <li><a href="#">Retro</a></li>
            </ul>
        </section>
    </div>
  #+END_SRC

* Страница раздела

  Страница раздела представляет собой рендер орг-файла, в котором
  находятся директивы =find-article-by-category=.

  Чтобы не осуществлять поиск по соответствия категории каждый раз,
  когда запрашивается страница раздела мы кэшируем страницу
  раздела. Для этого используется функция =cache-page=

  #+NAME: cache_page
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun process-directive-make-list-by-category (data global-var-hash subst)
      (ppcre:regex-replace-all
       "@make-list-by-category(.*)@"
       (orgdata-content data)
       (list #'(lambda (match reg)
                 (declare (ignore match))
                 (let* ((instr (string-trim '(#\Space #\Tab #\Newline) reg)))
                   (multiple-value-bind (star color category)
                       (values-list (split-sequence:split-sequence #\Space instr))
                     (format nil
                             "<ul>~{~a~}</ul>"
                             (iter (for x in (sort (find-articles-by-category category global-var-hash subst)
                                                   #'string<
                                                   :key #'(lambda (x) (getf x :sort))))
                                   (collect (tpl:li (append x (list :star star :color color))))))))))
       :simple-calls t))

    (defun cache-page (relative-filepath global-var-hash subst)
      (let ((data (parse-org relative-filepath)))
        (setf (orgdata-content data)
              (process-directive-make-list-by-category data global-var-hash subst))
        data))
  #+END_SRC

  Для того, чтобы эта функция отработала нормально необходимо перед ее
  вызовом закешировать содержимое раздела. Для этого используется
  функция =cache-section=:

  #+NAME: cache_section
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun cache-section (global-var-hash relative-filepath)
      "Функция кеширует в хеш-таблице содержимое каталога"
      (loop :for file :in  (get-directory-contents relative-filepath) :do
         (setf (gethash (pathname-name file) global-var-hash)
               (parse-org file))))
  #+END_SRC

  Эта функция в свою очередь использует =get-directory-contents= для
  получения содержимого каталога:

  #+NAME: get_directory_contents
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (defun get-directory-contents (path)
      "Функция возвращает содержимое каталога"
      (when (not (equal "/" (coerce (last (coerce path 'list)) 'string)))
        (setf path (format nil "~A/" path)))
      (directory (format nil "~A*.*" path)))
  #+END_SRC

* Страница org-файла

  Вот маршрут для статей:

  #+NAME: route_article
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    (let ((h-articles (make-hash-table :test #'equal)))
       (def/route article ("articles/:strkey")
         (multiple-value-bind (article isset)
             (gethash strkey h-articles)
           (if isset
               (render article)
               (let* ((filename (format nil "content/articles/~A.org" strkey))
                      (truename (probe-file filename)))
                 (if (null truename)
                     (page-404)
                     (let ((data (parse-org truename)))
                       (setf (orgdata-content data)
                             (process-directive-make-list-by-category data h-articles "subst"))
                       (destructuring-bind (headtitle navpoints)
                           (list "title" (menu))
                         (tpl:root (list :headtitle (getf (orgdata-directives data) :title)
                                         :stat (tpl:stat)
                                         :navpoints navpoints
                                         :title (getf (orgdata-directives data) :title)
                                         :columns (tpl:org (list :content (orgdata-content data)))))))))))))
  #+END_SRC

* Рендеринг

  Для того чтобы превращать объект orgdata в страничку используем
  унифицированный рендеринг:

  #+NAME: renders
  #+BEGIN_SRC lisp
    (in-package #:rigidus)

    ;; Рендер для списков
    (defmethod render ((data list))
      (destructuring-bind (headtitle navpoints content)
          data
        (tpl:root (list :headtitle headtitle
                        :stat (tpl:stat)
                        :navpoints navpoints
                        :title headtitle
                        :columns (tpl:org (list :content content))))))

    ;; Рендер для pathname
    (defmethod render ((file pathname))
      (if (string= (pathname-type file) "org")
          (render (parse-org file))
          (call-next-method)))

    ;; Рендер для orgdata
    (defmethod render ((data orgdata))
      (let* ((content     (concatenate 'string (orgdata-content data)))
             (sections    (orgdata-sections data))
             (directives  (orgdata-directives data))
             (title       (getf directives :title)))
        (tpl:root (list :headtitle title
                        :stat (tpl:stat)
                        :navpoints (menu)
                        :title title
                        :columns
                        (tpl:org (list :content content
                                       :sections (iter (for i from 1)
                                                       (for section in sections)
                                                       (collect (list :anchor (format nil "anchor-~a" i)
                                                                      :level (format nil "level-~a" (car section))
                                                                      :title (cadr section))))))))))
  #+END_SRC

* Определения модуля

  #+NAME: defmodule
  #+BEGIN_SRC lisp :tangle defmodule.lisp :noweb tangle :exports code :padline no :comments link
    (restas:define-module #:rigidus
      (:use #:closer-mop #:cl #:iter #:alexandria #:anaphora #:postmodern)
      (:shadowing-import-from :closer-mop
                              :defclass
                              :defmethod
                              :standard-class
                              :ensure-generic-function
                              :defgeneric
                              :standard-generic-function
                              :class-name))

    (in-package #:rigidus)

    <<utility>>

    <<orgdata_class>>

    <<renders>>

    (setf asdf:*central-registry*
          (remove-duplicates (append asdf:*central-registry*
                                     (list (make-pathname :directory (list :relative (sb-posix:getcwd)))))
                             :test #'equal))

    (defparameter *basedir* (make-pathname :directory (list :relative (sb-posix:getcwd))))

    (defun path (relative)
      (merge-pathnames relative *basedir*))

    (defparameter *articles* (make-hash-table :test #'equal))
    (defparameter *cached-articles-page* nil)

    (defparameter *aliens* (make-hash-table :test #'equal))
    (defparameter *cached-alien-page* nil)

    <<declare_blogs>>
    (defparameter *cached-blogs-page* nil)


    #| POSTGRESQL
    вставить в /etc/postgresql/<version>/main/pg_hba.conf
    local all all trust
    чтобы он доверял локальным пользователям
    потом переключаемся в пользователя postgres и создаем базу
    createuser -DRS <dbuser>
    createdb -l ru_RU.UTF-8 -T template0 -O <dbuser> <dbname>
    psql
    alter user <dbuser> with password '<dbpassword>';
    |#

    ;; (defparameter *db-name* "rigidusdb")
    ;; (defparameter *db-user* "rigidus")
    ;; (defparameter *db-pass* "rigidus1234")
    ;; (defparameter *db-serv* "localhost")
    ;; (defparameter *db-spec* (list *db-name* *db-user* *db-pass* *db-serv*))
    ;; (connect-toplevel *db-name* *db-user* *db-pass* *db-serv*)
    ;; (disconnect-toplevel)
    ;; (defparameter *db-connection* (connect *db-name* *db-user* *db-pass* *db-serv*))


    ;; (defmacro incrementor (name fld)
    ;;   `(let ((,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) 0))
    ;;      (list
    ;;       (defun ,(intern (format nil "INCF-~A-~A" (symbol-name name) (symbol-name fld)())) ()
    ;;         (incf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld)))))
    ;;       (defun ,(intern (format nil "INIT-~A-~A" (symbol-name name) (symbol-name fld) ())) (init-value)
    ;;         (setf ,(intern (format nil "INC-~A-~A" (symbol-name name) (symbol-name fld))) init-value)))))


    ;; (progn
    ;;   (incrementor comment id)
    ;;   (defclass comment () ;; definition of COMMENT
    ;;     ((id     :col-type integer    :initarg :id     :initform (incf-comment-id) :accessor id)
    ;;      (key    :col-type string     :initarg :key    :initform ""  :accessor key)
    ;;      (parent :col-type integer    :initarg :parent :initform ""  :accessor parent)
    ;;      (msg    :col-type string     :initarg :msg    :initform ""  :accessor msg)
    ;;      (childs                      :initarg :childs :initform nil :accessor childs))
    ;;     (:metaclass dao-class)
    ;;     (:keys id))
    ;;   ;; (unless (table-exists-p "comment") ;; create table COMMENT if not exists
    ;;     (with-connection (list *db-name* *db-user* *db-pass* *db-serv*)
    ;;       (query (sql (:drop-table :if-exists 'comment)))
    ;;       (execute (dao-table-definition 'comment))))
    ;; ;; )

    ;; (progn
    ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "first comment")))
    ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "second comment"))
    ;;   (let ((a (make-dao 'comment :key "TEST" :parent 0 :msg "third comment")))
    ;;     (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 1")
    ;;     (let ((b (make-dao 'comment :key "TEST" :parent (id a) :msg "parent comment 2")))
    ;;       (make-dao 'comment :key "TEST" :parent (id b) :msg "sub parent comment 2"))))
  #+END_SRC

* Sape

   #+NAME: sape

   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)


     (defun base64-cookies ()
       (let* ((cookies   (hunchentoot:cookies-out*))
              (serialize (mapcar #'(lambda (x)
                                     (let ((name (car x))
                                           (value (hunchentoot:cookie-value (cdr x))))
                                       (format nil "s:~d:\"~a\";s:~d:\"~a\";"
                                               (length name)
                                               name
                                               (length value)
                                               value)))
                                 cookies))
              (seri-str  (format nil "a:~d:{~a}"
                                 (length cookies)
                                 (if (null cookies)
                                     ""
                                     (format nil "~{~a~}" serialize)))))
         (base64:string-to-base64-string seri-str)))

     (defun recode (content from to)
       (sb-ext:octets-to-string (sb-ext:string-to-octets content :external-format from) :external-format to))

     (defun get-sape-links (uri)
       (let ((rs "")
             (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "links.php")))
                                          :environment (append (sb-ext:posix-environ)
                                                               (list (format nil "REQUEST_URI=~a" uri))
                                                               (list (format nil "COOKIE=~a" (base64-cookies))))
                                          :wait t
                                          :input nil
                                          :output :stream)))
         (unwind-protect
              (with-open-stream (out (sb-ext:process-output extproc))
                (do ((c (read-char out) (read-char out nil 'the-end)))
                    ((not (characterp c)))
                  (setf rs (concatenate 'string rs (string c))))))
         (when extproc
           (sb-ext:process-close extproc)
           (sb-ext:process-exit-code extproc))
         ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
         (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :cp1251))
         ))

     (defun get-sape-context (uri content)
       (let* ((rs "")
              (input-stream (make-string-input-stream content)) ;; no recode - utf-8
              (extproc (sb-ext:run-program "/usr/bin/php" `("-q" ,(format nil "~a" (path "context.php")))
                                           :environment (append (sb-ext:posix-environ)
                                                                (list (format nil "REQUEST_URI=~a" uri))
                                                                (list (format nil "COOKIE=~a" (base64-cookies))))
                                           :wait t
                                           :input input-stream
                                           :output :stream)))
         (unwind-protect
              (with-open-stream (out (sb-ext:process-output extproc))
                (do ((c (read-char out) (read-char out nil 'the-end)))
                    ((not (characterp c)))
                  (setf rs (concatenate 'string rs (string c))))))
         (when extproc
           (sb-ext:process-close extproc)
           (sb-ext:process-exit-code extproc))
         ;; latin-1 = :ISO8859-1 = :cp1252 (http://ru.wikipedia.org/wiki/ISO_8859-1)
         (format nil "~a" (recode (base64:base64-string-to-string rs) :ISO8859-1 :utf-8))))
   #+END_SRC
* Маршруты
** Страница 404

   #+NAME: route_404
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (defun page-404 (&optional (title "404 Not Found") (content "Страница не найдена"))
       (let* ((title "404 Not Found"))
         (tpl:root (list :headtitle title
                         :stat (tpl:stat)
                         :navpoints (menu)
                         :title title
                         :columns "<br/><br /><br/><br /><h2>404 Not Found</h2><br/><br /><br/><br />"))))

     (restas:define-route not-found-route ("*any")
       (restas:abort-route-handler
        (page-404)
        :return-code hunchentoot:+http-not-found+
        :content-type "text/html"))
   #+END_SRC

** Страница robots.txt

   #+NAME: route_robots
   #+BEGIN_SRC lisp
     (in-package #:rigidus)

     (restas:define-route robots ("/robots.txt")
       (format nil "User-agent: *~%Disallow: "))
   #+END_SRC

   #+NAME: routes
   #+BEGIN_SRC lisp :tangle routes.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)

     (defclass rigidus-render () ())

     <<route_robots>>

     <<route_404>>

     <<route_main>>

     <<route_article>>

     ;; TODO: blog

     ;; plan file pages

     (def/route about ("about")
       (render #P"content/about.org"))

     (def/route resources ("resources")
       (render #P"content/resources.org"))

     (def/route faq ("faq")
       (render #P"content/faq.org"))

     (def/route contacts ("contacts")
       (render #P"content/contacts.org"))

     (def/route radio ("radio")
       (render #P"content/radio.org"))


     ;; showing articles

     (defun show-article-from-hash (strkey hash)
       (multiple-value-bind (article isset)
           (gethash strkey hash)
         (unless isset
           (restas:abort-route-handler
            (page-404)
            :return-code hunchentoot:+http-not-found+
            :content-type "text/html"))
         article))


     (def/route articles ("articles")
       (render *cached-articles-page*))

     (def/route aliens ("aliens")
       (render *cached-alien-page*))

     (def/route alien ("alien/:strkey")
       (render (show-article-from-hash strkey *aliens*)))

     ;; TODO
     ;; (restas:define-route onlisp ("onlisp/doku.php")
     ;;   (let* ((content (tpl:onlisp))
     ;;          (title "Перевод книги Пола Грэма \"On Lisp\"")
     ;;          (menu-memo (menu)))
     ;;     (render
     ;;      (list title
     ;;            menu-memo
     ;;            (tpl:default
     ;;                (list :title title
     ;;                      :navpoints menu-memo
     ;;                      :sections ""
     ;;                      :links ""
     ;;                      :content content))))))

     (require 'bordeaux-threads)

     ;; (defparameter *serial-status* nil)
     ;; (defparameter *serial-lock*   (bordeaux-threads:make-lock "serial-lock"))

     ;; (defun serial-getter ()
     ;;   (tagbody
     ;;    re
     ;;      (bordeaux-threads:acquire-lock *serial-lock* t)
     ;;      (with-open-file (stream "/dev/ttyACM0"
     ;;                              :direction :io
     ;;                              :if-exists :overwrite
     ;;                              :external-format :ascii)
     ;;        (setf *serial-status* (format nil "~C" (read-char stream))))
     ;;      (bordeaux-threads:release-lock *serial-lock*)
     ;;      (go re)))


     ;; (defparameter *serial-thread* (bordeaux-threads:make-thread #'serial-getter :name "serial-getter"))

     ;; ;; stty -F /dev/ttyACM0 cs8 9600 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke noflsh -ixon -crtscts raw

     ;; (restas:define-route test ("test")
     ;;   (with-open-file (stream "/dev/ttyACM0"
     ;;                           :direction :io
     ;;                           :if-exists :overwrite
     ;;                           :external-format :ascii)
     ;;     (format stream "9"))
     ;;   (sleep 1)
     ;;   (let ((tmp (parse-integer *serial-status*))
     ;;         (rs  nil))
     ;;     (if (equal 2 (logand tmp 2))
     ;;         (setf rs (append rs (list :red "checked")))
     ;;         (setf rs (append rs (list :darkred "checked"))))
     ;;     (if (equal 1 (logand tmp 1))
     ;;         (setf rs (append rs (list :lightgreen "checked")))
     ;;         (setf rs (append rs (list :green "checked"))))
     ;;     (let* ((content (tpl:controltbl rs))
     ;;            (title "Control Service")
     ;;            (menu-memo (menu)))
     ;;       (render (list title
     ;;                     menu-memo
     ;;                     (tpl:default
     ;;                         (list :title title
     ;;                               :navpoints menu-memo
     ;;                               :content content)))))))

     ;; (restas:define-route test-post ("test" :method :post)
     ;;   (let ((rs 0))
     ;;     (when (string= (hunchentoot:post-parameter "red") "on")
     ;;       (setf rs (logior rs 2)))
     ;;     (when (string= (hunchentoot:post-parameter "green") "on")
     ;;       (setf rs (logior rs 1)))
     ;;     (with-open-file (stream "/dev/ttyACM0"
     ;;                             :direction :io
     ;;                             :if-exists :overwrite
     ;;                             :external-format :ascii)
     ;;       (format stream "~A" rs))
     ;;     (hunchentoot:redirect "/test")))

     ;; submodules

     (restas:mount-module -css- (#:restas.directory-publisher)
       (:url "/css/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/css")) (user-homedir-pathname))))

     (restas:mount-module -font- (#:restas.directory-publisher)
       (:url "/font/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/font")) (user-homedir-pathname))))

     (restas:mount-module -js- (#:restas.directory-publisher)
       (:url "/js/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/js"))  (user-homedir-pathname))))

     (restas:mount-module -img- (#:restas.directory-publisher)
       (:url "/img/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/img")) (user-homedir-pathname))))

     (restas:mount-module -resources- (#:restas.directory-publisher)
       (:url "/resources/")
       (restas.directory-publisher:*directory* (merge-pathnames (make-pathname :directory '(:relative "repo/rigidus.ru/resources")) (user-homedir-pathname)))
       (restas.directory-publisher:*autoindex* t))

   #+END_SRC
* Инициализация

   #+NAME: sape
   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)

     (defun menu ()
       (list (list :link "/" :title "Главная")
             (list :link "/about" :title "Об авторе")
             ;; Тут надо резюме
             ;; (list :link "/blog/" :title "Блог")
             (list :link "/articles/" :title "Статьи")
             (list :link "/aliens/" :title "Материалы")
             (list :link "/resources/" :title "Ресурсы")
             (list :link "/faq/" :title "FAQ")
             ;; (list :link "/job/" :title "О, работа!")
             (list :link "/contacts" :title "Контакты")))

     <<get_directory_contents>>

     <<cache_section>>

     <<cache_page>>

     (defun load-org ()
       ;; *articles* *aliens* *asdf*
       (cache-section *articles* "content/articles/")
       (cache-section *aliens*   "content/aliens/")
       <<cache_blogs>>
       ;; cached pages
       (setf *cached-articles-page* (cache-page #P"content/articles.org" *articles* "/articles/"))
       (setf *cached-alien-page*    (cache-page #P"content/alien.org"    *aliens*   "/alien/"))
       (setf *cached-blogs-page*    (cache-page #P"content/blogs.org"    *blogs*   "/blogs/")))

     (load-org)

     (orgdata-directives (gethash "asdf-foreword" *aliens*))
     (orgdata-directives (gethash "asdf-architecture" *aliens*))

     ;; start
     (restas:start '#:rigidus :port 9993)
     (restas:debug-mode-on)
     ;; (restas:debug-mode-off)
     (setf hunchentoot:*catch-errors-p* t)


     ;; (maphash #'(lambda (k v)
     ;;             ;; (print (orgdata-content v)))
     ;;              (print (orgdata-directives v)))
     ;;         *blogs*)
   #+END_SRC

* Sape

   #+NAME: sape
   #+BEGIN_SRC lisp :tangle sape.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:rigidus)
   #+END_SRC

* Демонизация

   #+NAME: daemon_conf
   #+BEGIN_SRC lisp :tangle daemon.conf :noweb tangle :exports code :padline no :comments link
     (:main-function
      #.(lambda ()
          ;;Providing true pathname to your start swank server script
          (load (format nil "/home/~A/repo/rigidus.ru/daemon.lisp"
                        (sb-posix:passwd-name
                         (sb-posix:getpwuid
                          (sb-posix:stat-uid
                           (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))
                ))
      ;; Default directory for pid files is system directory of this asdf system
      :pid-file "daemon-rigidus"
      :exit t
      :name nil
      :user nil
      :group nil
      :before-parent-exit-fn nil)
   #+END_SRC

   #+NAME: daemon
   #+BEGIN_SRC lisp :tangle daemon.lisp :noweb tangle :exports code :padline no :comments link
     (require 'swank)
     (swank:create-server :dont-close t :port 6777)
     (push (pathname (format nil "/home/~A/repo/rigidus.ru/"
                             (sb-posix:passwd-name
                              (sb-posix:getpwuid
                               (sb-posix:stat-uid
                                (sb-posix:stat (format nil "/proc/~A" (sb-posix:getpid)))))))) asdf:*central-registry*)
     (asdf:oos 'asdf:load-op :rigidus)
   #+END_SRC

   #+NAME: sape
   #+BEGIN_SRC shell :tangle daemon.sh :noweb tangle :exports code :padline no :comments link
     $(pwd)/../daemonization/scripts/daemon.sh $(pwd)/daemon.conf $1
   #+END_SRC

* Шаблон статистики

  Это статистика от яндекса

  #+NAME: tpl_stat
  #+BEGIN_SRC html
    {literal}
      <div style="margin-top: -29px; margin-left: 150px;">
          <!--Google Analitics -->
          <script type="text/javascript">
              var _gaq = _gaq || [];
              _gaq.push(['_setAccount', 'UA-20801780-1']);
              _gaq.push(['_trackPageview']);
              (function() {
              var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
              ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
              var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
              })();
          </script>
          <!--Google Analitics -->

          <!--LiveInternet counter-->
          <script type="text/javascript">
              <!--
                   document.write("<a href='http://www.liveinternet.ru/click' "+
                   "target=_blank><img src='//counter.yadro.ru/hit?t24.5;r"+
                   escape(document.referrer)+((typeof(screen)=="undefined")?"":
                   ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
                   screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
                   ";h"+escape(document.title.substring(0,80))+";"+Math.random()+
                   "' alt='' title='LiveInternet: показано число посетителей за"+
                   " сегодня' "+
                   "border='0' width='88' height='15'><\/a>")
         //-->
          </script>
          <!--/LiveInternet-->
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

          <!-- Yandex.Metrika informer -->
          <a href="https://metrika.yandex.ru/stat/?id=3701317&amp;from=informer"
          target="_blank" rel="nofollow"><img src="//bs.yandex.ru/informer/3701317/1_0_9F9F9FFF_7F7F7FFF_0_pageviews"
          style="width:80px; height:15px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры)"
                                              onclick="try{Ya.Metrika.informer({i:this,id:3701317,lang:'ru'});return false}catch(e){}"/></a>
          <!-- /Yandex.Metrika informer -->

          <!-- Yandex.Metrika counter -->
          <script type="text/javascript">
          (function (d, w, c) {
              (w[c] = w[c] || []).push(function() {
                  try {
                      w.yaCounter3701317 = new Ya.Metrika({id:3701317,
                              webvisor:true,
                              clickmap:true,
                              trackLinks:true,
                              accurateTrackBounce:true});
                  } catch(e) { }
              });

              var n = d.getElementsByTagName("script")[0],
                  s = d.createElement("script"),
                  f = function () { n.parentNode.insertBefore(s, n); };
              s.type = "text/javascript";
              s.async = true;
              s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

              if (w.opera == "[object Opera]") {
                  d.addEventListener("DOMContentLoaded", f, false);
              } else { f(); }
          })(document, window, "yandex_metrika_callbacks");
          </script>
          <noscript><div><img src="//mc.yandex.ru/watch/3701317" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
          <!-- /Yandex.Metrika counter -->
    {/literal}
  #+END_SRC

* Сборка
** Утилиты

   #+NAME: utility
   #+BEGIN_SRC lisp
     (in-package :rigidus)

     (defmacro bprint (var)
       `(subseq (with-output-to-string (*standard-output*)
                  (pprint ,var)) 1))

     (defmacro err (var)
       `(error (format nil "ERR:[~A]" (bprint ,var))))

     (defmacro def/route (name param &body body)
       `(progn
          (restas:define-route ,name ,param
            ,@body)
          (restas:define-route
              ,(intern (concatenate 'string (symbol-name name) "/"))
              ,(cons (concatenate 'string (car param) "/") (cdr param))
            ,@body)))
   #+END_SRC

** Шаблоны

   #+NAME: tpl
   #+BEGIN_SRC html :tangle templates.htm :noweb tangle :exports code :padline no :comments none
     // -*- mode: closure-template-html; fill-column: 140 -*-

     {namespace tpl}

     {template root}
         <<tpl_root>>
     {/template}

     {template main}
         <<tpl_main>>
     {/template}

     {template navelt}
         <li><a href="{$link}">{$title}</a></li>
     {/template}

     {template sectelt}
         <li class="{$level}">★<a href="#{$anchor}">{$title}</a>
     {/template}

     {template org}
         <<tpl_org>>
     {/template}

     {template postmain}
         <<tpl_post_main>>
     {/template}

     {template mainposts}
         {foreach $post in $posts}
             {call postmain data="$post" /}
         {/foreach}
     {/template}

     {template stat}
         <<tpl_stat>>
     {/template}

     {template li}
         <li>
             <span style="color: {$color}">{$star}</span>
             <a href="{$link}">{$title}</a>
         </li>
     {/template}

     {template section}
         <p class="alert" style="color: red; font-size: 18px;">{\n}
             <strong>{$title |noAutoescape}</strong>{\n}
         </p>{\n}
         {foreach $elt in $elts}
             <p>{$elt |noAutoescape}</p>{\n}
         {/foreach}
     {/template}

     {template default}
         <div class="pagecontent">
             <div id="guideNav">
                 <ul>
                     {foreach $elt in $sections}
                         {call sectelt data="$elt" /}
                     {/foreach}
                 </ul>
             </div>

             <div id="pagecontent">
                 {$content |noAutoescape}
             </div>

             <div class="divider"></div>
             {$links |noAutoescape}
             <ul id="share">
                 {foreach $elt in $navpoints}
                     {call navelt data="$elt" /}
                 {/foreach}
             </ul>
         </div>
     {/template}
   #+END_SRC

** Каркас проекта

   #+NAME: defsystem
   #+BEGIN_SRC lisp :tangle rigidus.asd :noweb tangle :exports code :padline no :comments link
     ;;;; <<copyright>>
     (asdf:defsystem #:rigidus
       :version      "0.0.2"
       :author       "rigidus <i.am.rigidus@gmail.com>"
       :licence      "GPLv3"
       :description  "site http://rigidus.ru"
       :depends-on   (#:anaphora
                      #:closer-mop
                      #:cl-ppcre
                      #:restas-directory-publisher
                      #:cl-base64
                      #:postmodern
                      #:restas
                      #:closure-template
                      #:drakma
                      #:split-sequence
                      #:cl-json)
       :serial       t
       :components   ((:static-file "templates.htm")
                      (:file "prepare")
                      (:file "defmodule")
                      (:file "orgmode")
                      (:file "sape")
                      (:file "routes")
                      (:file "init")
                      (:static-file "daemon.conf")
                      (:static-file "daemon.lisp")
                      (:static-file "daemon.sh")))
   #+END_SRC

** Подготовка к старту

   Подготовка включает в себя загрузку всех необходимых библиотек, компиляцию шаблонов, и,
   возможно, инициализацию окружения.

   #+NAME: prepare
   #+BEGIN_SRC lisp :tangle prepare.lisp :noweb tangle :exports code :exports none :padline no :comments link
     ;;;; <<copyright>>

     (closure-template:compile-template :common-lisp-backend #P"templates.htm")

     ;; (in-package #:rigidus)

     ;; (defparameter *repo-folder* "repo")
     ;; (defparameter *prj-folder* "rigidus")

     ;; ;; Базовый путь, от которого будем все считать
     ;; (defparameter *base-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/src/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к данным
     ;; (defparameter *data-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/data/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к стилям
     ;; (defparameter *css-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/css/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к картинкам
     ;; (defparameter *img-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/img/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))
     ;; (defparameter *pic-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/pic/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))
     ;; (defparameter *ava-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/ava/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к шрифтам
     ;; (defparameter *font-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/fonts/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))

     ;; ;; Путь к скриптам
     ;; (defparameter *js-path*
     ;;   (format nil "~A~A"
     ;;           (namestring (user-homedir-pathname))
     ;;           (format nil "~A/~A/js/"
     ;;                   *repo-folder*
     ;;                   *prj-folder*)))


     ;; ;; Компилируем шаблоны
     ;; (closure-template:compile-template
     ;;  :common-lisp-backend (pathname (concatenate 'string *base-path* "templates.htm")))

     ;; ;; submodules

     ;; ;; (restas:mount-module -css- (#:restas.directory-publisher)
     ;; ;;   (:url "/css/")
     ;; ;;   (restas.directory-publisher:*directory* *css-path*))

     ;; ;; (restas:mount-module -img- (#:restas.directory-publisher)
     ;; ;;   (:url "/img/")
     ;; ;;   (restas.directory-publisher:*directory* *img-path*))

     ;; ;; (restas:mount-module -pic- (#:restas.directory-publisher)
     ;; ;;   (:url "/pic/")
     ;; ;;   (restas.directory-publisher:*directory* *pic-path*))

     ;; ;; (restas:mount-module -ava- (#:restas.directory-publisher)
     ;; ;;   (:url "/ava/")
     ;; ;;   (restas.directory-publisher:*directory* *ava-path*))

     ;; ;; (restas:mount-module -font- (#:restas.directory-publisher)
     ;; ;;   (:url "/font/")
     ;; ;;   (restas.directory-publisher:*directory* *font-path*))

     ;; ;; (restas:mount-module -js- (#:restas.directory-publisher)
     ;; ;;   (:url "/js/")
     ;; ;;   (restas.directory-publisher:*directory* *js-path*))

     ;; ;; (restas:mount-module -resources- (#:restas.directory-publisher)
     ;; ;;   (:url "/resources/")
     ;; ;;   (restas.directory-publisher:*directory* "/resources/")
     ;; ;;   (restas.directory-publisher:*autoindex* t))
   #+END_SRC

** Copyright

   #+NAME: copyright
   #+BEGIN_SRC lisp
     Copyright © 2014-2016 Glukhov Mikhail. All rights reserved.
     Licensed under the GNU AGPLv3
   #+END_SRC
