<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Нетрадиционно ориентированная диспетчеризация</title>
<!-- 2017-10-17 Вт 16:39 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="rigidus" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Нетрадиционно ориентированная диспетчеризация</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Объектно-ориентированная диспетчеризация</a></li>
<li><a href="#sec-2">2. Фильтрующая диспетчеризация</a></li>
<li><a href="#sec-3">3. Субьектно-ориентированная диспетчеризация</a></li>
<li><a href="#sec-4">4. Контекстно-ориентированная диспетчеризация</a></li>
<li><a href="#sec-5">5. Model-View-Controller Considered Harmful</a></li>
<li><a href="#sec-6">6. Комбинированный подход и стратегия выбора эффективного метода</a></li>
</ul>
</div>
</div>
<p>
Основным вкладом объектно-ориентированного подхода в программирования является специальный
(ad-hoc) полиморфизм, реализуемый с помощью динамической диспетчеризации, когда эффективный
метод выбирается на основании одного (this) или нескольких (в языках с поддержкой обобщенных
функций) параметров.
</p>

<p>
В объектно-ориентированных языках методы (в том числе и переопределенные) наследуются по
цепочке классов или объектов, выбор метода обусловлен иерархией наследования аргументов.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Объектно-ориентированная диспетчеризация</h2>
<div class="outline-text-2" id="text-1">
<p>
Во всех языках, поддерживающих объектно-ориентированную парадигму общим местом является выбор
исполняемого метода на основе типов его аргументов, что позволяет программистам определять
новые методы для классов и с помощью их аргументов специализировать их для своих задач.
</p>

<p>
Существует несколько расширений и реализаций этого подхода, позволяющих специализироваться не
только по классам, но и по объектам, таких, что конкретные объекты могут иметь свое собственное
поведение, которое отклоняется от поведения класса.
</p>

<p>
В традиционных объектно-ориентированных системах вызов метода приводит к посылке сообщения
объекту, который сам решает, какой класс-специфичный или объект-специфичный метод будет вызван
на основании таблицы сигнатур методов. Как правило, такое сопоставление производится для
конкретных объектов, а это значит, что динамическое состояние работающей системы НЕ может легко
влиять на механизм диспетчеризации конкретного объекта.
</p>

<p>
Одним из решений этой проблемы является использование механизма явной диспетчеризации: объект,
получивший сообщение, пересылает его на другой объект на основе некоторых произвольных
критериев. Популярный пример такого подхода - паттерн проектирования State (Состояние)
</p>

<p>
Недостатком такого подхода является то, что он вводит проблему идентификации объекта - this
больше не является получателем сообщения, для которого вызывается эффективный метод. Эта
ситуация также иногда называется проблемой шизофрении объекта (object schizophrenia problem).
</p>

<p>
Есть ряд предложений для решения некоторых аспектов этой проблемы, например путем
переопределения self или this или группировки объектов делегирования в общий разделяемый объект
и разрешения им иметь общий идентификатор объекта. Тем не менее основная проблема
неоднозначности ссылки на эффективный объект остается - программист должен гарантировать,
корректную роль для каждого объекта в цепочке делегирования на который ссылается
объект-диспетчер в каждом общем случае.
</p>

<p>
Smalltalk и CLOS, среди прочего, позволяют изменить класс объекта, и следовательно его таблицу
методов: в Smalltalk-е можно заменить обьект obj-1 на объект obj-2 так, что все ссылки на obj-1
будут указывать на obj-2 при сохранении идентификации obj-1. В CLOS можно непосредственно
изменить класс объекта не затрагивая его идентификации.
</p>

<p>
В принципе эти операции могут быть использованы для реализации State-like паттернов. Однако,
как правило, не рекомендуется их использовать: в Smalltalk не проверяется совместимость схем
объектов, так что это может фактически привести к сбою системы (с задержкой) при неправильном
использовании. Common Lisp спецификация также явно не рекомендует использование change-class:
когда метод выбирается в зависимости от класса конкретного объекта, изменение класса этого
объекта в то время как метод выполняется может привести к "неопределенному результату" из-за
оптимизаций, которые компилятору Common Lisp разрешено выполнять. То же касается и SmallTalk -
если экземляр объекта меняет свой класс - не определено, будет ли в настоящем времени
выполнения видима старая или новая таблица диспетчеризации.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Фильтрующая диспетчеризация</h2>
<div class="outline-text-2" id="text-2">
<p>
Фильтрующая диспетчеризация на основе обобщенных функций расширяет их шагом фильтрации, где
аргументы, полученные обобщенной функцией отображаются как значения параметров функции,
определяемой пользователем. Эти определяемые пользователем функции фильтруют данные и затем
используются для отбора и выполнения примененимых методов.
</p>

<p>
Фильтрующие функции могут быть использованы для диспетчеризации методов, основанной на
состоянии переданных аргументов и позволяет выразить State-like паттерны без "проблемы
шизофрении объекта"
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Субьектно-ориентированная диспетчеризация</h2>
<div class="outline-text-2" id="text-3">
<p>
Коль скоро существует диспетчеризация по объекту, где эффективный метод выбирается в
зависимости от адресата сообщения, то должна существовать и диспетчеризация по субьекту, в
которой эффективный метод выбирается в зависимости от отправителя сообщения.
</p>

<p>
Такой подход дает возможность реализовать особый род полиморфизма, в котором объект содержит
несколько вариантов методов с одинаковой сигнатурой и выбирает среди них в зависимости от
сущности, которая вызывает метод.
</p>

<p>
Такого рода полиморфизм применим при организации разграничения доступа, там где есть
необходимость осуществлять разнообразные действия в зависимости от привелегий вызывающего метод
субьекта.
</p>

<p>
В этом случае целесообразно объединять инварианты поведения полиморфных методов разделяя их на
"роли", ассоциированные с субьектами, вызывающими сервис.
</p>

<p>
В современных наиболее распространенных объектно-ориентированных языках следовые количества
субьектно-ориентированной диспетчеризации находятся в объявлениях private, protected и public
членов класса.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Контекстно-ориентированная диспетчеризация</h2>
<div class="outline-text-2" id="text-4">
<p>
Расширяя специализацию эффективного метода на окружающую среду в которой работает полиморфный
код, необходимо ввести понятие "окружения" или "контекста", в которое включаются все внешние
условия работы программы.
</p>

<p>
Например, для мобильных устройств может быть актуален уровень разряда батареи, факт подключения
к сети и доступность ресурсов или даже сердечный ритм пользователя. Или, например, если
приложение "знает" (на основании сердечного ритма пользователя), что пользователь разозлился, то
оно, возможно, должен не делать определенные вещи :)
</p>

<p>
Такого рода поведение можно реализовать наивно, используя много блоков if везде в коде, но для
того чтобы явно выделить эту логику нужно использовать полиморфизм, где вызываемый метод будет
определяться состоянием окружающей среды, зафиксированным в глобально-доступных источниках, а в
ряде случаев даже опрашиваемым непосредственно в момент диспетчеризации.
</p>

<p>
Таким образом, объект хранит варианты методов для различных состояний окружения и осущетствляет
выбор эффективного метода сопоставляя текущее окружение с образцами в сигнатуре методов.
</p>

<p>
Используя такой вид полиморфизма рационально выделять типичные инварианты поведения в так
называемые "слои" ("layers") и в зависимости от изменений окружения активировать те из них,
которые соответствуют текущему состоянию окружения.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Model-View-Controller Considered Harmful</h2>
<div class="outline-text-2" id="text-5">
<p>
Первоначальная идея ООП заключается в том, что поведение объекта определяется лишь в том
классе, к которому он принадлежит. С применением архитектуры MVC поведение одного объекта
распространяется по всей системе.
</p>

<p>
Можно легко предствить себе, что объекты сами знают как себя вести, т.е. реагировать на
сообщения извне. Однако, когда программы становятся более сложными, код для отображения (View)
объектов, как правило, уже не содержиться в классе, потому что нужно иметь разные отображения
для одного и того же объекта, часто в одно и то же время.
</p>

<p>
Поэтому такой код отделяется в View-объект, который должен быть проинформирован об изменениях в
Model-объекте, что приводит к вариантам архитектуры Model-View-Controller первоначально
введенной в SmallTalk.
</p>

<p>
К сожалению такое распределение обязанностей, которое концептуально относится к одному объекту,
усложняет оригинальную простоту объектно-ориентированной парадигмы. Поэтому несколько более
поздних объектных систем изменили свои фреймворки для представления объектов обратно в
оригинальную идею, что объекты сами должны знать о том, как отображать себя. Однако при этом
теряется свойство иметь разные предстваления одного и того же объекта.
</p>

<p>
Контектно-ориентированное программирование обеспечивает альтернативный подход, придерживаясь
концептуальной простоты, что все поведение объекта инкапсулировано в нем самом, но позволяет
рассматривать разные варианты отображений в зависимости от контекста.
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Комбинированный подход и стратегия выбора эффективного метода</h2>
<div class="outline-text-2" id="text-6">
<p>
На сегодняшний момент в современных мэйнстрим-языках преобладает объектно-ориентированная
диспетчеризация, реализованная в большинстве из них в довольно урезаном объеме - эффективный
метод выбирается исключительно по типу единственного аргумента this.
</p>

<p>
Субьектно-ориентированная диспетчеризация практически не представлена, что приводит к большому
количеству кода, осуществляющего проверку привелегий. Этот код обычно размазан по всему
приложению или, в лучшем случае, вынесен в отдельную "систему прав" представляющую собой
самодельную вариацию на тему общеизвестных идей (ACL, RBAC, MAC, или DAC). Как правило этот код
весьма сложно поддерживать, а в большинстве случаев он еще и является точкой атаки
злоумышленников.
</p>

<p>
Контекстно-ориентированная диспетчеризация отсутствует во всех известных автору используемых
языках за исключением Common Lisp - там она доступна при использовании библиотеки, расширяющей
язык за счет использования метаобъектного протокола.
</p>

<p>
Возможно это связано с историческими причинами считать окружение программы статичным или по
меньшей мере незначительно вариабельным. С широким распространением мобильных устройств и
платформ с ограниченной совместимостью наличие языковых средств, способных явно управлять
поведением приложения в зависимости от изменений окружающей среды, становится серьезным
конкурентным преимуществом при создании мультиплатформенных продуктов.
</p>

<p>
Несмотря на серьезные проблемы с диспетчеризацией в большинстве широко используемых языков, в
Common Lisp существует библиотеки поддерживающие на уровне языка контекстно-ориентированную и
фильтрующую диспетчеризацию, опирающуюся на использование метаобъектного протокола и CLOS. Эта
библиотека доступна в исходных кодах и может служить примером разработки и внедрения актуальных
возможностей диспетчеризации и в других языках.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: rigidus</p>
<p class="date">Created: 2017-10-17 Вт 16:39</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode )</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
