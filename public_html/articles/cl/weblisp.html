<p>
Погуглил по рунету и обнаружил, что нигде нет getting started для того чтобы поднять
hunchentoot и заняться наконец веб-программированием на лиспе.
</p>

<p>
Ну раз нет, то надо написать, люди просят.
</p>

<p>
Все нижеизложенное - мой опыт хождения по граблям, а не истина в последней инстанции, так что
вы можете взять его за основу а дальше развлекаться как вам вздумается.
</p>

<p>
Итак, начнем с установки всего необходимого:
</p>

<ol class="org-ol">
<li>Устанавливаем sbcl. Что вы делаете, если (он еще) у вас не стоит.
</li>

<li>Устанавливаем hunchentoot, например так:
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(require 'asdf-install)
(asdf-install:install 'hunchentoot)
&lt;/source&gt;
</p>

<ol class="org-ol">
<li><p>
Устанавливаем ваши любимые библиотеки.
</p>

<p>
Запускаем лисп. Я запускаю его, заходя на сервер по ssh, внутри приятной тулзы screen. И
начинаем собственно писать код:
</p>
</li>

<li>Подгружаем библиотеки (которые вы установили ранее). У меня так:
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(in-package :cl-user)
(asdf:operate 'asdf:load-op '#:alexandria)
(asdf:operate 'asdf:load-op '#:hunchentoot)
(asdf:operate 'asdf:load-op '#:clsql)
(asdf:operate 'asdf:load-op '#:closure-template)
(asdf:operate 'asdf:load-op '#:split-sequence)
(asdf:operate 'asdf:load-op '#:babel)
(asdf:operate 'asdf:load-op '#:cl-json)
(asdf:operate 'asdf:load-op '#:postmodern)
(asdf:operate 'asdf:load-op '#:cl-store)
(asdf:operate 'asdf:load-op '#:cl-blackjack)
(asdf:operate 'asdf:load-op '#:cl-whores)
&lt;/source&gt;
</p>

<ol class="org-ol">
<li><p>
Есть переменная, на которую мы будем смотреть, чтобы узнать, выдавать вам ошибки в slime,
или героически справляться с ними самостоятельно. Так как у меня может приходить до пяти
запросов в секунду и в случае ошибки slime оказывается парализованным выстреливающими
сообщениями, я делаю простые функции, чтобы в случае такого epic fail зайти по ssh,
выполнить функцию, и разбираться в спокойной обстановке.
</p>

<p>
Правда, я не знаю что делать, если в момент появления ошибки я был отключен от сервера. Я
догадываюсь о том, что произошла ошибка по увеличению количества потоков "Hunchentoot worker" в
Slime Threads, но на моей системе они не дебажатся, хотя должны. Впрочем я на фряхе пока, может
быть в этом все и дело. На FreeBSD в sbcl потоки "более другие".
</p>
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defvar <b>catch-errors-p</b> nil)
</p>

<p>
(defun err-on () (setf <b>catch-errors-p</b> nil))
</p>

<p>
(defun err-off () (setf <b>catch-errors-p</b> t))
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Создаем свой acceptor, который будет принимать запросы:
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defclass debuggable-acceptor (hunchentoot:acceptor) ())
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Переопределяем метод hunchentoot:acceptor-request-dispatcher, чтобы добавить всплывание
ошибок в отладчике, если <b>catch-errors-p</b> установлена в нужное значение.
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defmethod hunchentoot:acceptor-request-dispatcher
    ((acceptor debuggable-acceptor))
  (if <b>catch-errors-p</b>
      (call-next-method)
      (let ((dispatcher
             (handler-bind ((error #'invoke-debugger))
               (call-next-method))))
        (lambda (request)
          (handler-bind ((error #'invoke-debugger))
            (funcall dispatcher request))))))
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Пишем свой диспетчер, который будет разруливать запросы
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defun dispatcher (request)
  (let* ((request-host (hunchentoot:host))
         (request-full-str (hunchentoot:request-uri request))
         (request-parted-list
          (split-sequence:split-sequence #\?
                                         (hunchentoot:request-uri request)))
         (request-str (string-right-trim "\/" (car request-parted-list))))
    (let ((output
           (cond ((equal "/somepage"  request-str) (somepage request))
                 ((equal "/otherpage" request-str) (otherpage request param))
                 (t (404page request)))))
      (setf (hunchentoot:content-type*) "text/html; charset=utf-8")
      (babel:string-to-octets output :encoding :utf-8))))
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Пишем функции somepage и otherpage, которые отдают конкретные страницы в этом примере. Лично
я считаю удобным помещать такое в отдельные пакеты, разбивая по функционалу, но у вас может
быть свое мнение на этот счет - я не настаиваю.
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defun somepage (request) "This is somepage")
(defun otherpage (request) "This is otherpage")
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Инстанцируем свой acceptor, передавая ему свой диспетчер на нужном вам порту, если
необходимо:
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(defvar <b>debuggable-acceptor</b>
(make-instance 'debuggable-acceptor
</p>
<p>
:request-dispatcher 'dispatcher
</p>
<p>
               :port 80))
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Запускаем hunchentoot и запрещаем ему обрабатывать ошибки самостоятельно, без высочайшего
соизволения:
</li>
</ol>

<p>
&lt;source lang="lisp"&gt;
(hunchentoot:start <b>debuggable-acceptor</b>)
(setf hunchentoot:*handle-http-errors-p* nil)
&lt;/source&gt;
</p>

<ol class="org-ol">
<li>Зажигаем огонек в глазах, складываем весь вышеприведенный код в один файл, исполняем в лиспе
и заходим на <a href="http:://localhost/somepage">http:://localhost/somepage</a> - чтобы проверить, работает ли все это на самом
деле.
</li>
</ol>
