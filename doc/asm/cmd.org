#+STARTUP: showall indent hidestars
#+TITLE: Получение аргументов командной строки в программах на ассемблере под линукс

* Вводная

В операционной среде, обеспечивающей поддержку Си, имеется возможность
передать аргументы или параметры запускаемой программе с помощью
командной строки.

В момент запуска программы функции =main= передаются два аргумента.
- В первом, обычно называемом argc (сокращение от argument count), стоит
  количество аргументов, заданых в командной строке.
- Второй параметр, называемый argv (от argument vector), является
  указателем на массив символьных строк, содержащих сами аргументы.



* Точка отсчета

Чтобы получить точку отсчета, нагуглим минимальный пример на языке Си,
который осуществляет обрабоку аргументов командной строки. Вот он:

#+NAME: argv.c
#+BEGIN_SRC c
  #include <stdio.h>
  void main (int argc, char * argv[]) {
      while (--argc > 0) {
          printf("%s\n", argv[argc]);
      }
  }
#+END_SRC

Как мы видим, здесь осуществляется выполнение тела цикла пока
декрементируемая переменная argc не станет равной нулю. В теле цикла
мы передаем функции =printf= адрес начала каждого параметра и она этот
параметр выводит.

Скомпилируем его и убедимся, что все работает:

#+BEGIN_SRC sh
  gcc -g -o argv argv.c
#+END_SRC

После выполнения этой команды должен появится испольняемый файл
=argv=, которы мы тут же запускаем, разумеется с параметрами командной
строки. Он должен нам вывести их в обратном порядке:

#+BEGIN_EXAMPLE
  ./argv this is params from command line
  line
  command
  from
  params
  is
  this
#+END_EXAMPLE

* Как это на ассемблере?

Получим ассемблерный листинг, чтобы понять как это происходит на
нижнем уровне:

#+BEGIN_EXAMPLE
  gcc -S -O1 -o argv.s argv.c
#+END_EXAMPLE

Получаем следующий файл =argv.s=:

#+BEGIN_SRC asm
      .file   "argv.c"
      .text
      .globl  main
      .type   main, @function
  main:
  .LFB23:
      .cfi_startproc
      pushq   %rbp
      .cfi_def_cfa_offset 16
      .cfi_offset 6, -16
      pushq   %rbx
      .cfi_def_cfa_offset 24
      .cfi_offset 3, -24
      subq    $8, %rsp
      .cfi_def_cfa_offset 32
      movq    %rsi, %rbp
      leal    -1(%rdi), %ebx
      testl   %ebx, %ebx
      jle .L1
  .L4:
      movslq  %ebx, %rax
      movq    0(%rbp,%rax,8), %rdi
      call    puts@PLT
      subl    $1, %ebx
      jne .L4
  .L1:
      addq    $8, %rsp
      .cfi_def_cfa_offset 24
      popq    %rbx
      .cfi_def_cfa_offset 16
      popq    %rbp
      .cfi_def_cfa_offset 8
      ret
      .cfi_endproc
  .LFE23:
      .size   main, .-main
      .ident  "GCC: (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005"
      .section    .note.GNU-stack,"",@progbits
#+END_SRC

Если выкинуть из кода все директивы ассемблера, которые не войдут в
исполняемый файл, то код существенно сократится:

#+BEGIN_SRC asm
      .file   "argv.c"
      .text
      .globl  main
      .type   main, @function
  main:
  .LFB23:
      pushq   %rbp
      pushq   %rbx
      subq    $8, %rsp
      movq    %rsi, %rbp
      leal    -1(%rdi), %ebx
      testl   %ebx, %ebx
      jle .L1
  .L4:
      movslq  %ebx, %rax
      movq    0(%rbp,%rax,8), %rdi
      call    puts@PLT
      subl    $1, %ebx
      jne .L4
  .L1:
      addq    $8, %rsp
      popq    %rbx
      popq    %rbp
      ret
  .LFE23:
      .size   main, .-main
      .ident  "GCC: (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005"
      .section    .note.GNU-stack,"",@progbits
#+END_SRC

Итак, что мы тут видим, на этом компактном листинге? Исполнение нашего
кода начинается с функции =main=. Первое что происходит - сохраняются
в стек регистры =%rbp= и =#rbx=. На моей процессорной архитектуре
(64разрядной) каждый из этих регистров занимает 64бита, т.е. 8
байт. Вариант кода для 32разрядной архитектуры рассмотрим чуть позже.

Затем, мы вычитаем из регистра указателя стека =%rsp= константу 8. Это
соответствует резервированию еще 8 байт в стеке. Теперь стек выглядит
так:

#+BEGIN_SRC ditaa :file ./img/stk1.png
 +-------------------------------------------------+ <- %RSP
 | Выделенные смещением указателя стека 8 байт     |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Сохраненный %rbx (4 байта)                      |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Сохраненный %rbp (4 байта)                      |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Адрес возврата в операционную систему (4 байта) |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+

#+END_SRC

Следующим шагом мы делаем команду =movq %rsi, %rbp=, которая
перемещает содержимое регистра =%rsi= в регистр =%rbp=. Забегая
вперед, можно сказать, что скоро станет очевидно, что операционная
система перед запуском программы поместила в регистр =rsi= указатель
на что-то связанное с командной строкой. Интересно что? Посмотрим, что
будет дальше, может бы мы найдем ответ на этот вопрос.

Следующей командой =leal -1(%rdi), %ebx= мы загружаем в регистр %ebx
число, которое на единицу меньше, чем значение в регистре
%rdi. Очевидно, что это и есть уменьшение переменной цикла (которая в
сишном коде у нас называется =argc=) на единицу. Таким образом, мы
можем заключить, что указатель на количество аргументов строки
операционная система при запуске программы помещает в регистр =%rdi=.

Следующей командой мы проверяем равенство переменной цикла
нулю. Команда =test= объединяет возможности команд AND и СМР. Как
команда =and=, она выполняет объединение по логическому "И"
соответствующих бит операндов; как команда =смр=, она изменяет только
состояния регистра =flags=, а не результат. Здесь по логическому "И"
сравнивается регистр %ebx сам с собой. Только в том случае, если %ebx
содержить ноль, в регистре флагов будет выставлен бит ZF (zero flag,
флаг нуля) в единицу.

Следующая команда условного перехода =jle .L1= (jump if less or equal)
проверяет этот бит и если он выставлен в единицу, осуществляется
переход на адрес, соответствующий метке =.L1=. Эта ситуация возникает
тогда, когда у нас нет параметров командной строки, т.е. когда мы
ввели только имя программы. В этом случае при старте этой программы в
регистре %rdi% будет единица, из которой мы вычли единицу, получился
ноль и мы переходим на метку .L1

Сходим туда и посмотрим, чем все закончится.

Мы видим, что мы добавляем к =%esp= констату 8, после чего
восстанавливаем =%rbx= и =%rbp=, приводя стек в то состояние, в
котором он был при запуске программы. У нас в стеке теперь лежит
только адрес возврата. После чего вызывается команда =ret=, которая
возвращает нас из функции =main= в код, который вернет управление в
операционную систему.

Что же будет, если мы все-же введем несколько параметров командной
строки? Тогда команда =jle= не перебросит нас на метку =.L1=, а вместо
этого мы продожим исполнение. И следующая наша команда =movslq  %ebx,
%rax= скопирует содержимое регистра %ebx в %rax. Как мы помним,
несколько раньше мы загрузили в %ebx уменьшенное на единицу количество
параметров командной строки. Теперь оно будет и в =%rax=. Надо
отметить, что %rax содержит 8 байт, а %ebx - четыре. Старшие разряды
будут заполнены командой =movslq= нулями.

Следующая команда =movq 0(%rbp,%rax,8), %rdi= поместит в регистр
=%rdi= содержимое адреса, который будет вычислен выражением
0+(%rbp+$rax)*8. Вспомним снова, что там лежит, чтобы понять, что это
означает.

Итак, в =%rax= лежит то, что ранее было в %ebx и проверялось на
равенство нулю и в случае успеха проверки завершало программу. Значит,
%rax содержит счетчик оставшихся параметров командной строки

В =%ebp лежит то, что ранее было в %rsi, и очевидно, это
сформированный операционной системой указатель на буфер, в котором
лежит массив байтов, каждый из которых является указателем на
следующий параметр командной строки.

Сумма этих двух регистров умножается на 8 - это размер указателя в
байтах в 64-битной архитектуре. Потом выполняется обращение по
получившимуся адресу, и полученное значение попадает в регистр =%rdi=.

И следующая команда =call puts@PLT= как раз принимает указатель на
строку, заканчивающуюся нулем в этом регистре! После ее выполнения (и
вывода строки на экран) регистр %ebx будет уменьшен на единицу: =subl
$1, %ebx=. Эта операция взведет флаг ZF если результат стал нулем и
следующая команда =jne .L4= перебросит нас на метку =.L4= если этого
НЕ произошло. Таким образом цикл будет повторяться пока не кончатся
все параметры.

* TODO Что если у нас другая архитектура?

TODO: Скомпилировать этот файл на машине с 32-разрядной архитектурой.

* Получаем объектный файл

Объектный файл - это файл с промежуточным представлением отдельного
модуля программы, полученный в результате обработки исходного кода
компилятором. Объектный файл содержит в себе особым образом
подготовленный код (часто называемый двоичным или бинарным), который
может быть объединён с другими объектными файлами при помощи редактора
связей (компоновщика) для получения готового исполнимого модуля, или
библиотеки.

Объектные файлы представляют собой блоки машинного кода и данных, с
неопределенными адресами ссылок на данные и процедуры в других
объектных модулях, а также список своих процедур и данных. Компоновщик
собирает код и данные каждого объектного модуля в итоговую программу,
вычисляет и заполняет адреса перекрестных ссылок между
модулями.

Связывание со статическими библиотеками выполняется редактором связей
или компоновщиком (который может представлять собой отдельную
программу или быть частью компилятора), а с операционной системой и
динамическими библиотеками связывание выполняется при исполнении
программы, после её загрузки в память.

В первую очередь нам надо убедиться полученный ассемблерный листинг
можно превратить в правильный объектный файл:

#+BEGIN_SRC sh
  as argv.s -o argv.o
#+END_SRC

Посмотрим, что у нас получилось:

#+BEGIN_SRC sh
  objdump -hrt argv.o

  argv.o:     формат файла elf64-x86-64

  Разделы:
  Инд Имя           Размер    VMA               LMA               Файл      Вырав
    0 .text         00000029  0000000000000000  0000000000000000  00000040  2**0
                    CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
    1 .data         00000000  0000000000000000  0000000000000000  00000069  2**0
                    CONTENTS, ALLOC, LOAD, DATA
    2 .bss          00000000  0000000000000000  0000000000000000  00000069  2**0
                    ALLOC
    3 .comment      0000002e  0000000000000000  0000000000000000  00000069  2**0
                    CONTENTS, READONLY
    4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000097  2**0
                    CONTENTS, READONLY
    5 .eh_frame     00000040  0000000000000000  0000000000000000  00000098  2**3
                    CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  SYMBOL TABLE:
  0000000000000000 l    df *ABS*  0000000000000000 argv.c
  0000000000000000 l    d  .text  0000000000000000 .text
  0000000000000000 l    d  .data  0000000000000000 .data
  0000000000000000 l    d  .bss   0000000000000000 .bss
  0000000000000000 l    d  .note.GNU-stack    0000000000000000 .note.GNU-stack
  0000000000000000 l    d  .eh_frame  0000000000000000 .eh_frame
  0000000000000000 l    d  .comment   0000000000000000 .comment
  0000000000000000 g     F .text  0000000000000029 main
  0000000000000000         *UND*  0000000000000000 _GLOBAL_OFFSET_TABLE_
  0000000000000000         *UND*  0000000000000000 puts


  RELOCATION RECORDS FOR [.text]:
  OFFSET           TYPE              VALUE
  0000000000000019 R_X86_64_PLT32    puts-0x0000000000000004


  RELOCATION RECORDS FOR [.eh_frame]:
  OFFSET           TYPE              VALUE
  0000000000000020 R_X86_64_PC32     .text
#+END_SRC

В объектном файле есть секции:
- =.text= - это скомпилированная программа, то есть машинные коды
  операций, соответствующие программе. Она будет использоваться
  загрузчиком программ для инициализации сегмента кода процесса.
- =.data= - наша программа не имеет ни инициализированных глобальных
  переменных, ни инициализированных статических локальных переменных,
  поэтому этот раздел должен быть пуст. Обычно этот раздел содержит
  предварительно инициализированные данные для загрузки в сегмент
  данных.
- =.bcc= - кусок неинициализированных данных, этот раздел указывает на
  то, сколько байтов должно быть выделено и обнулено в сегменте данных
  в дополнение к разделу .data. В нашей программе он пуст.
- =.comment=: этот сегмент содержит комментарии

Также в объектном файле могут встретиться другие секции:
- =.rodata= - этот сегмент содержит строки, которые помечена только для
  чтения. Большинство операционных систем не поддерживают сегмент
  данных только для чтения для процессов, поэтому содержимое .rodata
  переходит либо в сегмент кода процесса (потому что он доступен
  только для чтения), либо в сегмент данных (поскольку это
  данные). Поскольку компилятор не знает политики, принятой вашей ОС,
  он создает этот дополнительный раздел.
- =.debug_*=: - разделы с символами, которые облегчают отладку
- и другие..

Он также показывает нам таблицу символов с символом =main=, связанным
с адресом 00000029, и символ помещает undefined. Кроме того, таблица
перемещений говорит нам, как переместить ссылки на внешние разделы,
сделанные в разделе .text. Первый перемещаемый символ =puts=,
обозначает функцию библиотеки =libc=, в которуюю была сгенерирована
функция =printf=.

* Компоновка

Если сильно упростить, компоновка — это процесс извлечения секций из
объектных файлов, раскладывание их по указанным адресам и настройка
перекрестных ссылок.

В обычных операционнх системах ядро умеет читать выходной файл и
загружать секции в память по ожидаемым виртуальным адресам. Со
встраиваемыми системами (программирование микроконтроллеров) проще,
программа для прошивки берет бинарный файл и заливает на флешку как
есть.

Теперь посмотрим на процесс преобразования в исполняемый файл. Можно
подумать, что следующая команда вызовет компоновщик, который сделает
все необходимые вещи:

#+BEGIN_SRC sh
  ld -o argv argv.o
  ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
#+END_SRC

Но нет, компоновщик говорит, что ему нужна метка =_start= в качестве
символа, с которого начнется выполенение программы. Если же мы
поменяем в файле =main= на =start=, скомпилируем и попытаемся
скомпоновать - то он снова выдает ошибку:

#+BEGIN_SRC sh
  argv.c:(.text+0x38): undefined reference to `puts'
#+END_SRC

Все дело в функции =puts=, в вызов которой преобразовался =printf= -
компоновщик просто не знает, где ее взять. Попробуем немного ему
помочь, статически подключив библиотеку =libc=, в которой она
определена:

#+BEGIN_SRC sh
  ld -static -o argv argv.o -lc
#+END_SRC

Эта команда выдает нам много ошибок вида =undefined
reference=. Очевидно, что =libc= вызывает что-то еще. Тут уже не
обойтись без руководства. Читать я его конечно не буду.

Mало подключить библиотеку =libc=, еще совершенно необходимо
подключить библиотеку времени выполнения =crt1= (common
runtime). =crt1= содержит метку =_start=, и устанавливает =env=
(окружение) с помощью argc / argv / libc _init / libc _fini перед тем,
как вызвать главную функцию библиотеки =libc=.

Также необходимо подключить еще две библиотеки: =crti= и =crtn=. Они
определяют код, который будет выполняться до инициализации =libc= и
после ее деинициализации.

Линкер однопроходный и обрабатывает строку линковки
слева-направо. Поэтому при линковке важнен порядок объектных файлов и
библиотек. Включить многопроходную линковку в пределах группы можно с
помощью: --Wl,--start-group… -Wl,--end-group — внутри группы линкер
станет многопроходным и возможно разрешение кросс-зависимостей

Все это превращает линковку в настолько сложную процедуру, что даже
специально разработан скриптовый язык для управления компоновщиком:
https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html

Но мы не будем его использовать а вместо этого подключим библиотеки
одну за другой

#+BEGIN_SRC sh
  ld -static                          \
     -o argv                          \
     -L`gcc -print-file-name=`        \
     /usr/lib/x86_64-linux-gnu/crt1.o \
     /usr/lib/x86_64-linux-gnu/crti.o \
     argv.o                           \
     /usr/lib/x86_64-linux-gnu/crtn.o \
     --start-group -lc -lgcc -lgcc_eh --end-group
#+END_SRC

Что здесь происходит? Мы указываем, что компоновщик должен:
- произвести статическую линковку, т.е. собрать все библиотеки в один
  файл (-static)
- выходной файл должен называться "argv"
- путь для поиска библиотек должен быть получен путем выполнения
  команды =gcc -print-file-name==, которая на моей машине возвращает
  =/usr/lib/gcc/x86_64-linux-gnu/6/=
- первым файлом, который будет размещен в начале нашего исполняемого
  модуля будет =crt1.0=
- затем пойдет файл =crto.0=
- потом мы берем наш объектный файл, полученный на прошлом этапе
- и, наконец, =crtn.o=
- после этого мы включаем три библиотеки в указанном порядке: =libc=,
  =libgcc=, =libgcc_eh=.

Теперь компоновщик может построить исполняемый файл и аккуратно
настроить все ссылки.

* Исследование файла программы

Чтобы получить список всех функций внутри исполняемого файла можно
использовать команду =nm argv=.

Можно также дизассемблировать весь файл: =objdump -d argv=

Довольно интересно проанализировать как устроен бинарный исполняемый
файл:

#+BEGIN_SRC sh
  readelf -l argv

  Тип файла ELF — EXEC (Исполняемый файл)
  Точка входа 0x4009a0
  Имеется 6 заголовков программы, начиная со смещения 64

  Заголовки программы:
    Тип            Смещ.              Вирт.адр           Физ.адр            Рзм.фйл            Рзм.пм              Флаги  Выравн
    LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000cab51 0x00000000000cab51  R E    200000
    LOAD           0x00000000000caed0 0x00000000006caed0 0x00000000006caed0 0x0000000000001c80 0x00000000000034f8  RW     200000
    NOTE           0x0000000000000190 0x0000000000400190 0x0000000000400190 0x0000000000000020 0x0000000000000020  R      4
    TLS            0x00000000000caed0 0x00000000006caed0 0x00000000006caed0 0x0000000000000020 0x0000000000000050  R      8
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000  RWE    10
    GNU_RELRO      0x00000000000caed0 0x00000000006caed0 0x00000000006caed0 0x0000000000000130 0x0000000000000130  R      1

   Соответствие раздел-сегмент:
    Сегмент Разделы...
     00     .note.ABI-tag .rela.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_IO_vtables __libc_atexit .stapsdt.base __libc_thread_subfreeres .eh_frame .gcc_except_table
     01     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs
     02     .note.ABI-tag
     03     .tdata .tbss
     04
     05     .tdata .init_array .fini_array .data.rel.ro .got
#+END_SRC

Первый заголовок программы соответствует сегменту кода процесса,
который будет загружен из файла со смещением 0x000000 в область
памяти, которая будет отображаться в адресное пространство процесса по
адресу 0x400000. Сегмент кода будет размером 0xcab51 байтов и должен
быть выровнен по странице (0x200000). Этот сегмент будет содержать
сегменты ELF .text и .rodata, рассмотренные ранее, плюс дополнительные
сегменты, созданные во время процедуры связывания. Как и ожидалось, он
помечен только для чтения (R) и исполнения (E), но не доступен для
записи (W).

Второй заголовок программы соответствует сегменту данных
процесса. Загрузка этого сегмента выполняется по тем же самым шагам,
что указаны выше. Однако обратите внимание, что размер сегмента равен
0x1c80 в файле и 0x34f8 в памяти. Это связано с разделом .bss, который
должен быть обнулен и, следовательно, не должен присутствовать в
файле. Сегмент данных также будет выровнен по страницам (0x20000) и
будет содержать ELF-сегменты .data и .bss. Он будет помечен для чтения
и записи (RW). Третий заголовок программы является результатом
процедуры связывания и не имеет отношения к обсуждению.

Это можно проверить, запустив в соседнем терминале программу под
отладчиком и обратившись к файловой системе proc

В первом терминале:

#+BEGIN_SRC sh
  gdb --quiet ./argv
  Reading symbols from ./argv...(no debugging symbols found)...done.
  (gdb) break main
  Breakpoint 1 at 0x4009cb
  (gdb) run one two three
  Starting program: /path/to/file/argv one two three

  Breakpoint 1, 0x00000000004009cb in main ()
  (gdb)
#+END_SRC

И пока программа остановлена отладчиком, во втором терминале:

#+BEGIN_SRC sh
  cat /proc/`ps -C argv -o pid=`/maps
  00400000-004cb000 r-xp 00000000 00:2e 26351018              /path/to/file/argv
  006ca000-006cd000 rwxp 000ca000 00:2e 26351018              /path/to/file/argv
  006cd000-006f2000 rwxp 00000000 00:00 0                     [heap]
  7ffff7ffb000-7ffff7ffd000 r--p 00000000 00:00 0             [vvar]
  7ffff7ffd000-7ffff7fff000 r-xp 00000000 00:00 0             [vdso]
  7ffffffde000-7ffffffff000 rwxp 00000000 00:00 0             [stack]
  ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0     [vsyscall]
#+END_SRC

Как видим все размещение точно соответствует расчетному.

* Трассировка системных вызовов

#+BEGIN_SRC sh
  file argv
  argv: ELF 64-bit LSB executable, x86-64,
        version 1 (GNU/Linux),
        statically linked, for GNU/Linux 2.6.32,
        not stripped
  ./argv one two three
  three
  two
  one
#+END_SRC

Попробуем посмотреть какие системные вызовы делает наша
программа. Воспользуемся для этого инструментом =strace=

strace — это утилита, отслеживающая системные вызовы, которые
представляют собой механизм, обеспечивающий интерфейс между
процессом и операционной системой.

Эти вызовы могут быть перехвачены и прочитаны. Это позволяет лучше
понять, что процесс пытается сделать в заданное время. Перехватывая
эти вызовы, мы можем добиться лучшего понимания поведения процессов,
особенно если что-то идет не так.

#+BEGIN_SRC sh
  execve("./argv", ["./argv", "ONE", "TWO", "THREE"], [/* 62 vars */]) = 0
  uname({sysname="Linux", nodename="ng", ...}) = 0
  brk(NULL)                               = 0x7ad000
  brk(0x7ae1c0)                           = 0x7ae1c0
  arch_prctl(ARCH_SET_FS, 0x7ad880)       = 0
  readlink("/proc/self/exe", "/path/to/file/argv", 4096) = 29
  brk(0x7cf1c0)                           = 0x7cf1c0
  brk(0x7d0000)                           = 0x7d0000
  access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
  write(1, "THREE\n", 6THREE
  )                  = 6
  write(1, "TWO\n", 4TWO
  )                    = 4
  write(1, "ONE\n", 4ONE
  )                    = 4
  exit_group(4)                           = ?
  +++ exited with 4 +++
#+END_SRC

Здесь можно увидеть три вызова фунции =write=, про которую можно
прочитать, запустив команду =man 2 write=. Согласно этой справке она
принимает три параметра:
- файловый дескриптор
- указатель на буфер
- размер буфера

#+BEGIN_SRC c
  ssize_t write(int fd, const void *buf, size_t count);
#+END_SRC

В выдаче =strace= мы видим, что первым параметром все три раза
является "1", т.е. мы пишем в файловый дескриптор, соответствующий
"стандартному выводу". После мы видим само содержимое переданного
буфера (добавлен знак "\n" перевода строки), потом размер буфера,
потом сюда вклинивается сам вывод строки, и после закрывающей скобки
мы видим возвращаемый результат - количество выведенных символов.

После того как все будет выведено программа завершается, с кодом
возврата "4". Это произошло из-за того что в регистре %rax осталось
последнее возвращаенное значение функции =write=. Если мы очистим
регистр, например командой =xor %rax, %rax=, то значение будет равно
нулю.

Первый системный вызов - =execve=: запуск файла на выполнение. В скобках
передается команда с аргументами (если они есть) и количество
переменных окружения, переданных процессу. По умолчанию strace не
показы вает сами переменные окружения, но его можно попросить выводить
более подробную информацию с помощью опции ‘-v’. Вызов возвратил 0 —
значит все ok. В противном случае значение было бы -1.

Следующий интересный системный вызов — access: проверка прав
пользователя на файл. В данном случае тестируется существование файла
(о чем говорит режим проверки F_OK). На третьей строчке системный
вызов вернул значение -1 (ошибка) и вывел ошибку ENOENT (No such file
or directory). Это нормально, так как этот файл, если он есть, всего
лишь служит для указания линковщику на использование стандартных
неоптимизированных версий библиотек (для целей отладки)

Манипуляции над файлом всегда начинаются с системного вызова =open=,
открывающего файл в одном из режимов (O_RDONLY, O_WRONLY или O_RDWR),
кроме файлов стандартного ввода, стандартного вывода, и стандартного
вывода ошибкок, которые открыты с самого старта программы.

Вызов =open= возвращает небольшое целое число — файловый дескриптор,
который впоследствии будет использоваться другими вызовами (до того
момента, пока не будет закрыт с помощью вызова =close=).

После открытия файла вызовом open происходит его чтение вызовом =read=
или запись вызовом =write=. Оба вызова принимают файловый дескриптор,
а возвращают количество прочитанных/записанных байт.

Вызов =fstat= предназначен для получения информации о файле

Системный вызов =uname= позволяет
получить информацию о текущем ядре. Если трассировка uname занимает
всего сотню строк, то трассировка серьезного приложения легко может
занимать несколько тысяч строк. Читать такой лог — не самое большое
удовольствие. Поэтому иногда лучше записывать в лог только
определенные вызовы. Например, чтобы отследить все вызовы open и
access (а на них следует обращать внимание в первую очередь при
проблемах с запуском приложения):

Остальные вызовы, которые поймал =strace= можно посмотреть в
документации. Благодаря тому, что можно перехватывать общение
программы с операционной системой, мы можем многое сказать о поведении
программы. Это особенно интересно, когда она написана кем-то
другим.

А вот так можно увидеть полную таблицу вызовов, которые делает
программа

#+BEGIN_SRC sh
  strace -c  ./argv
  % time     seconds  usecs/call     calls    errors syscall
  ------ ----------- ----------- --------- --------- ----------------
    0.00    0.000000           0         4           brk
    0.00    0.000000           0         1         1 access
    0.00    0.000000           0         1           execve
    0.00    0.000000           0         1           uname
    0.00    0.000000           0         1           readlink
    0.00    0.000000           0         1           arch_prctl
  ------ ----------- ----------- --------- --------- ----------------
  100.00    0.000000
#+END_SRC
* Использование отладчика

Запустим нашу программу под отладчиком. И сразу воспользуемся командой
=info functions=, чтобы получить имена всех функций, которые есть в
программе. Вывод получается довольно длинным, поэтому я сокращу его
только до самых интересных функций:

#+BEGIN_SRC sh
  gdb --quiet ./argv
  (gdb) info functions
  All defined functions:

  Non-debugging symbols:
  0x00000000004002b8  _init
  0x0000000000400504  oom
  0x0000000000400530  fini
  0x00000000004009a0  _start
  0x00000000004009cb  _start
  0x00000000004009cb  main
  0x0000000000400dd0  __libc_start_main
  0x000000000040eda0  exit
  0x000000000040fee0  puts
  0x000000000043f4f0  _Exit
  0x000000000043f4f0  _exit
  0x000000000043ff00  write
  0x00000000004a2b94  _fini
  (gdb)
#+END_SRC

С помощью команды =disassemble= мы можем просмотреть код любой
функции. Например нашей функции =main=:

#+BEGIN_SRC gdbout
  (gdb) disassemble main
  Dump of assembler code for function main:
     0x00000000004009cb <+0>: push   %rbp
     0x00000000004009cc <+1>: push   %rbx
     0x00000000004009cd <+2>: sub    $0x8,%rsp
     0x00000000004009d1 <+6>: mov    %rsi,%rbp
     0x00000000004009d4 <+9>: lea    -0x1(%rdi),%ebx
     0x00000000004009d7 <+12>:    test   %ebx,%ebx
     0x00000000004009d9 <+14>:    jle    0x4009ed <main+34>
     0x00000000004009db <+16>:    movslq %ebx,%rax
     0x00000000004009de <+19>:    mov    0x0(%rbp,%rax,8),%rdi
     0x00000000004009e3 <+24>:    callq  0x40fee0 <puts>
     0x00000000004009e8 <+29>:    sub    $0x1,%ebx
     0x00000000004009eb <+32>:    jne    0x4009db <main+16>
     0x00000000004009ed <+34>:    add    $0x8,%rsp
     0x00000000004009f1 <+38>:    pop    %rbx
     0x00000000004009f2 <+39>:    pop    %rbp
     0x00000000004009f3 <+40>:    retq
     0x00000000004009f4 <+41>:    nopw   %cs:0x0(%rax,%rax,1)
     0x00000000004009fe <+51>:    xchg   %ax,%ax
  End of assembler dump.
#+END_SRC

Знакомый код, если не считать того, что некоторые имена теперь
представлены как им и полагается, адресами памяти.

С помощью команд =gdb= мы можем шаг за шагом исполнять код. Команда
=si= (step into) позволяет делать шаг, заходя в процедуры, команда
=ni= (next instruction) - перепрыгивая через вызов процедур. В любой
момент можно посмотреть содержимое регистров командой =info
registers=, и вложенность фреймов стека командой =info stack=. Узнать
больше команд можно воспользовавшись командой help.

Проведем исследование нашего файла шаг за шагом. Запустим наш файл с
пераметрами и установим точку останова, а затем посмотрим содержимое
регистров:

#+BEGIN_SRC sh
  (gdb) break main
  Breakpoint 1 at 0x4009cb
  (gdb) run argv one two three
  Starting program: /path/to/file/argv argv one two three

  Breakpoint 1, 0x00000000004009cb in main ()
  (gdb) info registers
  rax            0x4009cb 4196811
  rbx            0x4002b8 4195000
  rcx            0x4  4
  rdx            0x7fffffffdee8   140737488346856
  rsi            0x7fffffffdeb8   140737488346808
  rdi            0x5  5
  rbp            0x6cb018 0x6cb018
  rsp            0x7fffffffdd88   0x7fffffffdd88
  r8             0x8  8
  r9             0x2  2
  r10            0x2  2
  r11            0x1  1
  r12            0x401590 4199824
  r13            0x401620 4199968
  r14            0x0  0
  r15            0x0  0
  rip            0x4009cb 0x4009cb <main>
  eflags         0x246    [ PF ZF IF ]
  cs             0x33 51
  ss             0x2b 43
  ds             0x0  0
  es             0x0  0
  fs             0x0  0
  gs             0x0  0
#+END_SRC

На вершину стека указывает значение %esp и на момент старта программы
там должен лежать адрес возврата из =main=. Узнаем его:

#+BEGIN_SRC sh
  (gdb) x 0x7fffffffdd88
  0x7fffffffdd88:	0x00400c46
#+END_SRC

Отлично, теперь дизассемблируем код по этому адресу:

#+BEGIN_SRC sh
  (gdb) disassemble 0x00400c46
   Dump of assembler code for function generic_start_main:
   0x0000000000400a00 <+0>:	push   %r14
   0x0000000000400a02 <+2>:	push   %r13
   0x0000000000400a04 <+4>:	mov    $0x0,%eax
   0x0000000000400a09 <+9>:	push   %r12
   ...
   0x0000000000400c36 <+566>:	mov    0x10(%rsp),%rsi
   0x0000000000400c3b <+571>:	mov    0xc(%rsp),%edi
   0x0000000000400c3f <+575>:	mov    0x18(%rsp),%rax
   0x0000000000400c44 <+580>:	callq  *%rax
   0x0000000000400c46 <+582>:	mov    %eax,%edi
   ...
#+END_SRC

Действительно, мы видим библиотечную функцию =generic_start_main=,
которая по смещению +580 вызывает =main=.

Первая команда, которая будет исполнена - =push %rbp=. Убедимся, что
значение из %rbp оказалось в стеке после выполнения первого шага
программы. Для этого выполним команду =ni=:

#+BEGIN_SRC sh
(gdb) ni
0x00000000004009cc in main ()
(gdb) disassemble
Dump of assembler code for function main:
   0x00000000004009cb <+0>:	push   %rbp
=> 0x00000000004009cc <+1>:	push   %rbx
   0x00000000004009cd <+2>:	sub    $0x8,%rsp
   0x00000000004009d1 <+6>:	mov    %rsi,%rbp
   0x00000000004009d4 <+9>:	lea    -0x1(%rdi),%ebx
   0x00000000004009d7 <+12>:	test   %ebx,%ebx
   0x00000000004009d9 <+14>:	jle    0x4009ed <main+34>
   0x00000000004009db <+16>:	movslq %ebx,%rax
   0x00000000004009de <+19>:	mov    0x0(%rbp,%rax,8),%rdi
   0x00000000004009e3 <+24>:	callq  0x40fee0 <puts>
   0x00000000004009e8 <+29>:	sub    $0x1,%ebx
   0x00000000004009eb <+32>:	jne    0x4009db <main+16>
   0x00000000004009ed <+34>:	add    $0x8,%rsp
   0x00000000004009f1 <+38>:	pop    %rbx
   0x00000000004009f2 <+39>:	pop    %rbp
   0x00000000004009f3 <+40>:	retq
   0x00000000004009f4 <+41>:	nopw   %cs:0x0(%rax,%rax,1)
   0x00000000004009fe <+51>:	xchg   %ax,%ax
End of assembler dump.
#+END_SRC

Отладчик показывает нам место где мы остановились (смещение
+1). Посмотрим теперь на стек.

#+BEGIN_SRC sh
  (gdb) info register esp
  esp            0xffffdd80   -8832
#+END_SRC

Значение указателя стек изменилось, раньше было
0x7fffffffdd88. Посмотрим, что теперь лежит по этому адресу:

#+BEGIN_SRC sh
  (gdb)  x 0x7fffffffdd80
  0x7fffffffdd80:	0x006cb018

  (gdb) info register rbp
  0x7fffffffdd80:	0x006cb018
#+END_SRC

Мы видим, что то что лежит на вершине стека и содержимое %ebp
равны. Таким образом можно убедиться что команда =push %ebp= была
выполнена.

Аналогичным образом можно исследовать выполнение любых других
программ.

* Динамические разделяемые библиотеки

Для популярных библиотек таких как стандартная библиотека C (обычно
libc) быть статичной библиотекой имеет явный недостаток — каждая
исполняемая программа будет иметь копию одного и того же
кода. Действительно, если каждый исполняемый файл будет иметь копию
printf, fopen и тому подобных, то будет занято неоправданно много
дискового пространства.

Менее очевидный недостаток это то, что в статически скомпонованной
программе код фиксируется навсегда. Если кто-нибудь найдёт и исправит
баг в printf, то каждая программа должна будет скомпонована заново,
чтобы заполучить исправленный код.

Чтоб избавиться от этих и других проблем, были представлены
динамически разделяемые библиотеки (обычно они имеют расширение .so
или .dll в Windows и .dylib в Mac OS X). Для этого типа библиотек
компоновщик не обязательно соединяет все точки. Вместо этого
компоновщик выдаёт купон типа «IOU» (I owe you = я тебе должен) и
откладывает обналичивание этого купона до момента запуска программы.

Всё это сводится к тому, что если компоновщик обнаруживает, что
определение конкретного символа находится в разделяемой библиотеке, то
он не включает это определение в конечный исполняемый файл. Вместо
этого компоновщик записывает имя символа и библиотеки, откуда этот
символ должен предположительно появится.

Когда программа вызывается на исполнение, ОС заботится о том, чтобы
оставшиеся части процесса компоновки были выполнены вовремя до начала
работы программы. Прежде чем будет вызвана функция main, малая версия
компоновщика (часто называемая ld.so) проходится по списку обещания и
выполняет последний акт компоновки прямо на месте — помещает код
библиотеки и соединяет все точки.

Это значит, что ни один выполняемый файл не содержит копии кода
printf. Если новая версия printf будет доступна, то её можно
использовать просто изменив libc.so — при следующем запуске программы
вызовется новая printf.

Существует другое большое отличие между тем, как динамические
библиотеки работают по сравнению со статическими и это проявляется в
гранулярности компоновки. Если конкретный символ берётся из конкретной
динамической библиотеки (скажем printf из libc.so), то всё содержимое
библиотеки помещается в адресное пространство программы. Это основное
отличие от статических библиотек, где добавляются только конкретные
объекты, относящиеся к неопределённому символу.

Сформулируем иначе, разделяемые библиотеки сами получаются как
результат работы компоновщика (а не как формирование большой кучи
объектов, как это делает ar), содержащий ссылки между объектами в
самой библиотеке. Повторю ещё, nm — полезный инструмент для
иллюстрации происходящего: для приведённого выше примера он выдаст
множество исходов для каждого объектного файла в отдельности, если
этот инструмент запустить на статической версии библиотеки, но для
разделяемой версии библиотеки liby.so имеет только один неопределённый
символ x31. Также в примере с порядком включения библиотек в конце
предыдущей главы тоже никаких проблем не будет: добавление ссылки на
y32 в b.c не повлечёт никаких изменений, так как всё содержимое y3.o и
x3.o уже было задействовано.

Так между прочим, другой полезный инструмент — это ldd; на платформе
Unix он показывает все разделяемые библиотеки, от которых зависит
исполняемый бинарник (или же другая разделяемая библиотека), вместе с
указанием, где эти библиотеки можно найти. Для того чтобы программа
удачно запустилась, загрузчику необходимо найти все эти библиотеки
вместе со всеми их зависимостями. (Обычно загрузчик ищет библиотеки в
списке директорий, указанных в переменной окружения LD_LIBRARY_PATH.)

/usr/bin:ldd xeyes
        linux-gate.so.1 =>  (0xb7efa000)
        libXext.so.6 => /usr/lib/libXext.so.6 (0xb7edb000)
        libXmu.so.6 => /usr/lib/libXmu.so.6 (0xb7ec6000)
        libXt.so.6 => /usr/lib/libXt.so.6 (0xb7e77000)
        libX11.so.6 => /usr/lib/libX11.so.6 (0xb7d93000)
        libSM.so.6 => /usr/lib/libSM.so.6 (0xb7d8b000)
        libICE.so.6 => /usr/lib/libICE.so.6 (0xb7d74000)
        libm.so.6 => /lib/libm.so.6 (0xb7d4e000)
        libc.so.6 => /lib/libc.so.6 (0xb7c05000)
        libXau.so.6 => /usr/lib/libXau.so.6 (0xb7c01000)
        libxcb-xlib.so.0 => /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
        libxcb.so.1 => /usr/lib/libxcb.so.1 (0xb7be8000)
        libdl.so.2 => /lib/libdl.so.2 (0xb7be4000)
        /lib/ld-linux.so.2 (0xb7efb000)
        libXdmcp.so.6 => /usr/lib/libXdmcp.so.6 (0xb7bdf000)


Причина большей гранулярности заключается в том, что современные
операционные системы достаточно интеллигентны, чтобы позволить делать
больше, чем просто сэкономить сохранение повторяющихся элементов на
диске, чем страдают статические библиотеки. Различные исполняемые
процессы, которые используют одну и туже разделяемую библиотеку, также
могут совместно использовать сегмент кода (но не сегмент данных или
сегмент bss — например, два различных процесса могут находится в
различных местах при использовании, скажем, strtok). Чтобы этого
достичь, вся библиотека должна быть адресована одним махом, чтобы все
внутренние ссылки были выстроены однозначным образом. Действительно,
если один процесс подхватывает a.o и c.o, а другой b.o и c.o, то ОС не
сможет использовать никаких совпадений.


* То, что еще стоит рассмотреть

** Системы сборки

@mangling шаблоны и другие прелести с++
Динамически загружаемые библиотеки
см. https://habrahabr.ru/post/150327/

Перенаправление функций в разделяемых ELF-библиотеках
https://habrahabr.ru/post/106107/
