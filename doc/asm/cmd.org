#+STARTUP: showall indent hidestars
#+TITLE: Получение аргументов командной строки в программах на ассемблере под линукс

* Вводная

В операционной среде, обеспечивающей поддержку Си, имеется возможность
передать аргументы или параметры запускаемой программе с помощью
командной строки.

В момент запуска программы функции =main= передаются два аргумента.
- В первом, обычно называемом argc (сокращение от argument count), стоит
  количество аргументов, заданых в командной строке.
- Второй параметр, называемый argv (от argument vector), является
  указателем на массив символьных строк, содержащих сами аргументы.

* Первые эксперименты

** Точка отсчета

Чтобы получить точку отсчета, нагуглим минимальный пример на языке Си,
который осуществляет обрабоку аргументов командной строки. Вот он:

#+NAME: argv.c
#+BEGIN_SRC c
  #include <stdio.h>
  void main (int argc, char * argv[]) {
      while (--argc > 0) {
          printf("%s\n", argv[argc]);
      }
  }
#+END_SRC

Как мы видим, здесь осуществляется выполнение тела цикла пока
декрементируемая переменная argc не станет равной нулю. В теле цикла
мы передаем функции =printf= адрес начала каждого параметра и она этот
параметр выводит.

Скомпилируем его и убедимся, что все работает:

#+BEGIN_SRC sh
  gcc -g -o argv argv.c
#+END_SRC

После выполнения этой команды должен появится испольняемый файл
=argv=, которы мы тут же запускаем, разумеется с параметрами командной
строки. Он должен нам вывести их в обратном порядке:

#+BEGIN_EXAMPLE
  ./argv this is params from command line
  line
  command
  from
  params
  is
  this
#+END_EXAMPLE

** Как это на ассемблере?

Получим ассемблерный листинг, чтобы понять как это происходит на
нижнем уровне:

#+BEGIN_EXAMPLE
  gcc -S -O1 -o argv.s argv.c
#+END_EXAMPLE

Получаем следующий файл =argv.s=:

#+BEGIN_SRC asm
      .file   "argv.c"
      .text
      .globl  main
      .type   main, @function
  main:
  .LFB23:
      .cfi_startproc
      pushq   %rbp
      .cfi_def_cfa_offset 16
      .cfi_offset 6, -16
      pushq   %rbx
      .cfi_def_cfa_offset 24
      .cfi_offset 3, -24
      subq    $8, %rsp
      .cfi_def_cfa_offset 32
      movq    %rsi, %rbp
      leal    -1(%rdi), %ebx
      testl   %ebx, %ebx
      jle .L1
  .L4:
      movslq  %ebx, %rax
      movq    0(%rbp,%rax,8), %rdi
      call    puts@PLT
      subl    $1, %ebx
      jne .L4
  .L1:
      addq    $8, %rsp
      .cfi_def_cfa_offset 24
      popq    %rbx
      .cfi_def_cfa_offset 16
      popq    %rbp
      .cfi_def_cfa_offset 8
      ret
      .cfi_endproc
  .LFE23:
      .size   main, .-main
      .ident  "GCC: (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005"
      .section    .note.GNU-stack,"",@progbits
#+END_SRC

Если выкинуть из кода все директивы ассемблера, которые не войдут в
исполняемый файл, то код существенно сократится:

#+BEGIN_SRC asm
      .file   "argv.c"
      .text
      .globl  main
      .type   main, @function
  main:
  .LFB23:
      pushq   %rbp
      pushq   %rbx
      subq    $8, %rsp
      movq    %rsi, %rbp
      leal    -1(%rdi), %ebx
      testl   %ebx, %ebx
      jle .L1
  .L4:
      movslq  %ebx, %rax
      movq    0(%rbp,%rax,8), %rdi
      call    puts@PLT
      subl    $1, %ebx
      jne .L4
  .L1:
      addq    $8, %rsp
      popq    %rbx
      popq    %rbp
      ret
  .LFE23:
      .size   main, .-main
      .ident  "GCC: (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005"
      .section    .note.GNU-stack,"",@progbits
#+END_SRC

Итак, что мы тут видим, на этом компактном листинге? Исполнение нашего
кода начинается с функции =main=. Первое что происходит - сохраняются
в стек регистры =%rbp= и =#rbx=. На моей процессорной архитектуре
(64разрядной) каждый из этих регистров занимает 64бита, т.е. 8
байт. Вариант кода для 32разрядной архитектуры рассмотрим чуть позже.

Затем, мы вычитаем из регистра указателя стека =%rsp= константу 8. Это
соответствует резервированию еще 8 байт в стеке. Теперь стек выглядит
так:

#+BEGIN_SRC ditaa :file ./img/stk1.png
 +-------------------------------------------------+ <- %RSP
 | Выделенные смещением указателя стека 8 байт     |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Сохраненный %rbx (4 байта)                      |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Сохраненный %rbp (4 байта)                      |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+
 | Адрес возврата в операционную систему (4 байта) |
 |                                                 |
 |                                                 |
 |                                                 |
 +-------------------------------------------------+

#+END_SRC

Следующим шагом мы делаем команду =movq %rsi, %rbp=, которая
перемещает содержимое регистра =%rsi= в регистр =%rbp=. Забегая
вперед, можно сказать, что скоро станет очевидно, что операционная
система перед запуском программы поместила в регистр =rsi= указатель
на что-то связанное с командной строкой. Интересно что? Посмотрим, что
будет дальше, может бы мы найдем ответ на этот вопрос.

Следующей командой =leal -1(%rdi), %ebx= мы загружаем в регистр %ebx
число, которое на единицу меньше, чем значение в регистре
%rdi. Очевидно, что это и есть уменьшение переменной цикла (которая в
сишном коде у нас называется =argc=) на единицу. Таким образом, мы
можем заключить, что указатель на количество аргументов строки
операционная система при запуске программы помещает в регистр =%rdi=.

Следующей командой мы проверяем равенство переменной цикла
нулю. Команда =test= объединяет возможности команд AND и СМР. Как
команда =and=, она выполняет объединение по логическому "И"
соответствующих бит операндов; как команда =смр=, она изменяет только
состояния регистра =flags=, а не результат. Здесь по логическому "И"
сравнивается регистр %ebx сам с собой. Только в том случае, если %ebx
содержить ноль, в регистре флагов будет выставлен бит ZF (zero flag,
флаг нуля) в единицу.

Следующая команда условного перехода =jle .L1= (jump if less or equal)
проверяет этот бит и если он выставлен в единицу, осуществляется
переход на адрес, соответствующий метке =.L1=. Эта ситуация возникает
тогда, когда у нас нет параметров командной строки, т.е. когда мы
ввели только имя программы. В этом случае при старте этой программы в
регистре %rdi% будет единица, из которой мы вычли единицу, получился
ноль и мы переходим на метку .L1

Сходим туда и посмотрим, чем все закончится.

Мы видим, что мы добавляем к =%esp= констату 8, после чего
восстанавливаем =%rbx= и =%rbp=, приводя стек в то состояние, в
котором он был при запуске программы. У нас в стеке теперь лежит
только адрес возврата. После чего вызывается команда =ret=, которая
возвращает нас из функции =main= в код, который вернет управление в
операционную систему.

Что же будет, если мы все-же введем несколько параметров командной
строки? Тогда команда =jle= не перебросит нас на метку =.L1=, а вместо
этого мы продожим исполнение. И следующая наша команда =movslq  %ebx,
%rax= скопирует содержимое регистра %ebx в %eax. Как мы помним,
несколько раньше мы загрузили в %ebx уменьшенное на единицу количество
параметров командной строки. Теперь оно будет и в =%rax=. Надо
отметить, что %rax содержит 8 байт, а %ebx - четыре. Старшие разряды
будут заполнены командой =movslq= нулями.

Следующая команда =movq 0(%rbp,%rax,8), %rdi= поместит в регистр
=%rdi= содержимое адреса, который будет вычислен выражением
0+%rbp+$rax*8. Вспомним снова, что там лежит, чтобы понять, что это
означает.

Итак, в =%rax= лежит то, что ранее было в %ebx и проверялось на
равенство нулю и в случае успеха проверки завершало программу. Значит,
%rax содержит счетчик оставшихся параметров командной строки

В =%ebp лежит то, что ранее было в %rsi, и очевидно, это
сформированный операционной системой указатель на буфер, в котором
лежит массив байтов, каждый из которых является указателем на
следующий параметр командной строки.

Сумма этих двух регистров умножается на 8 - это размер указателя в
64-битной архитектуре. Потом выполняется обращение по получившимуся
адресу, и полученное значение попадает в регистр =%rdi=.

И следующая команда =call puts@PLT= как раз принимает указатель на
строку, заканчивающуюся нулем в этом регистре! После ее выполнения (и
вывода строки на экран) регистр %ebx будет уменьшен на единицу: =subl
$1, %ebx=. Эта операция взведет флаг ZF если результат стал нулем и
следующая команда =jne .L4= перебросит нас на метку =.L4= если этого
НЕ произошло. Таким образом цикл будет повторяться пока не кончатся
все параметры.

** TODO Что если у нас другая архитектура?
** Получаем объектный файл

Объектный файл - это файл с промежуточным представлением отдельного
модуля программы, полученный в результате обработки исходного кода
компилятором. Объектный файл содержит в себе особым образом
подготовленный код (часто называемый двоичным или бинарным), который
может быть объединён с другими объектными файлами при помощи редактора
связей (компоновщика) для получения готового исполнимого модуля, или
библиотеки.

Объектные файлы представляют собой блоки машинного кода и данных, с
неопределенными адресами ссылок на данные и процедуры в других
объектных модулях, а также список своих процедур и данных. Компоновщик
собирает код и данные каждого объектного модуля в итоговую программу,
вычисляет и заполняет адреса перекрестных ссылок между
модулями.

Связывание со статическими библиотеками выполняется редактором связей
или компоновщиком (который может представлять собой отдельную
программу или быть частью компилятора), а с операционной системой и
динамическими библиотеками связывание выполняется при исполнении
программы, после её загрузки в память.

В первую очередь нам надо убедиться полученный ассемблерный листинг
можно превратить в правильный объектный файл:

#+BEGIN_SRC sh
  as argv.s -o argv.o
#+END_SRC

Посмотрим, что у нас получилось:

#+BEGIN_SRC sh
  objdump -hrt argv.o

  argv.o:     формат файла elf64-x86-64

  Разделы:
  Инд Имя           Размер    VMA               LMA               Файл      Вырав
    0 .text         00000029  0000000000000000  0000000000000000  00000040  2**0
                    CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
    1 .data         00000000  0000000000000000  0000000000000000  00000069  2**0
                    CONTENTS, ALLOC, LOAD, DATA
    2 .bss          00000000  0000000000000000  0000000000000000  00000069  2**0
                    ALLOC
    3 .comment      0000002e  0000000000000000  0000000000000000  00000069  2**0
                    CONTENTS, READONLY
    4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000097  2**0
                    CONTENTS, READONLY
    5 .eh_frame     00000040  0000000000000000  0000000000000000  00000098  2**3
                    CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  SYMBOL TABLE:
  0000000000000000 l    df *ABS*  0000000000000000 argv.c
  0000000000000000 l    d  .text  0000000000000000 .text
  0000000000000000 l    d  .data  0000000000000000 .data
  0000000000000000 l    d  .bss   0000000000000000 .bss
  0000000000000000 l    d  .note.GNU-stack    0000000000000000 .note.GNU-stack
  0000000000000000 l    d  .eh_frame  0000000000000000 .eh_frame
  0000000000000000 l    d  .comment   0000000000000000 .comment
  0000000000000000 g     F .text  0000000000000029 main
  0000000000000000         *UND*  0000000000000000 _GLOBAL_OFFSET_TABLE_
  0000000000000000         *UND*  0000000000000000 puts


  RELOCATION RECORDS FOR [.text]:
  OFFSET           TYPE              VALUE
  0000000000000019 R_X86_64_PLT32    puts-0x0000000000000004


  RELOCATION RECORDS FOR [.eh_frame]:
  OFFSET           TYPE              VALUE
  0000000000000020 R_X86_64_PC32     .text
#+END_SRC

В объектном файле есть секции:
- =.text= - это скомпилированная программа, то есть машинные коды
  операций, соответствующие программе. Она будет использоваться
  загрузчиком программ для инициализации сегмента кода процесса.
- =.data= - наша программа не имеет ни инициализированных глобальных
  переменных, ни инициализированных статических локальных переменных,
  поэтому этот раздел должен быть пуст. Обычно этот раздел содержит
  предварительно инициализированные данные для загрузки в сегмент
  данных.
- =.bcc= - кусок неинициализированных данных, этот раздел указывает на
  то, сколько байтов должно быть выделено и обнулено в сегменте данных
  в дополнение к разделу .data. В нашей программе он пуст.
- =.comment=: этот сегмент содержит комментарии

Также в объектном файле могут встретиться другие секции:
- =.rodata= - этот сегмент содержит строки, которые помечена только для
  чтения. Большинство операционных систем не поддерживают сегмент
  данных только для чтения для процессов, поэтому содержимое .rodata
  переходит либо в сегмент кода процесса (потому что он доступен
  только для чтения), либо в сегмент данных (поскольку это
  данные). Поскольку компилятор не знает политики, принятой вашей ОС,
  он создает этот дополнительный раздел.
- =.debug_*=: - разделы с символами, которые облегчают отладку
- и другие..

Он также показывает нам таблицу символов с символом =main=, связанным
с адресом 00000029, и символ помещает undefined. Кроме того, таблица
перемещений говорит нам, как переместить ссылки на внешние разделы,
сделанные в разделе .text. Первый перемещаемый символ puts, обозначает
функцию libc, в которуюю была сгенерирована printf.

** Компоновка

Если сильно упростить, компоновка — это процесс извлечения секций из
объектных файлов, раскладывание их по указанным адресам и настройки
перекрестных ссылок.

В обычных операционнх системах ядро умеет читать выходной файл и
загружать секции в память по ожидаемым виртуальным адресам. Со
встраиваемыми системами проще, программа для прошивки берет бинарный
файл и заливает на флешку как есть.

Теперь давайте посмотрим на процесс преобразования в исполняемый
файл. Можно подумать, что следующая команда вызовет компоновщик,
который сделает все необходимые вещи:

#+BEGIN_SRC sh
  ld -o argv argv.o
  ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
#+END_SRC

Но нет, компоновщик говорит, что ему нужна метка =_start= в качестве
символа, с которого начнется выполенение программы. Если же мы
поменяем в файле =main= на =start=, скомпилируем и попытаемся
скомпоновать - то он снова выдает ошибку:

#+BEGIN_SRC sh
  argv.c:(.text+0x38): undefined reference to `puts'
#+END_SRC

Все дело в функции =puts=, в вызов которой преобразовался =printf= -
компоновщик просто не знает, где ее взять. Попробуем немного ему
помочь, статически подключив библиотеку =libc=, в которой она
определена:

#+BEGIN_SRC sh
  ld -static -o argv argv.o -lc
#+END_SRC

Эта команда выдает нам много ошибок вида =undefined
reference=. Очевидно, что =libc= вызывает что-то еще. Много чего
еще. Тут уже не обойтись без руководства. Читать я его конечно не
буду, лучше пойду на stackoverflow, который разьясняет некоторые
тонкие моменты.

Mало подключить библиотеку =libc= еще совершенно необходимо подключить
библиотеку времени выполнения =crt1= (common runtime). =crt1= содержит
метку =_start=, и устанавливает =env= (окружение) с помощью argc /
argv / libc _init / libc _fini перед тем, как вызвать главную функцию
библиотеки =libc=.

Также необходимо подключить еще две библиотеки: =crti= и =crtn=. Они
определяют код, который будет выполняться до инициализации =libc= и
после ее деинициализации.

Более того, все это довольно запутанным образом ссылается друг на
друга, поэтому нужно линковать в определенном порядке, для чего
придуманы специальные параметры =--start-group= и =--end-group=,
которые работают как скобки.

Все это превращает линковку в настолько сложную процедуру, что даже
специально разработан скриптовый язык для управления компоновщиком:
https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html

Но мы не будем его использовать а вместо этого подключим библиотеки
одну за другой

#+BEGIN_SRC sh
  ld -static                          \
     -o argv                          \
     -L`gcc -print-file-name=`        \
     /usr/lib/x86_64-linux-gnu/crt1.o \
     /usr/lib/x86_64-linux-gnu/crti.o \
     argv.o                           \
     /usr/lib/x86_64-linux-gnu/crtn.o \
     --start-group -lc -lgcc -lgcc_eh --end-group
#+END_SRC

Что здесь происходит? Мы указываем, что компоновщик должен:
- произвести статическую линковку, т.е. собрать все библиотеки в один
  файл (-static)
- выходной файл должен называться "argv"
- путь для поиска библиотек должен быть получен путем выполнения
  команды =gcc -print-file-name==, которая на моей машине возвращает
  =/usr/lib/gcc/x86_64-linux-gnu/6/=
- первым файлом, который будет размещен в начале нашего исполняемого
  модуля будет =crt1.0=
- затем пойдет файл =crto.0=
- потом мы берем наш объектный файл, полученный на прошлом этапе
- и, наконец, =crtn.o=
- после этого мы включаем три библиотеки в указанном порядке: =libc=,
  =libgcc=, =libgcc_eh=.

Теперь компоновщик может построить исполняемый файл и аккуратно
настроить все ссылки.
** Трассировка системных вызовов

#+BEGIN_SRC sh
  file argv
  argv: ELF 64-bit LSB executable, x86-64,
        version 1 (GNU/Linux),
        statically linked, for GNU/Linux 2.6.32,
        not stripped
  ./argv one two three
  three
  two
  one
#+END_SRC

Попробуем посмотреть какие системные вызовы делает наша
программа. Воспользуемся для этого инструментом =strace=

strace — это утилита, отслеживающая системные вызовы, которые
представляют собой механизм, обеспечивающий интерфейс между
процессом и операционной системой.

Эти вызовы могут быть перехвачены и прочитаны. Это позволяет лучше
понять, что процесс пытается сделать в заданное время. Перехватывая
эти вызовы, мы можем добиться лучшего понимания поведения процессов,
особенно если что-то идет не так.

#+BEGIN_SRC sh
  execve("./argv", ["./argv", "ONE", "TWO", "THREE"], [/* 62 vars */]) = 0
  uname({sysname="Linux", nodename="ng", ...}) = 0
  brk(NULL)                               = 0x7ad000
  brk(0x7ae1c0)                           = 0x7ae1c0
  arch_prctl(ARCH_SET_FS, 0x7ad880)       = 0
  readlink("/proc/self/exe", "/path/to/file/argv", 4096) = 29
  brk(0x7cf1c0)                           = 0x7cf1c0
  brk(0x7d0000)                           = 0x7d0000
  access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
  write(1, "THREE\n", 6THREE
  )                  = 6
  write(1, "TWO\n", 4TWO
  )                    = 4
  write(1, "ONE\n", 4ONE
  )                    = 4
  exit_group(4)                           = ?
  +++ exited with 4 +++
#+END_SRC

Здесь можно увидеть три вызова фунции =write=, про которую можно
прочитать, запустив команду =man 2 write=. Согласно этой справке она
принимает три параметра:
- файловый дескриптор
- указатель на буфер
- размер буфера

#+BEGIN_SRC c
  ssize_t write(int fd, const void *buf, size_t count);
#+END_SRC

В выдаче =strace= мы видим, что первым параметром все три раза
является "1", т.е. мы пишем в файловый дескриптор, соответствующий
"стандартному выводу". После мы видим само содержимое переданного
буфера (добавлен знак "\n" перевода строки), потом размер буфера,
потом сюда вклинивается сам вывод строки, и после закрывающей скобки
мы видим возвращаемый результат - количество выведенных символов.

После того как все будет выведено программа завершается, с кодом
возврата "4". Это произошло из-за того что в регистре %rax осталось
последнее возвращаенное значение функции =write=. Если мы очистим
регистр, например командой =xor %rax, %rax=, то значение будет равно
нулю.

Первый системный вызов - =execve=: запуск файла на выполнение. В скобках
передается команда с аргументами (если они есть) и количество
переменных окружения, переданных процессу. По умолчанию strace не
показы вает сами переменные окружения, но его можно попросить выводить
более подробную информацию с помощью опции ‘-v’. Вызов возвратил 0 —
значит все ok. В противном случае значение было бы -1.

Следующий интересный системный вызов — access: проверка прав
пользователя на файл. В данном случае тестируется существование файла
(о чем говорит режим проверки F_OK). На третьей строчке системный
вызов вернул значение -1 (ошибка) и вывел ошибку ENOENT (No such file
or directory). Это нормально, так как этот файл, если он есть, всего
лишь служит для указания линковщику на использование стандартных
неоптимизированных версий библиотек (для целей отладки)

Манипуляции над файлом всегда начинаются с системного вызова =open=,
открывающего файл в одном из режимов (O_RDONLY, O_WRONLY или O_RDWR),
кроме файлов стандартного ввода, стандартного вывода, и стандартного
вывода ошибкок, которые открыты с самого старта программы.

Вызов =open= возвращает небольшое целое число — файловый дескриптор,
который впоследствии будет использоваться другими вызовами (до того
момента, пока не будет закрыт с помощью вызова =close=).

После открытия файла вызовом open происходит его чтение вызовом =read=
или запись вызовом =write=. Оба вызова принимают файловый дескриптор,
а возвращают количество прочитанных/записанных байт.

Вызов =fstat= предназначен для получения информации о файле

Системный вызов =uname= позволяет
получить информацию о текущем ядре. Если трассировка uname занимает
всего сотню строк, то трассировка серьезного приложения легко может
занимать несколько тысяч строк. Читать такой лог — не самое большое
удовольствие. Поэтому иногда лучше записывать в лог только
определенные вызовы. Например, чтобы отследить все вызовы open и
access (а на них следует обращать внимание в первую очередь при
проблемах с запуском приложения):

Остальные вызовы, которые поймал =strace= можно посмотреть в
документации. Благодаря тому, что можно перехватывать общение
программы с операционной системой, мы можем многое сказать о поведении
программы. Это особенно интересно, когда она написана кем-то
другим.

А вот так можно увидеть полную таблицу вызовов, которые делает
программа

#+BEGIN_SRC sh
  strace -c  ./argv
  % time     seconds  usecs/call     calls    errors syscall
  ------ ----------- ----------- --------- --------- ----------------
    0.00    0.000000           0         4           brk
    0.00    0.000000           0         1         1 access
    0.00    0.000000           0         1           execve
    0.00    0.000000           0         1           uname
    0.00    0.000000           0         1           readlink
    0.00    0.000000           0         1           arch_prctl
  ------ ----------- ----------- --------- --------- ----------------
  100.00    0.000000
#+END_SRC
** COMMENT Использование отладчика

Запустим нашу программу под отладчиком. И сразу воспользуемся командой
=info functions=, чтобы получить имена всех функций, которые есть в
программе. Вывод получается довольно длинным, поэтому я сокращу его
только до самых интересных функций:

#+BEGIN_SRC sh
  gdb --quiet ./argv
  (gdb) info functions
  All defined functions:

  Non-debugging symbols:
  0x00000000004002b8  _init
  0x0000000000400504  oom
  0x0000000000400530  fini
  0x00000000004009a0  _start
  0x00000000004009cb  _start
  0x00000000004009cb  main
  0x0000000000400dd0  __libc_start_main
  0x000000000040eda0  exit
  0x000000000040fee0  puts
  0x000000000043f4f0  _Exit
  0x000000000043f4f0  _exit
  0x000000000043ff00  write
  0x00000000004a2b94  _fini
  (gdb)
#+END_SRC

С помощью команды =disassemble= мы можем просмотреть код любой
функции. Например нашей функции =main=:

#+BEGIN_SRC gdbout
  (gdb) disassemble main
  Dump of assembler code for function main:
     0x00000000004009cb <+0>: push   %rbp
     0x00000000004009cc <+1>: push   %rbx
     0x00000000004009cd <+2>: sub    $0x8,%rsp
     0x00000000004009d1 <+6>: mov    %rsi,%rbp
     0x00000000004009d4 <+9>: lea    -0x1(%rdi),%ebx
     0x00000000004009d7 <+12>:    test   %ebx,%ebx
     0x00000000004009d9 <+14>:    jle    0x4009ed <main+34>
     0x00000000004009db <+16>:    movslq %ebx,%rax
     0x00000000004009de <+19>:    mov    0x0(%rbp,%rax,8),%rdi
     0x00000000004009e3 <+24>:    callq  0x40fee0 <puts>
     0x00000000004009e8 <+29>:    sub    $0x1,%ebx
     0x00000000004009eb <+32>:    jne    0x4009db <main+16>
     0x00000000004009ed <+34>:    add    $0x8,%rsp
     0x00000000004009f1 <+38>:    pop    %rbx
     0x00000000004009f2 <+39>:    pop    %rbp
     0x00000000004009f3 <+40>:    retq
     0x00000000004009f4 <+41>:    nopw   %cs:0x0(%rax,%rax,1)
     0x00000000004009fe <+51>:    xchg   %ax,%ax
  End of assembler dump.
#+END_SRC

Знакомый код, если не считать того, что некоторые имена теперь
представлены как им и полагается, адресами памяти. Но это не мешает
нам, к примеру дизассеблировать функцию =puts=, набрав команду
=disassemble 0x40fee0=

#+BEGIN_SRC conf
  (gdb) disassemble 0x40fee0
  Dump of assembler code for function puts:
     0x000000000040fee0 <+0>: push   %r13
     0x000000000040fee2 <+2>: push   %r12
     0x000000000040fee4 <+4>: mov    %rdi,%r12
     0x000000000040fee7 <+7>: push   %rbp
     0x000000000040fee8 <+8>: push   %rbx
     0x000000000040fee9 <+9>: sub    $0x8,%rsp
     0x000000000040feed <+13>:    callq  0x4247c0 <strlen>
     0x000000000040fef2 <+18>:    mov    0x2bb847(%rip),%rbp        # 0x6cb740 <stdout>
     0x000000000040fef9 <+25>:    mov    %rax,%rbx
     0x000000000040fefc <+28>:    mov    0x0(%rbp),%eax
     0x000000000040feff <+31>:    mov    %rbp,%rdi
     0x000000000040ff02 <+34>:    and    $0x8000,%eax
     0x000000000040ff07 <+39>:    jne    0x40ff6a <puts+138>
     0x000000000040ff09 <+41>:    mov    0x88(%rbp),%rdx
     0x000000000040ff10 <+48>:    mov    %fs:0x10,%r8
     0x000000000040ff19 <+57>:    cmp    0x8(%rdx),%r8
     0x000000000040ff1d <+61>:    je     0x410060 <puts+384>
     0x000000000040ff23 <+67>:    mov    $0x1,%esi
     0x000000000040ff28 <+72>:    cmpl   $0x0,0x2be235(%rip)        # 0x6ce164 <__libc_multiple_threads>
     0x000000000040ff2f <+79>:    je     0x40ff39 <puts+89>
     0x000000000040ff31 <+81>:    lock cmpxchg %esi,(%rdx)
     0x000000000040ff35 <+85>:    jne    0x40ff3e <puts+94>
     0x000000000040ff37 <+87>:    jmp    0x40ff54 <puts+116>
     0x000000000040ff39 <+89>:    cmpxchg %esi,(%rdx)
     0x000000000040ff3c <+92>:    je     0x40ff54 <puts+116>
     0x000000000040ff3e <+94>:    lea    (%rdx),%rdi
     0x000000000040ff41 <+97>:    sub    $0x80,%rsp
     0x000000000040ff48 <+104>:   callq  0x4432f0 <__lll_lock_wait_private>
     0x000000000040ff4d <+109>:   add    $0x80,%rsp
     0x000000000040ff54 <+116>:   mov    0x88(%rbp),%rdx
     0x000000000040ff5b <+123>:   mov    0x2bb7de(%rip),%rdi        # 0x6cb740 <stdout>
     0x000000000040ff62 <+130>:   mov    %r8,0x8(%rdx)
     0x000000000040ff66 <+134>:   addl   $0x1,0x4(%rdx)
     0x000000000040ff6a <+138>:   mov    0xc0(%rdi),%eax
     0x000000000040ff70 <+144>:   test   %eax,%eax
     0x000000000040ff72 <+146>:   jne    0x410048 <puts+360>
     0x000000000040ff78 <+152>:   movl   $0xffffffff,0xc0(%rdi)
     0x000000000040ff82 <+162>:   mov    0xd8(%rdi),%r13
     0x000000000040ff89 <+169>:   mov    $0x4bfc68,%eax
     0x000000000040ff8e <+174>:   sub    $0x4bf5c0,%rax
     0x000000000040ff94 <+180>:   mov    %r13,%rdx
     0x000000000040ff97 <+183>:   sub    $0x4bf5c0,%rdx
     0x000000000040ff9e <+190>:   cmp    %rdx,%rax
     0x000000000040ffa1 <+193>:   jbe    0x410070 <puts+400>
     0x000000000040ffa7 <+199>:   mov    %rbx,%rdx
     0x000000000040ffaa <+202>:   mov    %r12,%rsi
     0x000000000040ffad <+205>:   callq  *0x38(%r13)
     0x000000000040ffb1 <+209>:   cmp    %rax,%rbx
     0x000000000040ffb4 <+212>:   jne    0x410051 <puts+369>
     0x000000000040ffba <+218>:   mov    0x2bb77f(%rip),%rdi        # 0x6cb740 <stdout>
     0x000000000040ffc1 <+225>:   mov    0x28(%rdi),%rax
     0x000000000040ffc5 <+229>:   cmp    0x30(%rdi),%rax
     0x000000000040ffc9 <+233>:   jae    0x410088 <puts+424>
     0x000000000040ffcf <+239>:   lea    0x1(%rax),%rdx
     0x000000000040ffd3 <+243>:   mov    %rdx,0x28(%rdi)
     0x000000000040ffd7 <+247>:   movb   $0xa,(%rax)
     0x000000000040ffda <+250>:   add    $0x1,%rbx
     0x000000000040ffde <+254>:   mov    $0x7fffffff,%eax
     0x000000000040ffe3 <+259>:   cmp    $0x7fffffff,%rbx
     0x000000000040ffea <+266>:   cmova  %rax,%rbx
     0x000000000040ffee <+270>:   testl  $0x8000,0x0(%rbp)
     0x000000000040fff5 <+277>:   jne    0x410036 <puts+342>
     0x000000000040fff7 <+279>:   mov    0x88(%rbp),%rdx
     0x000000000040fffe <+286>:   subl   $0x1,0x4(%rdx)
     0x0000000000410002 <+290>:   jne    0x410036 <puts+342>
     0x0000000000410004 <+292>:   movq   $0x0,0x8(%rdx)
     0x000000000041000c <+300>:   cmpl   $0x0,0x2be151(%rip)        # 0x6ce164 <__libc_multiple_threads>
     0x0000000000410013 <+307>:   je     0x41001c <puts+316>
     0x0000000000410015 <+309>:   lock decl (%rdx)
     0x0000000000410018 <+312>:   jne    0x410020 <puts+320>
     0x000000000041001a <+314>:   jmp    0x410036 <puts+342>
     0x000000000041001c <+316>:   decl   (%rdx)
     0x000000000041001e <+318>:   je     0x410036 <puts+342>
     0x0000000000410020 <+320>:   lea    (%rdx),%rdi
     0x0000000000410023 <+323>:   sub    $0x80,%rsp
     0x000000000041002a <+330>:   callq  0x443320 <__lll_unlock_wake_private>
     0x000000000041002f <+335>:   add    $0x80,%rsp
     0x0000000000410036 <+342>:   add    $0x8,%rsp
     0x000000000041003a <+346>:   mov    %ebx,%eax
     0x000000000041003c <+348>:   pop    %rbx
     0x000000000041003d <+349>:   pop    %rbp
     0x000000000041003e <+350>:   pop    %r12
     0x0000000000410040 <+352>:   pop    %r13
     0x0000000000410042 <+354>:   retq
     0x0000000000410043 <+355>:   nopl   0x0(%rax,%rax,1)
     0x0000000000410048 <+360>:   cmp    $0xffffffff,%eax
     0x000000000041004b <+363>:   je     0x40ff82 <puts+162>
     0x0000000000410051 <+369>:   mov    $0xffffffff,%ebx
     0x0000000000410056 <+374>:   jmp    0x40ffee <puts+270>
     0x0000000000410058 <+376>:   nopl   0x0(%rax,%rax,1)
     0x0000000000410060 <+384>:   mov    %rbp,%rdi
     0x0000000000410063 <+387>:   jmpq   0x40ff66 <puts+134>
     0x0000000000410068 <+392>:   nopl   0x0(%rax,%rax,1)
     0x0000000000410070 <+400>:   callq  0x4120c0 <_IO_vtable_check>
     0x0000000000410075 <+405>:   mov    0x2bb6c4(%rip),%rdi        # 0x6cb740 <stdout>
     0x000000000041007c <+412>:   jmpq   0x40ffa7 <puts+199>
     0x0000000000410081 <+417>:   nopl   0x0(%rax)
     0x0000000000410088 <+424>:   mov    $0xa,%esi
     0x000000000041008d <+429>:   callq  0x415930 <__overflow>
     0x0000000000410092 <+434>:   cmp    $0xffffffff,%eax
     0x0000000000410095 <+437>:   jne    0x40ffda <puts+250>
     0x000000000041009b <+443>:   jmp    0x410051 <puts+369>
     0x000000000041009d <+445>:   testl  $0x8000,0x0(%rbp)
     0x00000000004100a4 <+452>:   mov    %rax,%rsi
     0x00000000004100a7 <+455>:   jne    0x4100e8 <puts+520>
     0x00000000004100a9 <+457>:   mov    0x88(%rbp),%rdx
     0x00000000004100b0 <+464>:   subl   $0x1,0x4(%rdx)
     0x00000000004100b4 <+468>:   jne    0x4100e8 <puts+520>
     0x00000000004100b6 <+470>:   movq   $0x0,0x8(%rdx)
     0x00000000004100be <+478>:   cmpl   $0x0,0x2be09f(%rip)        # 0x6ce164 <__libc_multiple_threads>
     0x00000000004100c5 <+485>:   je     0x4100ce <puts+494>
     0x00000000004100c7 <+487>:   lock decl (%rdx)
     0x00000000004100ca <+490>:   jne    0x4100d2 <puts+498>
     0x00000000004100cc <+492>:   jmp    0x4100e8 <puts+520>
     0x00000000004100ce <+494>:   decl   (%rdx)
     0x00000000004100d0 <+496>:   je     0x4100e8 <puts+520>
     0x00000000004100d2 <+498>:   lea    (%rdx),%rdi
     0x00000000004100d5 <+501>:   sub    $0x80,%rsp
     0x00000000004100dc <+508>:   callq  0x443320 <__lll_unlock_wake_private>
     0x00000000004100e1 <+513>:   add    $0x80,%rsp
     0x00000000004100e8 <+520>:   mov    %rsi,%rdi
     0x00000000004100eb <+523>:   callq  0x49e250 <_Unwind_Resume>
  End of assembler dump.
#+END_SRC

Анализируя ее, мы видим, что по смещению +13 от начала функции
происходит вызов =strlen=, который вычисляет размер переданных данных,
чтобы потом передать его в третьем параметре системного вызова
=write=.

А по смещению +405 в регистр %rdi записывается значение, помеченное
как <stdout>, что очень похоже на передачу параметров. Следующий за
этим безусловный переход =<+412>: jmpq   0x40ffa7 <puts+199>=
подтверждает это предположение. Поставим точку останова на начало
функции и проверим это:
