#+STARTUP: showall indent hidestars
#+TITLE: Виртуальная машина аркадных игр

* Введение

Многие программисты используют написание аркадных игр для того чтобы
попрактиковаться в незнакомом языке программирования, методологии или
парадигме. Обучающие статьи такого рода помогают познакомить
сообщество с новыми идеями, такими как, например, реактивное
программирование: https://habrahabr.ru/company/infopulse/blog/338910/

Мне нравятся необычные подходы в программировании, такие, например,
как создание языков предметной области (Domain Specific Language,
DSL). Некоторые мощные языки, такие как Lisp и Forth пропагандируют
такой подход, но так как их популярность невелика, большинство
программистов не знают о том, что так тоже можно.

Поэтому я решил написать эту статью.

Кроме того, мне хотелось бы исследовать, смогут ли методы
искусственного интеллекта определять выигрышные игровые стратегии
опираясь на исходный код игры. Исходный код игр, как правило, слишком
перегружен нюансами и трудоемок для анализа. Код языка предметной
области может подходить для этой задачи лучше.

Мы будем создавать ассемблер и виртуальную машину (VM) для
классических аркадных игр. Это всем известные игры, такие как
"змейка", "диггер" или даже "сапер".

В классических аркадах игра происходит на одном экране, который виден
целиком, главный герой и враги представлены спрайтами, управление
происходит с клавиатуры или джойстика.

Итак приступим.

* Система команд виртуального процессора

** Команда ввода

Основная характерная часть аркадных игр - это специфическая система
управления, берущая начало от управляющих панелей аркадных
автоматов.

https://geektimes.ru/post/249984/

Эти управляющие панели представляют собой джойстик и кнопки управления
персонажем для каждого игрока плюс несколько общих для обоих игроков
кнопок, таких как, например "start game". Монетоприемник для простоты
тоже можно считать такой кнопкой или набором кнопок, если он принимает
монеты разного номинала.

Игрок управляет только своим объектом (персонажем) в двухмерном
пространстве в границах экрана.

Поэтому мы сразу можем определить команду, которую будем использовать
для получения состояния элементов управления. Она должна возвращать
нам строку битов, которая определяет положение джойстика и какие
клавиши в данный момент зажаты.

Назовем это команду =kbd=.

** Команда вывода
