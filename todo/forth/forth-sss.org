http://faceted-jacinth.livejournal.com/72169.html

Читаю Goedel, Escher, Bach (всё ещё), про активные символы етс, по поводу чего решил
наконец написать про язык программирования Форт, потому что есть в нём что-то такое.

Форт - это не язык, не мета-язык и не операционная система, это Идея, которая может
воплощаться в конкретных мета-языках, языках и форт-системах. В своём рассказе я
попытаюсь избежать углубления в детали, поскольку, как мне кажется, Идея настолько
красива, что будет интересна и полезна даже непрограммистам. А может быть - особенно
непрограммистам, поскольку программировать на форте ИМХО тяжело и бессмысленно, хотя
какие-то части Идеи или навеянные ей концепции скорее всего проникнут и уже проникают в
некоторые сферы человеческой деятельности. В когнитивную психологию, например =) Я
серьёзно.

А для программистегов и программисточег - must read абсолютно точно, потому что плох
тот программист, кто не мечтает написать собственный язык.

И тут же углубляюсь в необходимые детали =)

Форт-система представляет собой Словарь, в котором каждому Слову соответствует кусок
самого обычного машинного кода. В коде могут встречаться вызовы кода, соответствующего
другим Словам.

В ядре, то есть начальном словаре, определены слова для работы с условно-виртуальной
стековой машиной (арифметические действия, drop/dup/rotate и всё такое), Слово,
выдирающее следующее Слово из входного потока, Слово, создающее новую Словарную Статью
для данного слова, Слово, находящее в Словаре статью с данным именем, Слово, передающее
управление коду в Статье с данным именем и некоторые другие (немного, порядка сотни, с
кодом килобайт эдак на 8 для 8х86, точной цифры не знаю).

Сам процесс работы системы выглядит приблизительно так: ей даётся текст программы и
запускается слово Interpret, которое считывает очередное входное слово, находит его в
Словаре и передаёт управление на соответствующий ему код. Когда код возвращает
управление, процесс продолжается. Типа, интерпретация.

Допустим, очередное встреченное слово было ":" (двоеточие). Это слово, получив
управление, считывает следующее слово, создаёт новую словарную статью с таким именем и
начинает компилировать в неё все дальнейшие слова до слова ";". "Компилировать" в
простейшем случае означает вставлять инструкции вызова соответствующих слов.

В конце концов на выполнение запускается какое-нибудь слово типа "Поехали!", которое
делает то, что нужно сделать. Или в интерактивном режиме пользователь даёт какие-нибудь
команды. Или текущий словарь скидывается на диск.


Объединение компилятора, интерпретатора и, собственно, программы (включая необходимые
данные) в одну гомогенную структуру красиво само по себе, но предоставляемые таким
подходом возможности стократ интереснее.


Дело в том, что абсолютно весь код компилятора/интерпретатора, все составляющие его
слова, весь служебный стек и внутренние структуры данных доступны интерпретируемой
программе. Можно написать собственное слово "::", которое будет компилировать код
Особым Образом (например, с оптимизацией), а можно подменить уже существующее слово
":". Более того, само стандартное слово ":" распознаёт ключевые слова, которые
позволяют переходить из режима компиляции в режим интерпретации и обратно. То есть
компилируемое слово может активно вмешиваться в процесс компиляции себя (учитывая
текущее состояние системы) и следующих слов. Например, слово ";" завершает компиляцию,
начатую словом ":", совершенно самостоятельно.

Ещё можно создать новый Словарь, введя в нём слова для ассемблера другой target
machine, и перекомпилить текущий буквально парой команд.

Именно это делает форт мета-языком: мало того, что можно не включать в ядро всякие
циклы, условные переходы и определение переменных, это всё прекрасно пишется, так ещё
можно быстро научить систему понимать инфиксную запись математических выражений (вместо
дефолтной постфиксной, вытекающей из свойств underlying стековой машины) и pascal-style
объявление переменных.

Возможность подстраивать синтаксис языка под текущую задачу кажется мне Добром сама по
себе, но и это ещё не всё.

Конечно, можно писать прямо на голом базовом форте как на каком-нибудь макроассемблере,
воспринимая введение новых слов как объявление процедур. Можно с большим или меньшим
трудом написать интерпретатор какого-нибудь С-подобного языка, после чего наслаждаться
возможностью встроить в foreach автоматически генерируемый счётчик цикла, но это тоже
остановка на полдороге.

Дело в том, что форт фактически предлагает другую, не побоюсь этого слова, парадигму
программирования. В стандартной парадигме есть фиксированный интерпретатор, который
интерпретирует программу, в которой и заключена суть алгоритма. Тут же всё наоборот -
постепенно строится сложный интерпретатор, который в результате должен
проинтерпретировать единственное слово "поехали!" и данные произвольной структуры. И
если строить этот интерпретатор именно как интерпретатор, с постоянно меняющимся и
усложняющимся интерпретируемым языком, то удаётся достичь удивительной ёмкости
изложения, по крайней мере в некоторых задачах. Такое ощущение, что если в случае
процедурного подхода каждая строчка увеличивает мощность программы на константу, то
здесь мощность умножается на константу.

В качестве иллюстрации приведу код, обучающий форт-систему инфиксной записи. Читать сам
код совершенно необязательно, я его сам не понимаю и переписал из книжки с единственной
целью - продемонстрировать его компактность.
1) создаётся стек ops, в котором будут запоминаться операции

create ops here 2+ , 40 allot

2) определяются слова ">ops", "ops>" и "ops@", которые перемещают данные между этим
   конкретным стеком ops и основным стеком данных (типа >ops = push, ops> = pop, ops@ =
   peek)

: >ops ops @ ! 2 ops +! ;
: ops@ ops @ 2- @ ;
: ops> ops@ -2 ops +! ;

3) предполагая, что в стеке ops лежат пары "адрес операции":"приоритет" пишется слово
   >ops>, которое засовывает текущую операцию в этот стек, исполняя/компилируя (в
   зависимости от текущего состояния интерпретатора) все операции с меньшим
   приоритетом.

: >ops> >r begin ops@
   r@ < not while ops> drop ops>
state @ if , else execute then repeat r> drop;

(да, выглядит как КОД ИЗ АДА, не спорю. Но, наверное, можно привыкнуть. Как к
регулярным выражениям, например)
4) определяется слово 2-op, которое берёт со стека приоритет, из входного потока
   следующее слово и переопределяет его, следующее слово, как вызов >ops> с этим
   приоритетом и указателем на предыдущий код этого слова, причём с аттрибутом
   IMMEDIATE, то есть эти новые слова всегда исполняются, даже в режиме компиляции -
   поскольку они, собственно, и должны компилировать/интерпретировать код. Определяется
   1-op - как вызов 2-op c приоритетом 9.

: 2-op >in @ >r '
   r> >in ! create IMMEDIATE , ,
   >r >r r@ >ops> r> r> >ops >ops ;
: 1-op 9 2op ;

5) системе скармливается последовательность

2 2-op or     2 2-op xor    3 2-op and    4 2-op *
5 2-op <      5 2-op >      6 2-op +      6 2-op -
7 2-op *      7 2-op /      7 2-op mod
1-op not      1-op abs      1-op negate

Которая всё и переопределяет.
6) определяются круглые скобки: открывающая кладёт на стек ops ограничитель 0,
   закрывающая выталкивает (исполняет/компилирует) всё до ограничителя

: ( 0 >ops ; IMMEDIATE
: ) 1 >ops> ops> drop ; IMMEDIATE



Вот, собственно, и всё. Теперь код "( 2 + 3 * ( 4 + 6 ) ) / 2 " оставляет на стеке 16.
Это иллюстрирует фортопарадигменный подход, следуя которому мы во-первых ничтоже
сумняшеся определяем специальные слова для доступа к определённому стеку, а во-вторых
шаги 3 и 4 создают интерпретатор простенького языка, код на котором скармливается на
пятом шаге.


Так, к чему я это всё. Лично мне нравятся нормальные языки, типа С#, и, хотя от
возможности править синтаксис я бы не отказался, в Парадигму Форта не очень
верю. Написать же интерпретатор шарпа непосредственно на форте – это довольно таки
адская работа: нужно обучить его распознавать регулярные выражения и переписать
лексический генератор (базовый разделяет лексеммы по пробелам), написать распознавалку
БНФ и построить по ней какой-нибудь LALR парсер, написать, собственно, оптимизирующий
кодогенератор, а затем придумать способы удобно вклиниваться в распознавалку БНФ и
кодогенератор.
Причём делать это совершенно некому, поскольку фортопрограммеры в большинстве своём не
любят контекстно-свободные грамматики, зато любят писать нитроглицериновый код (типа
приведённого, одна ошибка – и привет).
Однако делать это и не нужно, поскольку если не принимать Парадигму, то можно обойтись
гораздо меньшей кровью: взять компилятор шарпа и сделать только последний шаг –
программируемый парсер. Я надеюсь, что кто-нибудь это сделает, причём скоро.

Тем не менее сама идея – красива безумно, на мой вкус. Оно какое-то замкнутое на себя и
почти живое получается.
Это одна из вещей, про которые хочется сказать, что люди их не придумали, а открыли -
типа как простые числа.

В реальной жизни Форт используется в микроконтроллерах (потому что маленький но мощный
как песдец, ведь фактически в ядре уже есть шелл, помимо всего прочего) и для
построения простеньких интерпретаторов, в которых отсутствие КС-разбора не очень
мешает. Может, ещё для чего, не знаю.

Я знаю слова Лисп, Хаскелл и Схема. Насколько их коннотаты похожи на Форт - не знаю.

Форт я тоже не знаю, кстати. Так, прочитал одну книжку, но зато несколько раз.

Причём тут когнитивная психология? Ну как, там Активные Символы, тут Слова, влияющие на
компиляцию дальнейшего текста, фактически придающие этому тексту смысл. Можно
использовать Форт в качестве источника вдохновения.
