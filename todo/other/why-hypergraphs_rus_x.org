[Оригинал (на английском), за авторством Линаса Вепстаса:] (http://blog.opencog.org/2013/03/24/why-hypergraphs/)


* Почему гиперграфы

  OpenCog использует =гиперграфы= для представления информации. Почему?  Я не думаю что кто-то ясно и лаконично объяснил
  это где-то в другом месте, так что я попытаюсь сделать это здесь.

  Это очень важный момент: я не могу передать вам, как много раз я отправлялся на поиски какой-нибудь крутой системы логического программирования или логического вывода или автоматического    доказательства теорем или =движка переписывания графов= или =системы вероятностного программирования= и потом опускал руки и понимал, что
  после множества потерянных часов ничего из этого не делает то, что я хочу. Если вы заинтересованы в AGI, позвольте мне заверить вас: того, что вы хотите, оно тоже не делает.
  Что я, собственно, хочу, чтобы они делали, и почему?

Ладно, начнём с простого -- систем переписывания графов. В наши дни почти все согласны, что перкрасный способ представлять знания -- использовать графы. Структура IsA(Cat, Animal) выглядит как граф с двумя вершинами, Cat и Animal, и подписанным ребром, IsA, между ними. Если помимо этого известно, что IsA(Binky, Cat), то я, в принципе, должен мочь вывести, что IsA(Binky, Animal). Это простое транзитивное отношение, и логическая дедукция в данном примере -- простое правило переписывания графа: если видишь подряд два IsA между первой и последней вершинами нарисуй третье IsA ребро. Просто, да?
И вот вы могли вообразить, что все движки логической индукции и рассуждений в ядрах своих содержат системы переписывания графов, правда? Так вы могли бы подумать. На самом деле, практически нет. А те, что всё же содержат, делают это каким-нибудь внутренним, придуманным на месте, не публичным, недокументированным образом; API нет, наружу оно не выставлено; это не "официальная" часть системы, с которой вы могли бы повозиться.

Ладно, так зачем мне системы переписывания графов? Ну, я работал над парсером естественных языков, так называемым декодером Витерби для Link Grammar. Мой изначальный граф -- цепочка слов, т.е. предложение. Слова -- вершины, а рёбра -- стрелочки, которые называются "следующее слово". Правда просто. Для парсинга предложения я хочу применить определённый набор простых правил переписывания графа: к примеру, если слово X существительное, создать стрелочку "часть речи" (POS) от слова X к особой вершине "существительное". Если слово непосредственно перед X -- прилагательное, (в смысле, у него есть стрелочка типа POS, указывающая на "прилагательное"), создать новую стрелочку, называющуюся "модификатор существительного", указывающую из X на это слово перед ним. Такая разметка графа называется "парсинг зависимостей", и является очень распространённым способом парсинга естественных языков. Так что вы могли бы подумать, что все парсеры зависимостей в ядрах своих содержат систему преписывания графов, да? Едва ли. На самом деле, рпактически ни один. А если и да, то они огорожены, являются сборищами хаков, недокументированы... Ну вы поняли.

Единственный известный мне парсер зависимостей, явным образом работающий на системе переписывания графов, открытой для эспериментов и документированной(!), -- это RelEx. Ух ты! Хотя RelEx изобрёл и использует свою собственную
 кастомную систему переписывания графов, полагаю, что в принципе он мог использовать какую-нибудь другую, уже существующую систему для этих целей ( Ну, вообще не мог, потому что в 2005 никаких устойчивых системы переписывания графов с открытым кодом не было. Ну да ладно.)

Чего ещё я хочу сделать? Ну, я мечтаю об использовании системы машинного обучения для разучивания новых правил! В смысле, цель AGI же в этом, правильно? Иметь машину, могущую изучать новые штуки? Так, чтобы изучать новые правила, посмотрим-ка, нужен простой синтаксис для представления правил. В общем-то, просто графовый язык. И вот вы могли бы подумать, что все системы переписывания графов имеют какой-нибудь простой для понимания и использования графовый язык, да? Ан нет. Подчёркиваю -- чёрта с два. За одним возможным исключением, приходится писать на Джаве или C++ или C#. К сожалению, моя система машинного обучения поа не умеет программировать на этих языках.

Вот прыжок на доверие, на логику, к которому я пришёл: было бы удобно, моги я выразить сами правила переписывания графов как графы. Было бы удобно, если бы я мог выразить логические следствия как графы. Было бы удобно, если бы сам мой графический язык программирования мог быть записан как граф. Вообще, он может. На самом деле, проще всего это сделать, если граф -- гиперграф. В следующем разделе я напишу, почему. Если бы у меня была система переписывания гиперграфов, у меня было бы место, где я мог бы  объединить обработку естественных языков, логические рассуждения и машинное обучение, все в одном.
И вот вы могли бы подумать, что каждый, старающийся построить систему AGI, писал бы её на основе системы переписывания графов, правильно? Но вы бы ошиблись. Похоже, OpenCog -- единственная система, которая так поступает.
Да, в реализации OpenCog'а куча косяков разработки и архитектурных недостатков. Её трудно понять и трудно использовать. Но теперь, быть может, вы понимаете, почему я присягнул ему на верность вместо того, чтобы убежаь с какой-нибудь ещё системой рассуждений или парсером или байесовой сетью или чем бы то ни было.

Математические основания

В этом разделе я попытаюсь укрепить все вышеизложенные замечания на прочном математическом основании, воззвав к теории моделей, теории категорий (и даже n-категорий!) и теории типов. Благом от этого будет то, что простейшим способом представить структуры данных так, чтобы алгоритмы машинного обучения могли их выучить и затем применить их к парсингу естественных языков и логическим рассуждениям, является представление структур данных гиперграфами.

В теории моделей и информатике есть идея сигнатуры: множества функций, принимающих некоторое количество аргуметов и возвращающих некоторое значение (совсем как сигнатура в Джаве или C++). Если на минуточку перестать обращать внимание на типы (как это делают lisp и scheme), то, в приницпе, можно подавать любое значение в люой позиции в люой функции, и класть их на стек произвольно, даже рекурсивно. Это называется алгебра термов, или свободная алгебра термов, или "свободная теория". Если функции не имеют имён (являются анонимными), получаем лямбда исчисление.

Один из способ представить эелмент алгебры термов -- в виде графа, а именно направленного дерева. Таким образом, если у нас есть две функции, f(x,y) и g(x,y), и три постоянных a,b,c, то  f(a, g(b,c)) -- двоичное дерево, с f в верхнем узле, g в левом узле и листьями a, b,c. Алгбера терминов тоогда есть просто собрание всех таких деревьев. Ни больше, ни меньше.

Чтобы заниматься полезным программированием, также нужны предикаты или отношения -- штуки со значениями истинности, и термы упорядченности. Так, "больше чем" -- отношение, и "a>b" либо истинно, либо ложно. Отношениями также бывают штуки вроде Является, Имеет, Принадлежит, ЖивётВ, РаботаетВ. Последние два примера должны прояснить, что реляционные алгебры составляют основу баз данных, SQL и noSQL. Отношения совмещаются с логическими операциями (employee X LivesIn city Y AND ReportsTo dept Z  -- классический пример).

Вообще, алгебры термов и реляционные алгебры совмещают, так что можно писать что-нибудь вроде
 3<f(x,y) где f(x,y) терм, < отношение, а 3 постоянная. Добавьте сюда особые операторы, связывающие свободные переменные, Для Всех и СуществуетТакой, и получите логику первого порядка. Так, к примеру, ДляВсех x СуществуетТакой y что  3<f(x,y).

Особым случаем отношение является правило переписывания графа. Это отношение, принимающее терм и замещающее его другим термом. К примеру,  ab->c, что означает ‘встретив строку ab, замени её на c’. BNF нотация в компьютерных языках -- просто набор отношений переписывания термов. Систему переписывания термов используют для парсинга (формального ) языка. Переписывания графов -- просто разновидность этого: встретив граф x, замени его графом y.

До сих пор я избегал вопроса типов. В программировании типы позволяют ввести безопасность типов. Типы делают код более читаемым: f(string, int) менее загадочно, чем f(x,y). Типы решат некоторые абстрактные проблемы рекурсии в лямбда исчислении. Правило переписывания в BNF нотации является типизированным: замена a->bc выполняется не для любого a, а только если a веб-страница, или IP адрес или URL. Правило переписывания графов, говорящее " увидев x, замени его на y", неявным образом требует типизирования x: x не может быть чем угодно, он должен быть конкретным видом графа, с особой формой и связями. Правило применяется ко всем графам такой формы, такого рода или типа. Таким образом правило переписывания x->y на самом деле (тип x)->(тип y). Графически это всё ещё две точки x и y, с направленным ребром между ними. А, подождите-ка, x и y же не точки, это графы. У какого графа вместо точек графы? У какого графа между графами рёбра? У гиперграфа!

И вот это основной момент "Ага!" Когда это увидишь, гиперграфы начинаешь видеть везде. Конечно, можно представлять множество (a,b,c) как дерево, в котором Множество -- корень, и три потомка -- a,b,c. Или можно представлять его как гиперграф: Множество как "связь" (гиперребро с 3 вершинами вместо 2), а точки a,b,c как узлы, содержащиеся в связи. На самом деле, все гипеграфы двойственны направленным деревьям; имея одно, можно получить другое. Гиперграфы -- просто удобная форма записи.

Давайте на минуточку оглянемся на произошедшее: функция f(x,y,z) -- просто гиперребро f, соединяющее три узла x,y,z.
 Булево выражение a AND b AND c можно переписать как AND(a,b,c), что является конкретным примером эквивалентности гиперграфов. Можно записать это как правило редукции: (a AND b AND c) -> AND(a,b,c), что само по себе является гиперграфом формы x->y, где x и y гиперграфы. Конструкты логики первого порядка "для всех" и "существует" -- просто особые случаи свзяующей операции лямбда из лямбда исчисления, которые связывают свободную переменную в выражении. Опять гиперграфы: лямбда тут просто гиперсвязь, связывающая переменную x в выражении y, а y просто кхе-кхе, гиперграф термов.

Выше я упомянул категории и n-категории, и полагаю, что должен оправдать это упоминание. В той мере, в которой теория категорий является теорией точек и стрелочек, правило переписывания между графами является морфизмом в категории малых диаграмм. Тонкий, но важный момент в теории категорий, который практически никогда не обсуждается в учебниках по ней, в том, что все объекты неявно типизированы. В категории множеств все объекты одного типа -- множества. Это не упоминается, поскольку когда категория задана, все объекты в ней одного типа; типы меняются, только когда функторы отображают один на другой. Таим образом для понимания категорико-теоретического эквивалента типов в информатике надо думать о функторах. Но как мы только что видели, правило переписывания графов -- просто морфизм функторов. Так что можно сказать, что переписывание графов есть просто категория Кат малых категорий. Или можно пойти в другую сторону и называть это всё 2-категориями. Как угодно.
Возможно, полезно будет заметить, что алгоритмы переписывания графов иногда выражают в форме кодекартовых квадратов (one-pushouts or 2-pushouts); это такое специальное понятие в теории категорий. Важно для переписывания графов то, что любая категория с кодекартовыми квадратами и уравнителями имеет все (ко)пределы. Только вот, как мы только что увидели, нам нужны переписывания гиперграфов, а не просто графов. Вот.

Для чего ещё они хороши?

В OpenCog'е типы Link и Node наследуют от типа Atom. Такое соглашение о названиях намеренно располагает: "Atom" должно вызывать в уме понятие атомарнй формулы из теории моделей или логики первого порядка; это формула, в которой нет переменных и у которой есть значение истинности (в ней нет булевых операций или кванторов). Это распологающе наименование помогает укрепить задуманное использование OpenCog'овских гиперграфов по отношению к логике первогог порядка.

Значение истинности -- другое дело. В OpenCog по умолчанию используется значение истинности, являющееся парой чисел с плавающей точкой: вероятность и доверительный интервал. Эти числа позволяют отобразить некоторые другие понятия ИИ на гиперграфы: байесовы сети, сети Маркова и искусственные нейронные сети. Всё это графы, притом направленные. Они отличаются тем, как приписывают и распространяют вероятности, энтропии и активации, выраженные числами с плавающей запятой. Идеи вроде логических сетей Маркова, которые воплощают принципы наибольшей энтропии (они же принцип Больцмана) на сети выражений логики первого порядка, можно представить гиперграфами OpenCog'а. Ах, ещё надо упомянуть PLN (Сеть Вероятностной Логики), для которой atomspace разрабатывался изначально. Что мне нравится в гиперграфомо atomspace'е OpenCog'а: у него есть невероятно мощная способность лаконично и просто выражать сложные понятия современного ИИ.

Хорошие, плохие и убогие.

Про хороших вы слышали. Теперь про плохих и убогих. Во-первых, реализация OpenCog atomspace'а медленная и неэффективная, излишне сложная, плохо архитектурно сработанная, слабо распределённая, немасштабируемая и однопоточная. Но давайте в это не полезем. Всё это можно поправить с помощью больших программистских усилий (и глубинного архитектурного мышления). Это уже горячо обсуждалось в прошлом. Когда-нибудь это может быть поправлено.

Плохо в OpenCog atomspace'е то, что почти никто не понимает, что, кхе-кхе, это язык программирования. Давайте я очень чётко скажу: OpenCog воплощает правила переписывания графов с помощью ImplicationLink (связи "Следствие"). Последовательность таких связей можно использовать для вычислений. В этом смысле он немного схож с языком Graph Programs, с той лишь разницей, что OpenCog допускает дробные значения истинности, логическое программирования и прочее добро. Если придерживаться использования только связей "Следствие" с целочисленными значениями истинности ("Истина"/ "Ложь"), получим систему, которая фактически будет Прологом. Вы, конечно, знаете, что Пролог весьма распространён в среде ИИ проектов, поскольку на нём весьма просто писать движки рассуждений и экспертные системы и тому подобное. Но вы можете не знать, что близкое отношение к Прологу имеет
Answer-Set Programming (ASP, Программирование Множеств Ответов). На самом деле ASP использует точно ту же нотацию, что и Пролог. Разница в двух важных аспектах: во-первых, при запуске программы на Прологе получают один ответ, а на ASP все! Он впечатляющее более мощный, а причина в том, что современные решатели ASP построены поверх современных вычислителей булевой удовлетворимости. Что означает, что они поразительно эффективны.

Так и какое отношение это имеет к OpenCog'у? Ну, тут у нас есть система, которая, при использовании связей "Следствие", фактически является  более-менее Прологом, если использовать режим строгой логики. Или можно сказать, что это как типизированное лямбда исчисление. Но есть ли у нас простой для понимания и использования Прологообразный синтаксис для этого всего? Нет. И это плохо. Можно ли взять имеющуюся программу на Прологе, обработать её каким-нибудь инструментом, и преобразовать её в связи "Следствие"? Нельзя. Заработает ли она быстрее? Ни в коем случае; она, скорее всего, будет медленне самого мдленного Пролога в истории -- Борланд Пролога, работающего ка 5 МГц IPM PC в 1986 году. А про решаетль ASP для OpenCog'а можете вообще забыть . Для особых случаев, когда все значения истинности -- строгие "Истина" или "Ложь", у нас нет вычислителя булевой удовлетворимости, который находил бы решения для наших графов связей "Следствие". И это плохо. Реально Плохо. Но я думаю, что это потому, что очень немногие понимают, что OpenCog Atomspace -- на самом деле чашка Петри для языков программирования.


Ёлки, у нас нет даже чего-нибудь равносильного алгоритму разбора предложений RelEx'а для OpenCog'а, даже с учётом того, что RelEx на OpenCog похож. Это отсустствие тормозит мои попытки продолжить работу над парсером Link-Grammar и приведению обработки естественных языков из её нынешнего обособленного положения в состояние универсального гибкого фреймворка.

( И мы тут едва начали. Чтобы вывод следствий и pattern mining в atomspace'е происходил быстро, нужно реализовать что-то вроде "мемоизации" из lisp/scheme. Но оказывается, что мемоизация -- это просто реляционная алгебра, база данных кратких выражений, заменяющих длинные. OpenCog Atomspace также, помимо прочего, является реляционной базой данных, которая способная хранить и обрабатывать запросы не только к плоским таблицам или парам "ключ-значение", но и к полноценным гиперграфам. И это не мечтания, это критично для производительности (и отасти реализовано))

Почему у нас всего этого нет? Ну, это сложно. Это просто нелегко. У нас нет инфрастурктуры, чтобы сделать это лёгким, и нет пользователей, требующих эти инструменты. Не думаю, что большинство пользователей осознаёт, что может сделать atomspace. Практически никто не думает о том, "как программировать на языке OpenCog", даже несмотря а то, что он обладает потенциалом, далеко превосходящим таковой любого из существующих языков вероятностного программирования. Пора всё это поменять, но для этого потребуется кто-нибудь умный и увлечённый. Много таких кого-нибудь. Это можете быть вы.
