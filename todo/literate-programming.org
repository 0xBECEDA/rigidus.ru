#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Литературное программирование

* Эпиграф

Слова ниже взяты из интервью Дональда Кнута, которое Эндрю Бинсток взял у него в
апреле 2008. Я позволю себе большую цитату:

#+BEGIN_NOTE
Лично для меня literate programming - это наиболее важная вещь, вышедшая из проекта
TeX. Этот подход не только позволил мне писать и поддерживать программы быстрее и
надежнее, чем когда бы то ни было раньше, и он не только был для меня самым большим
источником удовольствия, начиная с 1980-х гг. - он иногда оказывался
незаменимым.

Некоторые из моих основных программ, такие как метасимулятор MMIX, не
могли бы быть написаны с применением любой другой методологии, о которой я когда-либо
слышал. Сложность была просто чересчур устрашающей, чтобы с ней можно было справиться
на основе моих ограниченных умственных возможностей; без применения literate
programming все предприятие потерпело бы полную неудачу. Literate programming - это то,
что требуется для превышения обычного уровня достижений. Но я не считаю разумным
навязывание идей кому бы то ни было. Если грамотное программирование - это не ваш
стиль, забудьте о нем и делайте то, что вам нравится. Если этот подход не будет
нравиться никому, кроме меня, пусть он умрет.

Мой опыт показывает, что программное обеспечение, созданное на основе грамотного
программирования, оказывается существенно лучше, чем разработанное с применением более
традиционных методов. Тем не менее, обычное программное обеспечение, как правило,
оказывается неплохого качества – я поставил бы ему оценку C (или, может быть, C++), но
не F; следовательно, традиционные методы остаются с нами. Поскольку эти методы усвоены
огромным сообществом программистов, у большинства людей нет большого стимула к их
изменению, равно как у меня нет мотивации для изучения эсперанто, хотя этот язык мог бы
быть предпочтительнее английского, немецкого, французского или русского языков (если бы
все на него перешли).
#+END_NOTE

Он продолжает пользоваться этим подходом и сегодня: "...Что касается текущих каталогов в моей
машине, в этом году я пока написал 68 разных CWEB-программ. В 2007-м году их было 100,
в 2006-м - 90, в 2005-м - 100, в 2004-м - 90 и т.д."

* Суть подхода

...раскрывается в его статье "Literate Programming", написанной в 1983 г:

#+BEGIN_NOTE
Давайте изменим наше традиционное отношение к построению программ: вместо
представления, что нашей главной задачей является объяснение компьютеру что делать,
давайте сосредоточимся на объяснении человеку что мы хотим чтобы сделал компьютер.

Я не в силах противостоять желанию поработать над задачами по программированию, которые
я обычно поручаю помощниками студенческих исследований; и почему? Потому что мне
кажется, что наконец я могу писать программы так, как они и должны быть написаны. Мои
программы не только объяснены лучше чем когда-либо прежде; они лучше как программы,
потому что новая методология заставляет меня делать свою работу лучше.
#+END_NOTE

Суть литературного программирования состоит в том, что программа описывается отдельными
кусочками, следующими в произвольном порядке. Т.е. пишется как бы текст лекции, статьи,
объяснения или эссе, в который вставлены абзацы-куски кода.  Это намеренно сделано так,
что читается подряд, как связный текст и предназначено в первую очередь для
человеческих глаз.

Затем два инструмента принимают на вход "литературный" исходник на "литературном
программистском языке" и выдают - один чистый код, второй - красиво отформатированную
статью-документацию.

[[img:literate2way.jpg]]

Кнут выдумал это очень давно, и его оригинальные инструменты работают на основе его же
собственного TeX'а (т.е. программист пишет свой исходник-эссе пользуясь TeXовой
разметкой), но сегодня есть варианты для, например, "вики-синтаксиса".

Главная идея Кнута в том, что такой стиль СИЛЬНО ПОМОГАЕТ делать ПРОЕКТЫ БОЛЬШОГО
РАЗМЕРА.

Это - огромная проблема. Человеческий мозг начинает уставать после первых 1000-1300
строчек, приходится сосредоточиваться значительно сильнее чтобы все помнить и не сажать
ошибок, и далее приходится вводить особые способы деления на куски, выдумывания новых
абстракций более высокого уровня чтобы затем писать на "новом языке" и т.д.

TeX, одна из самых сложных программ в мире, не имеет багов и работает на любом
компьютере, включая древние 286-е и КПК. Это чудо человеческого гения.

Кнут предложил довести требование читаемости кода до предела и превратить написание
программы в написание книги об этой программе. При этом код и документация не
разделяются, они описывают решение проблемы формально и неформально. Естественно, что
логика изложения может отличаться от последовательности команд. Кроме того, текст
должен быть представлен в удобном для читателя виде. Поэтому нужны специальные
инструменты, которые позволяют смешивать разметку текста и код.

Кнут, вполне естественно, предложил для текста TeX. Кроме того, в тот момент он
использовал язык программирования Pascal, строгость которого усугубляется требованием
однопроходной компиляции. Из-за этого порядок определения функций, типов и переменных
строго фиксирован, что противоречит требованию понятности изложения. Так что Дональду
Кнуту пришлось написать свою систему WEB, которая устроена примерно так. Программа
состоит из кусочков (chunks)документации, чередующихся с кусочками кода. В кусочках
кода можно ссылаться на другие кусочки, причем ссылки могут идти и вперед, и назад, а
на один кусочек может быть несколько ссылок. Получается своего рода сеть, отсюда и
название, которое потом использовали для похожей структуры документов в интернет.

Чтобы такую программу можно было использовать, есть две утилиты - tangle, которая
вытаскивает кусочки кода, подставляет их на место ссылок и формирует программу, которую
можно скомпилировать, и weave , которая форматирует кусочки кода командами TeX и
создает документ TeX, который можно распечатать.

TeX и написан таким образом, а человеко-читаемая версия вышла в виде книги "TeX: The
program".

* Современное состояние

Интерес к этой идее, и развитие инструментальных средств и самой идеи постепенно
угасали с популяризацией и персонализацией компьютеров. Этот очевидный факт можно
пояснить, не выходя за рамки принятой модели — повышение доступности компьютеров
означает и глобальное смещение приоритетов в алгоритмической основе ПО.

Естественно, алгоритмически сложное ПО никуда не исчезает, но на общем фоне его роль
уже далеко не столь важна, как в период создания Д. Кнутом идей Литературного
Программирования.

Сегодня правят бал пользовательские интерфейсы, а сложная алгоритмика в панике
упрятывается в повторно используемые компоненты — в панике из-за того, что массовый
рынок требует слишком много программ "сразу и сейчас", а для разработки такого
количества ПО просто невозможно найти необходимое количество программистов класса
Д. Кнута.

И все-таки области, где применение идей ЛП не теряет своей актуальности, никуда
не исчезают — управляющие программы для встраиваемых систем, высоконадежные
программные комплексы класса "mission critical", критическое системное
ПО и, наконец, — столь модное сегодня "открытое ПО". О последнем
стоит сказать особо — именно идеи "открытого ПО" (распространяемого
на уровне исходных текстов), казалось бы, идеально согласуются с целью ЛП. Ведь
доступность исходных текстов — не самоцель различных сообществ и не прихоть
авторов той или иной лицензии, напротив, это критический фактор жизнеспособности
программ. Казалось бы, что именно здесь идее ЛП суждено было обосноваться прочно
и надолго, и "открытое ПО" необходимо создавать именно на основе принципа
"объясняй человеку, как должен действовать компьютер".

** Детализация

Цель ЛП прозрачна и даже благородна. Ее можно сформулировать и другими словами,
а именно: "главное в работоспособной программе — не управляющие инструкции
компьютеру, а знания разработчика программы, выраженные в максимально удобной
для понимания сторонним человеком форме". В реальности большинство программистов…
сталкивались с образчиками ЛП при изучении посвященных алгоритмическим основам
своей профессии книг, авторы которых практически всегда прибегают к приему описания
реализаций программ на псевдокоде — гибриде языка программирования и естественного
языка. Впрочем, крохотный пример может показаться не лишним, а заодно и дать
первое ощущение "привкуса" ЛП:

Стиль C и C++:

#+BEGIN_SRC c++
for ( ic=0, ic<MaxCusts, ic++ )
  if ( Cust[ic].age > 18 ) itc_drupal_
...
#+END_SRC

Стиль ЛП

#+BEGIN_SRC lp
  @<Для каждого из зарегистрированных потребителей, достигшего совершеннолетия>@
#+END_SRC

Давайте сразу обратим внимание на пары символов ~@<~ и ~>@~. Они своей симметрией
наводят на аналогию с символами-ограничителями тегов в языках разметки, например
HTML. И, как ни странно, во второй раз аналогия не подвела — все воплощения идеи ЛП
являются специализированными языками разметки, поддержанными инструментально.

Естественно, у читателя должен возникнуть вопрос - "Ну и что это дает?".
Действительно, зачем вводить еще один язык, если можно (и нужно) просто комментировать
текст программы? Чтобы ответить на подобные вопросы, достаточно узнать самое главное о
соотношении синтаксиса и семантики языков ЛП.

Синтаксически языки ЛП крайне просты и представляют собой небольшой перечень правил
записи объединения высокоуровневых фрагментов псевдокода, допускающего описание
программы на естественном языке, и фрагментов-"реализаций" этого псевдокода, в которых
последний "реализуется" на некотором языке программирования. Принципиальное свойство
языка ЛП — произвольный (выбираемый программистом) порядок следования в ЛП-программе
фрагментов-"реализаций".

Семантика языка ЛП, несмотря на простоту синтаксиса, куда более сложна. Фактически язык
ЛП формирует принципиально новую парадигму программирования, не зависящую (или
минимально зависящую) от языка реализации программы. К особенностям этой "ЛП-парадигмы"
разные исследователи и программисты-практики относят "плавность" перехода от описания
проблемы (постановки задачи) к реализации (программе), полноценную поддержку разных
методик анализа и разработки (например, гибридной: нисходящий анализ и восходящая
реализация), эффективное воплощение принципа "разделяй и властвуй" и т. д. Сторонники
наиболее радикальной точки зрения на ЛП считают, что такие особенности позволяют
говорить о ЛП-языках как о принципиально новых языках программирования, поддерживающих
стиль программирования, при котором "дисциплинированно делается именно то, что нужно
делать".

Ну а теперь можно и ответить на поставленный вопрос. Вспомним принципиальную
синтаксическую особенность языков ЛП — произвольность порядка и отсутствие упоминаний о
каких-либо ограничениях на содержание фрагментов-"реализаций".  Казалось бы,
незначительный нюанс, но в ЛП, как и в жизни, все строится на них.  Вследствие таких
особенностей об уровне применимости ЛП-подхода можно и не говорить — он "работает" от
самого высокого уровня (проектирования) до самого низкого, превращая и кодирование в
процесс высокоуровневой разработки.

** Пора объяснений

Во всех материалах, посвященных ЛП, очень трудно отделить концептуальную часть
от реалий применений. Впрочем, этим грешат все описания методологий, концепций
и парадигм программирования — чтобы по-настоящему "почувствовать вкус",
требуется реальный пример, а не потешная программка класса "Hello, world",
ведь материал адресуется тем, для кого "потешный" уровень программирования
— давно пройденный этап. Журнальная статья тем более не позволяет приводить
"реальные примеры". Мы ограничимся только обсуждением нюансов.

Псевдокод ЛП-программ фактически представляет собой описание структуры будущего
программного "шедевра". Абсолютно неформальное, допускающее включение
математических формул, иллюстраций, чего угодно — вплоть до мультимедийных
"вставок", такое описание-документация "по ходу дела" дополняется
новыми фрагментами псевдокода и фрагментами-"реализациями". При этом
ЛП-программист не должен следить за сложной в больших программах "адресацией"
— соответствием команд псевдокода и фрагментов-"реализаций", так
как сами фразы на псевдокоде являются "адресом". То есть, если где-то
в ЛП-программе встретилась фраза псевдокода "@< Вывод сообщения на печать
>@", впоследствии программист может "овеществить" ее следующим
фрагментом-"реализацией":
@< Вывод сообщения об ошибке на печать >@=
prints("Error!n);

Располагаться это "овеществление" может в тексте ЛП-программы где угодно, и если
впоследствии реализующий псевдокод фрагмент кода по каким-то причинам надо изменить,
достаточно произвести такое изменение только в фрагменте-"реализации".

Задача инструментов, поддерживающих ЛП-программирование, — преобразование программы на
ЛП-языке в текст, пригодный к трансляции в исполняемый код, и одновременное
формирование качественной документации в том или ином представлении. Задача не слишком
сложна, но и здесь есть свои нюансы — произвольное расположение фрагментов-"реализаций"
в тексте ЛП-программы приводит к необходимости "хитрого" механизма нумерации строк
кода.

** Развитие

Как и всякая методология, ЛП обладает массой специфических недостатков. Их можно
характеризовать "часто высказываемыми возмущениями" (ЧВВ) в тематических сетевых
конференциях: реализации слишком сложны, реализации недостаточно функциональны, с
имеющимися реализациями трудно отлаживать программы и организовать коллективную
разработку, реализации не поддерживают используемый нами язык программирования. К
счастью, в подавляющем большинстве случаев речь идет о существующих реализациях
инструментария ЛП, а не о самой идее ЛП — последняя, напротив, даже при очевидном
несовершенстве инструментов демонстрирует убедительные достоинства.

Казалось бы, что все предпосылки для развития ЛП-инструментария есть: во-первых,
ЛП-методология работает, что доказано ее успешным применением не в одном реальном
проекте, во-вторых, рост популярности открытого ПО остро ставит проблему качества
документации, в-третьих, инструментарий ЛП весьма прост. И все же, никаких существенных
событий с момента создания Д. Кнутом первой реализации ЛП-системы под названием WEB в
мире "грамотного программирования" не произошло. Авторы новых инструментальных средств
или увеличивают сложность ЛП-языка до невообразимых пределов, отпугивая тем самым
многих программистов, прекрасно знающих, что значит изучение "еще одного языка", или
сокращают функциональность до весьма сомнительного уровня.

Поразительно и то, что во всем изобилии материалов, посвященных ЛП (а их действительно
много), до сих пор не была усмотрена напрашивающаяся аналогия между сочетанием
"фрагмент псевдоязыка — фрагмент-"реализация" и… структурами,
используемыми для описания знаний, в первую очередь, с фреймами. Уже упоминавшийся
ранее в весьма странном контексте термин "адрес" в данном случае получает
ясное толкование: объекты ЛП-программы — фрагменты псевдоязыка — могут адресовать
другие объекты и при этом включать дополнительные описания фрагментов реальных
программ. Идеально соответствующая фреймовому представлению знаний картина, позволяющая
говорить об ЛП-программе как о высокоуровневой базе знаний. Качество содержимого
этой базы, естественно, определяется качеством работы создателей программы, и
в этом плане ЛП как методология не способна привести ни к каким принципиальным
улучшениям (опять же, как и любая методология вообще). А вот сама фреймовая модель
открывает весьма неожиданные и привлекательные перспективы, связанные, в первую
очередь, с коллективной разработкой программ и повторным использованием кода.
Существующие отработанные реализации распределенных фреймовых баз знаний (например,
система FramerD), по идее,
позволяют создавать громадные репозитории ЛП-программ, находить подходящие для
повторного использования фрагменты ЛП-кода, организовывать управление и совместную
работу тысяч программистов над одним проектом.

Не менее поразителен и факт крайне слабого развития интерактивных инструментальных
средств, поддерживающих ЛП. Наибольшие достижения в этой области наблюдались лет 10
назад, на платформе Macintosh, да и то пик их популярности, похоже, прошел.

Развития функциональности ЛП, скорее всего, не было вообще — после Д. Кнута то ли никто
не осмелился что-либо улучшить в идеях мастера, то ли эти идеи не столь сильно овладели
умами… Хотя целый ряд усовершенствований напрашивается сам собой — сочетание ЛП-систем
и систем статической проверки программ, генерация высокоуровневых спецификаций на
основе ЛП-кода, построение гибридных систем класса "ЛП — формальный язык описания,
пригодный к верификации".

** Будущее?

Вопрос "Есть ли будущее у ЛП?" сегодня уже весьма актуален. Даже в хорошо подходящих
для нее областях применения эта методология не нашла массового распространения — в
первую очередь, из-за несовершенства технологических средств. У ЛП есть фанатичные
приверженцы, но, судя по крайне малому количеству реально созданных на основе ЛП
программ, приверженность — не главный решающий фактор в развитии. Как, впрочем, и
фанатизм.


* Примеры использования подхода

http://zahardzhan.github.io/2010/emacs-starter-kit-the-program.html

http://zahardzhan.github.io/well-tuned-emacs/
