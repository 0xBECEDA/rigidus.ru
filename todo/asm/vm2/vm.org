#+STARTUP: showall indent hidestars
#+TITLE: Виртуальная машина аркадных игр

* Введение

Многие программисты используют написание аркадных игр для того чтобы
попрактиковаться в незнакомом языке программирования, методологии или
парадигме. Обучающие статьи такого рода помогают познакомить
сообщество с новыми идеями, такими как, например, реактивное
программирование: https://habrahabr.ru/company/infopulse/blog/338910/

Мне нравятся необычные подходы в программировании, такие, например,
как создание языков предметной области (Domain Specific Language,
DSL). Некоторые мощные языки, такие как Lisp и Forth пропагандируют
такой подход, но так как их популярность невелика, большинство
программистов не знают о том, что так тоже можно.

Поэтому я решил написать эту статью.

Кроме того, мне хотелось бы исследовать, смогут ли методы
искусственного интеллекта определять выигрышные игровые стратегии
опираясь на исходный код игры. Исходный код игр, как правило, слишком
перегружен нюансами и трудоемок для анализа. Код языка предметной
области может подходить для этой задачи лучше.

Мы будем создавать ассемблер и виртуальную машину (VM) для
классических аркадных игр. Это всем известные игры, такие как
"змейка", "диггер" или даже "сапер".

Итак приступим.

* Система команд виртуального процессора
** Ввод

Основная характерная часть аркадных игр - это специфическая система
управления, берущая начало от управляющих панелей аркадных
автоматов.

https://geektimes.ru/post/249984/

Эти управляющие панели представляют собой:
- джойстик и кнопки управления персонажем (для каждого игрока)
- несколько общих для обоих игроков кнопок, таких как, "start game".
Монетоприемник (для простоты) тоже можно считать такой кнопкой или
набором кнопок, если он принимает монеты разного номинала.

Игрок управляет только своим объектом (персонажем) в двухмерном
пространстве в границах экрана.

Поэтому мы сразу можем определить команду, которую будем использовать
для получения состояния элементов управления. Она должна возвращать
нам строку битов, которая определяет положение джойстика и какие
клавиши в данный момент зажаты.

Назовем это команду =getkbd=. Она не имеет операндов и возвращает
([TODO:gmm] - куда возвращает ?) битовую строку состояния
клавиатуры. [TODO:gmm] - Расписать значения каждого бита.

** Вывод

В классических аркадах игра происходит на одном экране, который виден
целиком, главный герой и враги представлены спрайтами -
картинками. Соответственно весь вывод на экран заключается в
копировании спрайта из памяти в видеопамять. Определим для этого
команду =show. У этой команды должны быть операнды:
- координаты начальной точки вывода =x= и =y=
- ширина и высота спрайта =w= и =h=
- указатель на буфер, где лежит спрайт =buffer=

Координаты начальной точки вывода могут быть отрицательными - это
стоит сделать для того, чтобы была возможность плавного появления
спрайта из-за границы экрана.

Если в процессе вывода спрайта часть точек рисуется за границами
экрана - виртуальная машина просто игнорирует это.

Для простоты мы сделаем так, что видеопамять не будет доступна на
чтение, получить спрайт с экрана нельзя. Все коллизии объектов игра
должна уметь считать, опираясь на структуры этих объектов, а не на
нарисованные точки на экране.

** Арифметика
*** Целочисленная

Чтобы складывать и вычитать координаты нам нужны команды =add= и =sub=

** Логические

Нам нужны команды операции с битами: =and=, =or=, =test=, =xor=.

** Команды передачи управления
*** Вызова процедур и возврата из них

=call= и =ret=

*** Условных переходов

| Типы операндов | Мнемокод | Критерий               | Значения флагов    |
|----------------+----------+------------------------+--------------------|
| Любые          | je       | операнд_1 =  операнд_2 | zf = 1             |
| Любые          | jne      | операнд_1 <> операнд_2 | zf = 0             |
| Со знаком      | jl/jnge  | операнд_1 <  операнд_2 | sf <> of           |
| Со знаком      | jle/jng  | операнд_1 <= операнд_2 | sf <> of OR zf = 1 |
| Со знаком      | jg/jnle  | операнд_1 >  операнд_2 | sf = of AND zf = 0 |
| Со знаком      | jge/jnl  | операнд_1 => операнд_2 | sf = of            |
| Без знака      | jb/jnae  | операнд_1 <  операнд_2 | cf = 1             |
| Без знака      | jbe/jna  | операнд_1 <= операнд_2 | cf = 1 OR zf=1     |
| Без знака      | ja/jnbe  | операнд_1 >  операнд_2 | cf = 0 AND zf = 0  |
| Без знака      | jae/jnb  | операнд_1 => операнд_2 | cf = 0             |
