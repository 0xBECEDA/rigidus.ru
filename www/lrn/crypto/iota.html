<!DOCTYPE html>
<html>
<head>
<title>IOTA - криптовалюта для интернета вещей.</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">IOTA - криптовалюта для интернета вещей.</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Как работает IOTA</a>
<ul>
<li><a href="#unnumbered-2">Граф транзакций и подтверждения</a></li>
<li><a href="#unnumbered-3">Предотвращение Double spending</a></li>
<li><a href="#unnumbered-4">Эмиссия</a></li>
</ul>
</li>
<li><a href="#unnumbered-5">Пользовательские характеристики</a>
<ul>
<li><a href="#unnumbered-6">Высокая производительность для IoT</a></li>
<li><a href="#unnumbered-7">Отсутствие упорядочивания</a></li>
</ul>
</li>
<li><a href="#unnumbered-8">Сценарии атаки</a>
<ul>
<li><a href="#unnumbered-9">Broken tangle</a></li>
<li><a href="#unnumbered-10">Double spending</a></li>
</ul>
</li>
<li><a href="#unnumbered-11">Ссылки</a></li>
<li><a href="#unnumbered-12">Критика</a></li>
<li><a href="#unnumbered-13">Вопросы</a></li>
<li><a href="#unnumbered-14">Транзакция</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Как работает IOTA</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
IOTA - криптовалюта для интернета вещей. Базовой структурой является, так называемый
<code>tangle</code> - вариант направленного ациклического графа (DAG). Несмотря на то, что "tangle"
означает "клубок", структурно это скорее похоже на связаный шарф.
</p>
</div>

<div id="outline-container-unnumbered-2" class="outline-3">
<h3 id="unnumbered-2">Граф транзакций и подтверждения</h3>
<div class="outline-text-3" id="text-unnumbered-2">
<p>
Каждый узел (vertex) представляет собой транзакцию, каждое ребро является направленным,
и представляет собой ссылку на хэш ранее созданной транзакции.
</p>

<p>
Из одного вертекса может быть не более двух ссылок на предыдущие транзакции. Очевидно,
первый вертекс не может иметь предшественников, а второй имеет только одного.
Предполагаю, что для таких вертексов в соответствующих полях размещены нули.
</p>

<p>
Узлы, на которые нет ссылок, называются оконечными (<code>tips</code>). Когда новая транзакция
создается, из множества известных узлов выбираются те, хэш которых будет помещен в её
ссылочное поле
</p>

<p>
В каждый момент времени по крайней мере один <code>tip</code> будет существовать, поэтому если
новые транзакции приходят редко, то <code>tangle</code> вырождается в <code>chain</code>, т.е. каждая
следующая транзакция подтверждает только одну предыдущую.
</p>

<p>
<div class="figure"><img src="/img/iota-chain.png" alt="nil"/><p></p></div>
</p>

<p>
Напротив, если множество транзакций приходят одномоментно, то все они будут ссылаться
на один доступный <code>tip</code>, что выглядит как "одуванчик", где этот <code>tip</code> в центре.
</p>

<p>
<div class="figure"><img src="/img/iota-star.png" alt="nil"/><p></p></div>
</p>

<p>
Так как каждый узел при создании захватывает два оконечных узла (если может),
предполагается тенденция уменьшения кол-ва свободных оконечных узлов - в пределе до
одного.
</p>

<p>
В момент создания транзакции необходимо выбрать среди известных узлов те, которые будут
подтверждаться. Можно было бы выбирать случайно, но есть более интересный алгоритм,
который называется <code>unweighted random walk</code>
</p>

<p>
Его суть в следующем: мы помещаем "курсор" в genesis-транзакцию и на каждом шаге он
переходит на одну из транзакций, которая апрувит ту, где он сейчас находится. Если
таких транзакций несколько, то выбор одной из них происходит случайным образом.
</p>

<p>
<div class="figure"><img src="/img/unweighted-random-walk.gif" alt="nil"/><p></p></div>
</p>

<p>
Таким образом, благодаря этому механизму, последние транзакции связываются с
предпоследними и получается именно "вязаный шарф".
</p>

<p>
Однако, при использовании этого алгоритма сеть не может противодействовать появлению
"ленивых оконечных узлов", <code>lazy tips</code>, которые вместо исполнения алгоритма <code>unweighted
random walk</code> просто подтверждают старые, уже много раз подтвержденные транзакции -
такой подход вычислительно дешевле, но не помогает сети, т.к. новые тразакции не
подтверждаются.
</p>

<p>
<div class="figure"><img src="/img/bad-unweighted-random-walk.png" alt="nil"/><p></p></div>
</p>

<p>
Решение состоит в том, чтобы встроить в систему стимулы против подобного поведения,
так, чтобы <code>lazy tips</code> были бы подтверждены сетью с меньшей вероятностью. Введем термин
"совокупный вес", <code>cumulative weight</code>, чтобы отразить важность транзакции. <code>Cumulative
weight</code> данного узла рассчитываестя как количество подтверждений этого узла плюс
один. В приведенном примере транзакция номер 3 имеет совокупный вес равный 5, потому
что ее подтверждают четыре синие транзакции.
</p>

<p>
<div class="figure"><img src="/img/cumulative-weight.png" alt="nil"/><p></p></div>
</p>

<p>
В примере ниже транзакция 16 является <code>lazy tip</code>. Чтобы подтвердить её, <code>unweighted
random walk</code> должен достичь транзакции 7, а затем выбрать транзакцию 16 за
транзакцией 9. Но в модели предпочтения транзакций с большим <code>cumulative weight</code> это
врядли произойдет, потому что транзакция 16 имеет кумулятивный вес равный единице, а
транзакция 9 - кумулятивный вес равный семи. Этот механизм эффективно предотвращает
"ленивое" поведение.
</p>

<p>
<div class="figure"><img src="/img/iota-lazy-prevention.png" alt="nil"/><p></p></div>
</p>

<p>
Нужна ли нам вообще случайность? Мы можем всегда выбирать самую тяжелую транзакцию, без
каких-либо вероятностей. Но тогда мы получим множество побочных транзакций, которые
никогда не будут одобрены:
</p>

<p>
<div class="figure"><img src="/img/super-weighed-walk.png" alt="nil"/><p></p></div>
</p>

<p>
Чтобы избежать этого вводится новый параметр <code>alfa</code> который устанавливает, насколько
важен кумулятивный вес транзакции. Он влияет на вероятность выбора узла. Если <code>alfa</code>
равен нулю - мы возвращаемся к <code>unweighted random walk</code>.
</p>

<p>
<div class="figure"><img src="/img/weighted-random-walk.png" alt="nil"/><p></p></div>
</p>

<p>
Правильный выбор <code>alfa</code> - нетривиальная задача, которая решается методом Markov Chain
Monte Carlo, <code>MCMC</code>. В цепи Маркова каждый шаг не зависит от предыдущего, а следует из
заранее определенног правила.
</p>

<p>
<div class="figure"><img src="/img/mcmc.gif" alt="nil"/><p></p></div>
</p>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-3">
<h3 id="unnumbered-3">Предотвращение Double spending</h3>
<div class="outline-text-3" id="text-unnumbered-3">
<p>
Предотвращение <code>double-spending</code> осуществляется следующим образом:
</p>

<p>
Положим, <code>Алиса</code> имеет на балансе 5 монет и создает две транзакции, в первой из которых
пересылает их <code>Бобу</code>, а во второй - <code>Чарли</code>. В таком случае узел, который видит обе
транзакции, должен отвергнуть как минимум одну из этих транзакций, т.к. в результате
<code>Алиса</code> будет иметь отрицительный баланс.
</p>

<p>
<div class="figure"><img src="/img/iota-double-spending-base.png" alt="nil"/><p></p></div>
</p>

<p>
Если одна из транзакций будет подтверждена одним узлом, а другая - иным, то это
приведет к формированию двух ветвей, одна из которых в конечно счете должна быть
отброшена. При использовании алгоритма <code>weighted random walk</code>, со временем одна из
ветвей станет больше.
</p>

<p>
Доверие к транзакции расчитывается как процент оконечных узлов (<code>tips</code>), которые её
подтверждают. На картинке транзакции с доверием больше 95% показаны с толстой
рамкой. Так например, транзакция 9 подтверждается двумя из четырех <code>tips</code>. Если бы мы
использовали <code>random tip selection</code>, у неё было бы 50%. Тем не менее, оконечные узлы,
которые её подтверждают, по-видимому, более весомы, чем те, которые не подтверждают,
что немного повышает доверие.
</p>

<p>
<div class="figure"><img src="/img/confirmation-confidence.png" alt="nil"/><p></p></div>
</p>

<p>
Как только сделка Алисы достигает некоторого очень высокого доверительного порога,
скажем, 95%, маловероятно, что она будет вытеснена из консенсуса. Однако <code>Алиса</code> может
попытаться сформировать альтернативную ветвь в <code>tangle</code>. Для этого она должна
поддержать double spending транзакцию для <code>Чарли</code>. <code>Алисе</code> придется апрувить две старые
транзакции, которые не ссылаются на ее транзакцию с <code>Чарли</code>. Затем она начнет выдавать
как можно больше транзакций, пытаясь увеличить вес ветки с транзакцией для <code>Чарли</code>.
</p>

<p>
Если у нее будет достаточно вычислительной мощности, она может заставить сеть поверить
ей и последовать за ее веткой, однако, если мы рассчитаем уровень доверия для ветки с
транзакцией для <code>Боба</code>, то увидим, что он снизился с 95% до нуля.
</p>

<p>
<code>Боб</code> может рассчитать доверие пока оно 95% и выполнить свою часть сделки - отправить
товар или оказать услугу, а потом столкнуться с тем, что доверие изменилось - тогда
атака <code>Алисы</code> удалась.
</p>

<p>
Для зрелой и активной сети вычислительные ресурсы для реализации атаки будут слишком
дорогостоящими, но на стадии развития такая атака может быть очень вероятной. Под этим
предлогом IOTA Foundation вводит так называемый "Координатор", который является
централизованным сервером, который каждые две минуты создает <code>milestone</code>-транзакцию,
которая немедленно подтверждает все одобренные ей транзакции на 100%. Они заявляют, что
это временное решение, до тех пор, пока сеть не выйдет на достаточный уровень
мощности.
</p>
</div>
</div>

<div id="outline-container-unnumbered-4" class="outline-3">
<h3 id="unnumbered-4">Эмиссия</h3>
<div class="outline-text-3" id="text-unnumbered-4">
<p>
Отсутствует, все монеты были созданы в первой транзакции. По сценарию в первых
транзакциях они распределяются среди инвесторов.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-5" class="outline-2">
<h2 id="unnumbered-5">Пользовательские характеристики</h2>
<div class="outline-text-2" id="text-unnumbered-5">
</div><div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">Высокая производительность для IoT</h3>
<div class="outline-text-3" id="text-unnumbered-6">
<p>
Сеть позиционируется как легковесное решение для устройств, ограниченных в
вычислительной мощности и энергопотреблении.
</p>
</div>
</div>

<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">Отсутствие упорядочивания</h3>
<div class="outline-text-3" id="text-unnumbered-7">
<p>
Порядок транзакций не имеет значения, потому что итоговый баланс от него не
зависит. Это повышает производительность.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-8" class="outline-2">
<h2 id="unnumbered-8">Сценарии атаки</h2>
<div class="outline-text-2" id="text-unnumbered-8">
</div><div id="outline-container-unnumbered-9" class="outline-3">
<h3 id="unnumbered-9">Broken tangle</h3>
<div class="outline-text-3" id="text-unnumbered-9">
<p>
Идея состоит в том, чтобы выпустить N конфликтующих транзакций, две из которых не могут
подтвердить другие узлы в сети, эффективно разбивая tangle на N сегментов. В конце
концов один выигрывает, но все, кто отправил транзакции на отвергнутый сегмент, должны
будут повторно отправить их, и к тому времени злоумышленник мог выпустить еще один
набор конфликтных транзакций.
</p>

<p>
Цель состоит в том, чтобы предотвратить подтверждение большинства транзакций (отказ в
обслуживании)
</p>
</div>
</div>

<div id="outline-container-unnumbered-10" class="outline-3">
<h3 id="unnumbered-10">Double spending</h3>
<div class="outline-text-3" id="text-unnumbered-10">
<p>
Большую часть времени узел получает и обменивает транзакции с соседями. Он заботится о
топологии графа только тогда, когда пришло время произвести транзакцию или принять
платеж.
</p>

<p>
<div class="figure"><img src="/img/iota-double-spending.png" alt="nil"/><p></p></div>
</p>

<p>
Сейчас 16:04, и <code>Боб</code> решает отправить транзакцию, которая ссылается на 2 транзакции:
</p>
<ul class="org-ul">
<li>1 йота на адрес <code>Алисы</code>
</li>
<li>1 йоту от адреса <code>Алисы</code>
</li>
</ul>

<p>
Это не приводит к <code>double</code> spending, поэтому в 16:07 он завершает создание транзакции.
</p>

<p>
Через 90 минут плохой парень <code>Чарли</code> решает сослаться на сделку <code>Боба</code> и другую сделку,
которая тратит 1 йоту с адреса <code>Алисы</code>
</p>

<p>
В 17:44 он завершает создание транзакции, которая ссылается на subtangle с искаженным
состоянием.
</p>

<p>
Никто из нас не заботится об этом, мы не знаем о плохом парне <code>Чарли</code>, потому что наши
узлы продолжают получать все транзакции и делиться ими.
</p>

<p>
В 19:15 хорошая девочка <code>Диана</code> решает отправить сообщение своей матери, она анализирует
<code>Tangle</code> и видит, что она не должна ссылаться на транзакцию Чарли, поэтому вместо этого
ссылается на транзакцию <code>Боба</code>.
</p>

<p>
Ее транзакция не является особенной, поэтому она не показана на картинке
</p>

<p>
Спустя несколько минут умная девушка <code>Ева</code> решает отправить сообщение своему парню. Она
хороша, но она тоже умна и решает потролить плохого парня <code>Чарли</code>
</p>

<p>
Она находит транзакцию, которая откладывает 1 йоту на адрес <code>Алисы</code>. Она ссылается на
эту сделку, а также на сделку <code>Чарли</code>. Мы видим сделку <code>Евы</code> в 19:21
</p>

<p>
Позже кто-то другой, производящий транзакцию, будет ссылаться на транзакцию <code>Евы</code> без
каких-либо проблем, потому что она «исправила» проблему, созданную <code>Чарли</code>.
</p>

<p>
Как мы можем видеть в этом сценарии в течение короткого периода времени, реестр может
быть неконсистентным
</p>

<p>
Все будет хорошо, если 67% + мощности хеширования контролируются доброжелательными
пользователями.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-11" class="outline-2">
<h2 id="unnumbered-11">Ссылки</h2>
<div class="outline-text-2" id="text-unnumbered-11">
<ul class="org-ul">
<li>whitepaper <a href="https://iota.org/IOTA_Whitepaper.pdf">https://iota.org/IOTA_Whitepaper.pdf</a>
</li>
<li>референсная реализация: <a href="https://github.com/iotaledger/iri">https://github.com/iotaledger/iri</a>
</li>
<li>демонстрашка на js: <a href="https://public-rdsdavdrpd.now.sh/">https://public-rdsdavdrpd.now.sh/</a>
</li>
<li>демонстрашка unweighted random walk: <a href="https://public-xnmzdqumwy.now.sh/">https://public-xnmzdqumwy.now.sh/</a>
</li>
<li>демонстрашка mcmc <a href="https://public-qnbiiqwyqj.now.sh/">https://public-qnbiiqwyqj.now.sh/</a>
</li>
<li>демо confirmation confidence <a href="https://public-krwdbaytsx.now.sh/">https://public-krwdbaytsx.now.sh/</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-12" class="outline-2">
<h2 id="unnumbered-12">Критика</h2>
<div class="outline-text-2" id="text-unnumbered-12">
<ul class="org-ul">
<li><a href="https://casey.github.io/iota/">https://casey.github.io/iota/</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-13" class="outline-2">
<h2 id="unnumbered-13">Вопросы</h2>
<div class="outline-text-2" id="text-unnumbered-13">
<ul class="org-ul">
<li>Топология сети?
</li>
<li>Протокольный уровень правило взаимодействия узлов?
</li>
<li>Как работают консенсус и валидация блоков? Кто проверяет?
</li>
<li>Механизмы хранения данных как устроены хранилища?
</li>
<li>Смарт-контракты: да, нет, другие подходы
</li>
<li>Что такое коссвенное подтверждение?
</li>
<li>Что такое скрытые оконечники
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-14" class="outline-2">
<h2 id="unnumbered-14">Транзакция</h2>
<div class="outline-text-2" id="text-unnumbered-14">
<p>
Я взял кусок класса транзакции из сорцов:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #af00ff;">public</span> <span style="color: #af00ff;">class</span> <span style="color: #008700;">Transaction</span> <span style="color: #af00ff;">implements</span> <span style="color: #008700;">Persistable</span> {
    <span style="color: #af00ff;">public</span> <span style="color: #af00ff;">static</span> <span style="color: #af00ff;">final</span> <span style="color: #008700;">int</span> <span style="color: #af5f00;">SIZE</span> = 1604;

    <span style="color: #af00ff;">public</span> <span style="color: #008700;">byte</span>[] <span style="color: #af5f00;">bytes</span>;

    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">address</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">bundle</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">trunk</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">branch</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">obsoleteTag</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">value</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">currentIndex</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">lastIndex</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">timestamp</span>;

    <span style="color: #af00ff;">public</span> <span style="color: #008700;">Hash</span> <span style="color: #af5f00;">tag</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">attachmentTimestamp</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">attachmentTimestampLowerBound</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">attachmentTimestampUpperBound</span>;

    <span style="color: #af00ff;">public</span> <span style="color: #008700;">int</span> <span style="color: #af5f00;">validity</span> = 0;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">int</span> <span style="color: #af5f00;">type</span> = <span style="color: #008787;">TransactionViewModel</span>.PREFILLED_SLOT;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">arrivalTime</span> = 0;

    <span style="color: #af0000;">//</span><span style="color: #af0000;">public boolean confirmed = false;</span>
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">boolean</span> <span style="color: #af5f00;">parsed</span> = <span style="color: #008787;">false</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">boolean</span> <span style="color: #af5f00;">solid</span> = <span style="color: #008787;">false</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">long</span> <span style="color: #af5f00;">height</span> = 0;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">String</span> <span style="color: #af5f00;">sender</span> = <span style="color: #87005f;">""</span>;
    <span style="color: #af00ff;">public</span> <span style="color: #008700;">int</span> <span style="color: #af5f00;">snapshot</span>;

    ...
}
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
