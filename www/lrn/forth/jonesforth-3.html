<!DOCTYPE html>
<html>
<head>
<title>jonesforth-3</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">jonesforth-3</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Общие соображения</a>
<ul>
<li><a href="#sec-1-1">Атомы</a></li>
<li><a href="#sec-1-2">Списки</a></li>
<li><a href="#sec-1-3">cons, car и cdr (c***r)</a></li>
<li><a href="#sec-1-4">T и NIL</a></li>
<li><a href="#sec-1-5">null</a></li>
<li><a href="#sec-1-6">number</a></li>
<li><a href="#sec-1-7">eq</a></li>
<li><a href="#sec-1-8">equal</a></li>
<li><a href="#sec-1-9">quote</a></li>
<li><a href="#sec-1-10">Тэги</a></li>
<li><a href="#sec-1-11">Cons-cells</a></li>
<li><a href="#sec-1-12">Atom-cells</a></li>
<li><a href="#sec-1-13">Списки свойств атома</a></li>
</ul>
</li>
<li><a href="#sec-2">Cons-ячейки</a>
<ul>
<li><a href="#sec-2-1">Создание cons-ячеек</a>
<ul>
<li><a href="#sec-2-1-1">Alter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Расширяем Forth</a>
<ul>
<li><a href="#sec-3-1">Минимализм</a></li>
<li><a href="#sec-3-2">Eval</a></li>
<li><a href="#sec-3-3">Environment</a></li>
<li><a href="#sec-3-4">Global definitions</a></li>
<li><a href="#sec-3-5">Read</a>
<ul>
<li><a href="#sec-3-5-1">Tokenizer</a></li>
</ul>
</li>
<li><a href="#sec-3-6">Atom</a></li>
</ul>
</li>
<li><a href="#sec-4">Базовые типы</a></li>
<li><a href="#sec-5">Полный текст си-части</a></li>
<li><a href="#sec-6">Лисп-часть</a></li>
<li><a href="#sec-7">Полезные ссылки</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Общие соображения</h2>
<div class="outline-text-2" id="text-1">
<p>
В лиспе есть два базовых понятия, через которые может быть выражено все остальное:
</p>
<ul class="org-ul">
<li>атом (atom)
</li>
<li>пара (pair)
</li>
</ul>

<p>
И атом и пара хранятся в памяти машины, поэтому необходимо создать для них
представление и несколько базовых функций.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Атомы</h3>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Списки</h3>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">cons, car и cdr (c***r)</h3>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">T и NIL</h3>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">null</h3>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">number</h3>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">eq</h3>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">equal</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">equal</span> x y)
  (<span style="color: #a020f0;">cond</span> ((numberp x)
         (<span style="color: #a020f0;">cond</span> ((numberp y) (= x y))
               (t nil)))
        ((atom x) (eq x y))
        ((atom y) nil)
        ((equal (car x) (car y))
         (equal (cdr x) (cdr y)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">quote</h3>
</div>


<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">Тэги</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Атом и пара должны содержать так назвываемый "тэг" (<code>tag</code>), представляющий собой набор
битов, который описывает их свойства. Если старший бит тэга равен единице - это атом,
иначе - это пара.
</p>

<p>
Пара содержит в себе два указателя, которые мы традиционно будем называть
</p>
<ul class="org-ul">
<li><code>A</code>-указатель
</li>
<li><code>D</code>-указатель
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">Cons-cells</h3>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">Atom-cells</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Информационная ячейка атома подобно ячейкам списочной памяти содержит CAR- и
CDR-указатели.  Но если у cons-ячеек остальные разряды заполнены нулями и почти никакой
информации не несут, то у ячеек атома в этих разрядах содержится большая часть сведений
об атоме. Один из этих разрядов (43-й) должен содержать 1, являющуюся признаком
информационной ячейки. Группа разрядов (47-й — 44-й) содержит код наименования
свойства, которым наделен данный атом. Предусмотрены следующие стандартные наименования
свойств:
</p>
<ul class="org-ul">
<li>SVBR - встроенная обычная функция
</li>
<li>FSUBR - встроенная специальная функция,
</li>
<li>EXPR - обычная функция, определенная в выполняемой программе,
</li>
<li>FEXPR - специальная функция определенная в программе,
</li>
<li>APVAL -константа (безразлично, встроенная или введенная в программе),
</li>
<li>FIX - целое (десятичное)
</li>
<li>BITS — строка битов (восьмеричное число).
</li>
</ul>

<p>
Разряды с 39 го
по 25-й отведены под CAR-указатель, который содержит адрес свойства:
</p>
<ul class="org-ul">
<li>адрес начала машинной подпрограммы для свойств SUBR и FSUBR,
</li>
<li>адрес определяющего выражения функции в списочной памяти для свойств EXPR и FEXPR,
</li>
<li>адрес значения константы для свойства APVAL,
</li>
<li>адрес самой информационной ячейки числа для свойств FIX и BITS.
</li>
</ul>

<p>
Как мы увидим впоследствии (см. разд. 2.8), именно
такое использование а-указателя информационной ячейки числа
позволяет записывать числа в лисповских программах, не
прибегая к помощи QUOTE (см. разд. 1.32).
</p>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">Списки свойств атома</h3>
</div>
</div>



<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Cons-ячейки</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Создание cons-ячеек</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Чтобы создать cons-ячейку, надо выделить под нее 2 слова и вернуть указатель:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="cons0">: CONS0 2 CELLS ALLOT <span style="color: #a020f0;">;</span>
</pre>
</div>

<p>
Чтобы записать в CAR этой CONS-ячейки значение, нужен указатель и собственно значение:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="set_car_cons">: CAR! ( value addr -- ) ! <span style="color: #a020f0;">;</span>
</pre>
</div>

<p>
Чтобы прочитать значение из CAR этой ячейки нужен только адрес:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="get_car_cons">: CAR@ ( value addr -- ) @ <span style="color: #a020f0;">;</span>
</pre>
</div>

<p>
Чтобы записать/прочитать в CDR нужно сделать то же самое, только увеличить адрес на
размер машинного слова:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="set_cdr_cons">: CDR! ( value addr -- ) 1 CELLS + ! <span style="color: #a020f0;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="set_cdr_cons">: CDR@ ( value addr -- ) 1 CELLS + @ <span style="color: #a020f0;">;</span>
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">Alter</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Альтернативные варианты этого
</p>

<div class="org-src-container">

<pre class="src src-forth">: car! ( v a - ) ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr! </span>( v a - ) cell+ ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">car@ </span>( a - v ) @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr@ </span>( a - v ) cell+ @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons </span>( k v - a ) swap 2 cells allocate throw tuck ! tuck ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons0 </span>( - a ) 0 0 cons <span style="color: #a020f0;">;</span>

<span style="color: #b22222;">\ &#1055;&#1088;&#1086;&#1089;&#1090;&#1091;&#1102; &#1103;&#1095;&#1077;&#1081;&#1082;&#1091; cons &#1084;&#1086;&#1078;&#1085;&#1086; &#1089;&#1076;&#1077;&#1083;&#1072;&#1090;&#1100; &#1089; &#1084;&#1077;&#1085;&#1100;&#1096;&#1077;&#1081; &#1089;&#1083;&#1086;&#1078;&#1085;&#1086;&#1089;&#1090;&#1100;&#1102; &#1073;&#1077;&#1079; &#1076;&#1080;&#1085;&#1072;&#1084;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1075;&#1086; &#1088;&#1072;&#1089;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;:
</span>
<span style="color: #b22222;">\
\ Simplified cons cells
\ Tested under RetroForth, gForth, Win32Forth
\
</span><span style="color: #a020f0;">: </span><span style="color: #0000ff;">car! </span>( v a -- ) ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr! </span>( v a -- ) cell+ ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">car@ </span>( a -- v ) @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr@ </span>( a -- v ) cell+ @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons </span>( car cdr -- a ) swap here &gt;r , , r&gt; <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons0 </span>( -- a ) 0 0 cons <span style="color: #a020f0;">;</span>


<span style="color: #b22222;">\ For Retro 11.x
\ Use @car @cdr !car !cdr with this.
</span><span style="color: #a020f0;">: </span><span style="color: #0000ff;">car </span>   (  a-A )  <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr </span>   (  a-A )  1+ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons </span>  ( cc-a )  swap here [ 2, ] dip <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons0 </span> (   -a )  0 0 cons <span style="color: #a020f0;">;</span>

<span style="color: #b22222;">\
\ For PygmyForth
\
</span><span style="color: #a020f0;">: </span><span style="color: #0000ff;">car! </span>( v a -- ) ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr! </span>( v a -- ) 2 + ! <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">car@ </span>( a -- v ) @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cdr@ </span>( a -- v ) 2 + @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons </span>( car cdr -- a ) SWAP HERE PUSH , , POP <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons0 </span>( -- a ) 0 0 cons <span style="color: #a020f0;">;</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth">0 <span style="color: #228b22;">CONSTANT </span><span style="color: #a0522d;">NULL
</span><span style="color: #a020f0;">: </span><span style="color: #0000ff;">null? </span>NULL = <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons </span>( tail head -- cons )  , , HERE 2 cells - <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">head </span>( cons -- head )  @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">tail </span>( cons -- tail )  1 cells + @ <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">execr </span>( func -- n )  swap execute <span style="color: #a020f0;">;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">size </span><span style="color: #b22222;">( cons -- n )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        drop <span style="color: #008b8b;">0</span>
    <span style="color: #a020f0;">else</span>
        tail size 1+
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">str </span><span style="color: #b22222;">( cons -- )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        <span style="color: #8b2252;">." NULL"</span>
    <span style="color: #a020f0;">else</span>
        dup head .
        tail str
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">range </span><span style="color: #b22222;">( upto from -- cons )</span> recursive
    2dup = <span style="color: #a020f0;">if</span>
        2drop NULL
    <span style="color: #a020f0;">else</span>
        tuck 1+ range
        swap cons
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">nth </span><span style="color: #b22222;">( nthindex cons -- nthelem )</span> recursive
    over <span style="color: #008b8b;">0 </span>= <span style="color: #a020f0;">if</span>
        head nip
    <span style="color: #a020f0;">else</span>
        swap 1- swap tail nth
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">3dup </span>( a b c -- a b c a b c )  dup 2over rot <span style="color: #a020f0;">;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">reduce </span><span style="color: #b22222;">( binop initn cons -- n )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        drop nip
    <span style="color: #a020f0;">else</span>
        3dup
        head rot execute
        rot drop
        swap tail reduce
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">map </span><span style="color: #b22222;">( func cons -- cons )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        nip
    <span style="color: #a020f0;">else</span>
        2dup
        tail map -rot
        head execr cons
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">filter </span><span style="color: #b22222;">( pred cons -- cons )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        nip
    <span style="color: #a020f0;">else</span>
        2dup tail filter -rot
        head tuck execr <span style="color: #a020f0;">if</span>
            cons
        <span style="color: #a020f0;">else</span>
            drop
        <span style="color: #a020f0;">endif</span>
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">sum </span>( cons -- sumn )  ['] + 0 rot reduce <span style="color: #a020f0;">;</span>

<span style="color: #a020f0;">: </span><span style="color: #0000ff;">cons= </span><span style="color: #b22222;">( cons1 cons2 -- bool )</span> recursive
    dup null? <span style="color: #a020f0;">if</span>
        drop null?
    <span style="color: #a020f0;">else</span>
        over null? <span style="color: #a020f0;">if</span>
            2drop <span style="color: #008b8b;">0</span>
        <span style="color: #a020f0;">else</span>
            2dup
            head swap head = <span style="color: #a020f0;">if</span>
                tail swap tail swap cons=
            <span style="color: #a020f0;">else</span>
                2drop <span style="color: #008b8b;">0</span>
            <span style="color: #a020f0;">endif</span>
        <span style="color: #a020f0;">endif</span>
    <span style="color: #a020f0;">endif ;</span>

<span style="color: #b22222;">( *** TESTS *** )</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">assert </span>( bool -- ) invert if cr s" AssertionError: " exception throw endif <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">even? </span>( n -- bool ) 2 mod 0 = <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">odd? </span>( n -- bool ) even? invert <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">doubled </span>( n -- 2n ) 2 * <span style="color: #a020f0;">;</span>
<span style="color: #a020f0;">: </span><span style="color: #0000ff;">square </span>( n -- nsquared ) dup * <span style="color: #a020f0;">;</span>

NULL <span style="color: #008b8b;">1 </span>cons head <span style="color: #008b8b;">1 </span>= assert
NULL <span style="color: #008b8b;">1 </span>cons tail NULL = assert
NULL <span style="color: #008b8b;">2 </span>cons 1 cons head <span style="color: #008b8b;">1 </span>= assert
NULL <span style="color: #008b8b;">2 </span>cons 1 cons tail head <span style="color: #008b8b;">2 </span>= assert
NULL <span style="color: #008b8b;">2 </span>cons <span style="color: #008b8b;">1 </span>cons tail tail NULL = assert
NULL <span style="color: #008b8b;">3 </span>cons 2 cons 1 cons size <span style="color: #008b8b;">3 </span>= assert

<span style="color: #008b8b;">2 </span>even? assert
<span style="color: #008b8b;">3 </span>odd? assert

<span style="color: #008b8b;">10 </span>1 range size <span style="color: #008b8b;">9 </span>= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">odd? </span>16 <span style="color: #008b8b;">1 </span>range filter
NULL <span style="color: #008b8b;">15 </span>cons 13 cons 11 cons 9 cons 7 cons 5 cons 3 cons <span style="color: #008b8b;">1 </span>cons
cons= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">even? </span>11 <span style="color: #008b8b;">1 </span>range filter
NULL <span style="color: #008b8b;">10 </span>cons 8 cons 6 cons 4 cons <span style="color: #008b8b;">2 </span>cons
cons= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">even? </span>6 1 range dup <span style="color: #a020f0;">' </span><span style="color: #0000ff;">odd? </span>swap filter
cons= invert assert

<span style="color: #008b8b;">10 2 </span>range
<span style="color: #008b8b;">17 3 </span>range
cons= invert assert

NULL
NULL <span style="color: #008b8b;">1 </span>cons
cons= invert assert

NULL <span style="color: #008b8b;">1 </span>cons
NULL
cons= invert assert

NULL NULL cons= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">square </span>6 <span style="color: #008b8b;">1 </span>range map
NULL <span style="color: #008b8b;">25 </span>cons 16 cons 9 cons 4 cons <span style="color: #008b8b;">1 </span>cons
cons= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">odd? </span>10 <span style="color: #008b8b;">1 </span>range map
NULL <span style="color: #008b8b;">-1 </span>cons 0 cons -1 cons 0 cons -1 cons 0 cons -1 cons 0 cons <span style="color: #008b8b;">-1 </span>cons
cons= assert

<span style="color: #008b8b;">0 </span>NULL 1 cons nth <span style="color: #008b8b;">1 </span>= assert
<span style="color: #008b8b;">0 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #008b8b;">1 </span>= assert
<span style="color: #008b8b;">1 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #008b8b;">2 </span>= assert
<span style="color: #008b8b;">2 </span>NULL 3 cons 2 cons 1 cons nth <span style="color: #008b8b;">3 </span>= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>123 null reduce <span style="color: #008b8b;">123 </span>= assert
<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>123 null 5 cons reduce <span style="color: #008b8b;">128 </span>= assert
<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>123 null 2 cons 1 cons reduce <span style="color: #008b8b;">126 </span>= assert
<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>100 null 4 cons 3 cons 2 cons 1 cons reduce <span style="color: #008b8b;">110 </span>= assert
<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>0   101 1 range reduce <span style="color: #008b8b;">5050 </span>= assert
<span style="color: #a020f0;">' </span><span style="color: #0000ff;">* </span>1   11 1 range reduce <span style="color: #008b8b;">3628800 </span>= assert
<span style="color: #008b8b;">1753 </span>112 range sum <span style="color: #008b8b;">1529412 </span>= assert

<span style="color: #a020f0;">' </span><span style="color: #0000ff;">+ </span>0 <span style="color: #a020f0;">' </span><span style="color: #0000ff;">doubled
</span><span style="color: #a020f0;">' </span><span style="color: #0000ff;">odd?
</span><span style="color: #008b8b;">3201 1350 </span>range
filter
map
reduce
<span style="color: #008b8b;">4208750 </span>= assert
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Расширяем Forth</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Минимализм</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Необходимы шесть специальных форм:
</p>
<ul class="org-ul">
<li>ссылка на переменную
</li>
<li>константный литерал
</li>
<li>(quote exp)
</li>
<li>(if test conseq alt)
</li>
<li>(set! var exp) присваивание
</li>
<li>(define var exp)
</li>
<li>(lambda (var&#x2026;) exp)
</li>
<li>последовательность (progn)
</li>
<li>вызов процедуры (proc exp&#x2026;)
</li>
</ul>

<p>
И три синтаксические конструкции
</p>
<ul class="org-ul">
<li>parse
</li>
<li>eval
</li>
<li>environment
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Eval</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">eval</span>(x, env=global_env):
    <span style="color: #8b2252;">"Evaluate an expression in an environment."</span>
    <span style="color: #a020f0;">if</span> isa(x, Symbol):             <span style="color: #b22222;"># </span><span style="color: #b22222;">variable reference</span>
        <span style="color: #a020f0;">return</span> env.find(x)[x]
    <span style="color: #a020f0;">elif</span> <span style="color: #a020f0;">not</span> isa(x, <span style="color: #483d8b;">list</span>):         <span style="color: #b22222;"># </span><span style="color: #b22222;">constant literal</span>
        <span style="color: #a020f0;">return</span> x
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'quote'</span>:          <span style="color: #b22222;"># </span><span style="color: #b22222;">(quote exp)</span>
        (_, exp) = x
        <span style="color: #a020f0;">return</span> exp
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'if'</span>:             <span style="color: #b22222;"># </span><span style="color: #b22222;">(if test conseq alt)</span>
        (_, test, conseq, alt) = x
        <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">eval</span>((conseq <span style="color: #a020f0;">if</span> <span style="color: #483d8b;">eval</span>(test, env) <span style="color: #a020f0;">else</span> alt), env)
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'set!'</span>:           <span style="color: #b22222;"># </span><span style="color: #b22222;">(set! var exp)</span>
        (_, var, exp) = x
        env.find(var)[var] = <span style="color: #483d8b;">eval</span>(exp, env)
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'define'</span>:         <span style="color: #b22222;"># </span><span style="color: #b22222;">(define var exp)</span>
        (_, var, exp) = x
        <span style="color: #a0522d;">env</span>[var] = <span style="color: #483d8b;">eval</span>(exp, env)
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'lambda'</span>:         <span style="color: #b22222;"># </span><span style="color: #b22222;">(lambda (var*) exp)</span>
        (_, <span style="color: #483d8b;">vars</span>, exp) = x
        <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">lambda</span> *args: <span style="color: #483d8b;">eval</span>(exp, Env(<span style="color: #483d8b;">vars</span>, args, env))
    <span style="color: #a020f0;">elif</span> x[0] == <span style="color: #8b2252;">'begin'</span>:          <span style="color: #b22222;"># </span><span style="color: #b22222;">(begin exp*)</span>
        <span style="color: #a020f0;">for</span> exp <span style="color: #a020f0;">in</span> x[1:]:
            <span style="color: #a0522d;">val</span> = <span style="color: #483d8b;">eval</span>(exp, env)
            <span style="color: #a020f0;">return</span> val
        <span style="color: #a020f0;">else</span>:                          <span style="color: #b22222;"># </span><span style="color: #b22222;">(proc exp*)</span>
            <span style="color: #a0522d;">exps</span> = [<span style="color: #483d8b;">eval</span>(exp, env) <span style="color: #a020f0;">for</span> exp <span style="color: #a020f0;">in</span> x]
            <span style="color: #a0522d;">proc</span> = exps.pop(0)
            <span style="color: #a020f0;">return</span> proc(*exps)

    <span style="color: #a0522d;">isa</span> = <span style="color: #483d8b;">isinstance</span>
    <span style="color: #a0522d;">Symbol</span> = <span style="color: #483d8b;">str</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Environment</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Env</span>(<span style="color: #483d8b;">dict</span>):
    <span style="color: #8b2252;">"An environment: a dict of {'var':val} pairs, with an outer Env."</span>
    <span style="color: #a020f0;">def</span> <span style="color: #0000ff;">__init__</span>(<span style="color: #a020f0;">self</span>, parms=(), args=(), outer=<span style="color: #008b8b;">None</span>):
        <span style="color: #a020f0;">self</span>.update(<span style="color: #483d8b;">zip</span>(parms,args))
        <span style="color: #a020f0;">self</span>.outer = outer
        <span style="color: #a020f0;">def</span> <span style="color: #0000ff;">find</span>(<span style="color: #a020f0;">self</span>, var):
            <span style="color: #8b2252;">"Find the innermost Env where var appears."</span>
            <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">self</span> <span style="color: #a020f0;">if</span> var <span style="color: #a020f0;">in</span> <span style="color: #a020f0;">self</span> <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">self</span>.outer.find(var)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Global definitions</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>+
</li>
<li>-
</li>
<li>*
</li>
<li>/
</li>
<li>not
</li>
<li>&gt;
</li>
<li>&lt;
</li>
<li>&gt;=
</li>
<li>&lt;=
</li>
<li>=
</li>
<li>equal?
</li>
<li>eq?
</li>
<li>length
</li>
<li>cons
</li>
<li>car
</li>
<li>cdr
</li>
<li>append
</li>
<li>list
</li>
<li>list?
</li>
<li>null?
</li>
<li>symbol?
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Read</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">Tokenizer</h4>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Atom</h3>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Базовые типы</h2>
<div class="outline-text-2" id="text-4">
<p>
Итак мы имеем следующие базовые типы данных:
</p>
<ul class="org-ul">
<li>точечная пара,
</li>
<li>символ,
</li>
<li>число,
</li>
<li>строка (pascal style, т.к. это даст возможность хранения произвольных бинарных данных
в неизменном виде)
</li>
</ul>

<p>
(функции и макросы могут быть представлены обычными s-выражениями)
</p>

<p>
для удобства реализации добавлены 4 дополнительных типа:
</p>
<ul class="org-ul">
<li>функция,
</li>
<li>макрос,
</li>
<li>встроенная функция
</li>
<li>встроенный макрос.
</li>
</ul>

<p>
Итак, имеем следующую структуру для s-выражения:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>;

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *(*<span style="color: #228b22;">built_in</span>) (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span>*);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> {
    <span style="color: #a020f0;">enum</span> {
        <span style="color: #a0522d;">DOTTED_PAIR</span>, <span style="color: #a0522d;">STRING</span>, <span style="color: #a0522d;">SYMBOL</span>, <span style="color: #a0522d;">NUMBER</span>, <span style="color: #a0522d;">FUNCTION</span>, <span style="color: #a0522d;">MACRO</span>, <span style="color: #a0522d;">BUILT_IN_FUNCTION</span>, <span style="color: #a0522d;">BUILT_IN_MACRO</span>
    } <span style="color: #a0522d;">type</span>;
    <span style="color: #a020f0;">union</span> {
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">first</span>, *<span style="color: #a0522d;">rest</span>;
        } <span style="color: #a0522d;">pair</span>;
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">ptr</span>;
            <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
        } <span style="color: #a0522d;">string</span>;
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>;
        } <span style="color: #a0522d;">function</span>;
        <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>;
        <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>;
        <span style="color: #228b22;">built_in</span> <span style="color: #a0522d;">built_in</span>;
    } <span style="color: #a0522d;">u</span>;
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">next</span>;
};
</pre>
</div>

<p>
На базе вышеприведённой структуры s-выражения легко построить функцию его вычисления:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_s_expr</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">first</span>, *<span style="color: #a0522d;">in</span> = expr;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">benv</span>;

    trace_put(<span style="color: #8b2252;">"%s -&gt; ..."</span>, in, <span style="color: #008b8b;">NULL</span>, env);

    <span style="color: #a020f0;">if</span> (expr)
        <span style="color: #a020f0;">if</span> (expr-&gt;type == SYMBOL)
            <span style="color: #a020f0;">if</span> (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            <span style="color: #a020f0;">else</span>
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            <span style="color: #a020f0;">if</span> (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

            expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

            <span style="color: #a020f0;">if</span> (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                  first-&gt;u.function.env, pos);

                expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                <span style="color: #a020f0;">if</span> (first-&gt;type == MACRO) {
                    trace_put(<span style="color: #8b2252;">"%s ~&gt; %s"</span>, in, expr, env);
                    expr = eval_s_expr(expr, env, pos);
                }
            }
            <span style="color: #a020f0;">else</span>
                expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put(<span style="color: #8b2252;">"%s -&gt; %s"</span>, in, expr, env);

    <span style="color: #a020f0;">return</span> expr;
}
</pre>
</div>

<p>
Если вычислимое выражение является символом, мы просто ищем его значение в текущем
лексическом окружении (find<sub>symbol</sub>). Если вызов функции: вначале вычисляем фактические
параметры, используя текущее лексическое окружение (map<sub>eval</sub>), затем привязываем их к
символам формальных параметров (apply<sub>args</sub>) уже в лексическом окружении самой
функции. Далее последовательно вычисляем элементы тела на основе полученного
лексического окружения, возвращая значение последнего выражения (eval<sub>list</sub>). Для вызова
макроса порядок вычисления несколько иной. Фактические параметры не вычисляются, а
передаются в неизменном виде. Кроме того, результирующее выражение макроса
(макроподстановка) подвергается дополнительному вычислению. Числа, строки, функции и
макросы вычисляются сами в себя.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Полный текст си-части</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;ctype.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;float.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">LINE_COMMENT_CHAR</span> <span style="color: #8b2252;">';'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BLOCK_COMMENT_CHAR1</span> <span style="color: #8b2252;">';'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BLOCK_COMMENT_CHAR2</span> <span style="color: #8b2252;">'|'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">LIST_OPEN_BRACE_CHAR</span> <span style="color: #8b2252;">'('</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">LIST_CLOSE_BRACE_CHAR</span> <span style="color: #8b2252;">')'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">LIST_DOT_CHAR</span> <span style="color: #8b2252;">'.'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STRING_DELIMITER_CHAR</span> <span style="color: #8b2252;">'"'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STRING_ESCAPE_CHAR</span> <span style="color: #8b2252;">'\\'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUMBER_PREFIX_CHAR</span> <span style="color: #8b2252;">'$'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUMBER_FORMAT_HEX_CHAR</span> <span style="color: #8b2252;">'h'</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUMBER_FORMAT_OCT_CHAR</span> <span style="color: #8b2252;">'o'</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NIL_SYMBOL_STR</span> <span style="color: #8b2252;">"_"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TRUE_SYMBOL_STR</span> <span style="color: #8b2252;">"t"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TRACE_SYMBOL_STR</span> <span style="color: #8b2252;">"trace"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">CAR_SYMBOL_STR</span> <span style="color: #8b2252;">"@"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">CDR_SYMBOL_STR</span> <span style="color: #8b2252;">"%"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">CONS_SYMBOL_STR</span> <span style="color: #8b2252;">"^"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">IF_SYMBOL_STR</span> <span style="color: #8b2252;">"?"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">LAMBDA_SYMBOL_STR</span> <span style="color: #8b2252;">"!"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MACRO_SYMBOL_STR</span> <span style="color: #8b2252;">"#"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SETQ_SYMBOL_STR</span> <span style="color: #8b2252;">"="</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">QUOTE_SYMBOL_STR</span> <span style="color: #8b2252;">"'"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">PLUS_SYMBOL_STR</span> <span style="color: #8b2252;">"+"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">GREATER_SYMBOL_STR</span> <span style="color: #8b2252;">"&gt;"</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">FUNCTION_STR_FORMAT</span> <span style="color: #8b2252;">"&lt;!%s&gt;"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MACRO_STR_FORMAT</span> <span style="color: #8b2252;">"&lt;#%s&gt;"</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">OUT_OF_MEMORY_MSG</span> <span style="color: #8b2252;">"out of memory"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">UNEXPECTED_EOF_MSG</span> <span style="color: #8b2252;">"unexpected end of file"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BAD_SYNTAX_MSG</span> <span style="color: #8b2252;">"bad syntax"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NON_FUNC_MACRO_MSG</span> <span style="color: #8b2252;">"expression %s is neither a function nor a macro"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NON_NONEMPTY_LIST_MSG</span> <span style="color: #8b2252;">"expression %s is not a nonempty list"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NON_LIST_MSG</span> <span style="color: #8b2252;">"expression %s is not a proper list"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">UNBOUND_SYMBOL_MSG</span> <span style="color: #8b2252;">"unbound symbol %s"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BAD_FORMAL_ARGS_MSG</span> <span style="color: #8b2252;">"bad formal arguments %s"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BAD_ACTUAL_ARGS_MSG</span> <span style="color: #8b2252;">"bad actual arguments %s"</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STRING_OVERFLOW_MSG</span> <span style="color: #8b2252;">"string size overflow"</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NUMBER_LENGTH_MAX</span> 32
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">SYMBOL_LENGTH_MAX</span> 32
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STRING_LENGTH_MAX</span> 256
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">S_EXPR_LENGTH_MAX</span> 1024

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">filename</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">line</span>, <span style="color: #a0522d;">chr</span>;
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>;

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *(*<span style="color: #228b22;">built_in</span>) (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>*,
                                    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span>*);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> {
    <span style="color: #a020f0;">enum</span> {
        <span style="color: #a0522d;">DOTTED_PAIR</span>, <span style="color: #a0522d;">STRING</span>, <span style="color: #a0522d;">SYMBOL</span>, <span style="color: #a0522d;">NUMBER</span>, <span style="color: #a0522d;">FUNCTION</span>, <span style="color: #a0522d;">MACRO</span>,
        <span style="color: #a0522d;">BUILT_IN_FUNCTION</span>, <span style="color: #a0522d;">BUILT_IN_MACRO</span>
    } <span style="color: #a0522d;">type</span>;
    <span style="color: #a020f0;">union</span> {
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">first</span>, *<span style="color: #a0522d;">rest</span>;
        } <span style="color: #a0522d;">pair</span>;
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">ptr</span>;
            <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
        } <span style="color: #a0522d;">string</span>;
        <span style="color: #a020f0;">struct</span> {
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>;
        } <span style="color: #a0522d;">function</span>;
        <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>;
        <span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>;
        <span style="color: #228b22;">built_in</span> <span style="color: #a0522d;">built_in</span>;
    } <span style="color: #a0522d;">u</span>;
};

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">error</span>(<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">message</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">expr</span>) {
    <span style="color: #a020f0;">if</span> (pos)
        printf(<span style="color: #8b2252;">"Error at %s:%d:%d: "</span>, pos-&gt;filename, pos-&gt;line, pos-&gt;chr);
    <span style="color: #a020f0;">else</span>
        printf(<span style="color: #8b2252;">"Error: "</span>);
    <span style="color: #a020f0;">if</span> (expr)
        printf(message, expr);
    <span style="color: #a020f0;">else</span>
        printf(<span style="color: #8b2252;">"%s"</span>, message);
    puts(<span style="color: #8b2252;">""</span>);
    exit(1);
}

<span style="color: #228b22;">void</span> *<span style="color: #0000ff;">alloc_mem</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>) {
    <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">ptr</span> = malloc(size);
    <span style="color: #a020f0;">if</span> (!ptr)
        error(OUT_OF_MEMORY_MSG, <span style="color: #008b8b;">NULL</span>, <span style="color: #008b8b;">NULL</span>);
    <span style="color: #a020f0;">return</span> ptr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">true_</span> () {
    <span style="color: #a020f0;">static</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">if</span> (!expr) {
        expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
        expr-&gt;type = SYMBOL;
        expr-&gt;u.symbol = TRUE_SYMBOL_STR;
    }
    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_char</span>(<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span> = getc(file);
    <span style="color: #a020f0;">if</span> (chr == <span style="color: #8b2252;">'\n'</span>)
        pos-&gt;line++, pos-&gt;chr = 1;
    <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr != EOF)
        pos-&gt;chr++;
    <span style="color: #a020f0;">return</span> chr;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">next_char</span>(<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span> = getc(file);
    ungetc(chr, file);
    <span style="color: #a020f0;">return</span> chr;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_significant_char</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">enum</span> { <span style="color: #a0522d;">NO_COMMENT</span>, <span style="color: #a0522d;">LINE_COMMENT</span>, <span style="color: #a0522d;">BLOCK_COMMENT</span> } <span style="color: #a0522d;">state</span> = NO_COMMENT;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>;

    <span style="color: #a020f0;">while</span> (1) {
        chr = get_char(file, pos);
        <span style="color: #a020f0;">if</span> (state == NO_COMMENT) {
            <span style="color: #a020f0;">if</span> (chr == BLOCK_COMMENT_CHAR1 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR2) {
                get_char(file, pos);
                state = BLOCK_COMMENT;
                <span style="color: #a020f0;">continue</span>;
            }
            <span style="color: #a020f0;">if</span> (chr == LINE_COMMENT_CHAR)
                state = LINE_COMMENT;
            <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr != <span style="color: #8b2252;">' '</span> &amp;&amp; chr != <span style="color: #8b2252;">'\t'</span> &amp;&amp; chr != <span style="color: #8b2252;">'\r'</span> &amp;&amp; chr != <span style="color: #8b2252;">'\n'</span>)
                <span style="color: #a020f0;">return</span> chr;
        }
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (state == BLOCK_COMMENT) {
            <span style="color: #a020f0;">if</span> (chr == BLOCK_COMMENT_CHAR2 &amp;&amp;
                next_char(file) == BLOCK_COMMENT_CHAR1) {
                get_char(file, pos);
                state = NO_COMMENT;
            }
            <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == EOF)
                error(UNEXPECTED_EOF_MSG, pos, <span style="color: #008b8b;">NULL</span>);
        }
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (state == LINE_COMMENT) {
            <span style="color: #a020f0;">if</span> (chr == <span style="color: #8b2252;">'\n'</span>)
                state = NO_COMMENT;
            <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == EOF)
                <span style="color: #a020f0;">return</span> EOF;
        }
    }
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_s_expr</span> (<span style="color: #228b22;">FILE</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span>*);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_list</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>, *<span style="color: #a0522d;">rest</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>;

    chr = get_significant_char(file, pos);
    <span style="color: #a020f0;">if</span> (chr == LIST_CLOSE_BRACE_CHAR)
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;

    ungetc(chr, file);
    pos-&gt;chr--;
    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = parse_s_expr(file, pos);
    rest = expr;

    <span style="color: #a020f0;">while</span> (1) {
        chr = get_significant_char(file, pos);
        <span style="color: #a020f0;">if</span> (chr == LIST_DOT_CHAR) {
            rest-&gt;u.pair.rest = parse_s_expr(file, pos);
            <span style="color: #a020f0;">if</span> (get_significant_char(file, pos) != LIST_CLOSE_BRACE_CHAR)
                error(BAD_SYNTAX_MSG, pos, <span style="color: #008b8b;">NULL</span>);
            <span style="color: #a020f0;">break</span>;
        }
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == LIST_CLOSE_BRACE_CHAR) {
            rest-&gt;u.pair.rest = <span style="color: #008b8b;">NULL</span>;
            <span style="color: #a020f0;">break</span>;
        }
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, <span style="color: #008b8b;">NULL</span>);
        <span style="color: #a020f0;">else</span> {
            ungetc(chr, file);
            pos-&gt;chr--;
            rest-&gt;u.pair.rest = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
            rest-&gt;u.pair.rest-&gt;type = DOTTED_PAIR;
            rest-&gt;u.pair.rest-&gt;u.pair.first = parse_s_expr(file, pos);
            rest = rest-&gt;u.pair.rest;
        }
    }

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">read_escape_seq</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">buf</span>) {
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">TODO: add support for escape sequences </span><span style="color: #b22222;">*/</span>

}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_string</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buf</span>[STRING_LENGTH_MAX];
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>, <span style="color: #a0522d;">i</span> = 0;

    <span style="color: #a020f0;">while</span> (i &lt; STRING_LENGTH_MAX) {
        chr = get_char(file, pos);
        <span style="color: #a020f0;">if</span> (chr == STRING_ESCAPE_CHAR)
            read_escape_seq(file, pos, buf);
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == STRING_DELIMITER_CHAR)
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (chr == EOF)
            error(UNEXPECTED_EOF_MSG, pos, <span style="color: #008b8b;">NULL</span>);
        <span style="color: #a020f0;">else</span>
            buf[i++] = chr;
    }

    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = STRING;
    expr-&gt;u.string.ptr = i ? alloc_mem(i) : <span style="color: #008b8b;">NULL</span>;
    memcpy(expr-&gt;u.string.ptr, buf, i);
    expr-&gt;u.string.size = i;

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">read_double</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">buf</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>, <span style="color: #a0522d;">i</span> = 0, <span style="color: #a0522d;">point</span> = -1;

    chr = next_char(file);
    <span style="color: #a020f0;">if</span> (chr == <span style="color: #8b2252;">'+'</span> || chr == <span style="color: #8b2252;">'-'</span>) {
        get_char(file, pos);
        buf[i++] = chr;
    }

    <span style="color: #a020f0;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    <span style="color: #a020f0;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; next_char(file) == <span style="color: #8b2252;">'.'</span>)
        buf[point = i++] = get_char(file, pos);

    <span style="color: #a020f0;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
        buf[i++] = get_char(file, pos);

    chr = next_char(file);
    <span style="color: #a020f0;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == <span style="color: #8b2252;">'e'</span> || chr == <span style="color: #8b2252;">'E'</span>) &amp;&amp; i &gt; point + 1) {
        get_char(file, pos);
        buf[i++] = chr;

        chr = next_char(file);
        <span style="color: #a020f0;">if</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == <span style="color: #8b2252;">'+'</span> || chr == <span style="color: #8b2252;">'-'</span>)) {
            get_char(file, pos);
            buf[i++] = chr;
        }

        <span style="color: #a020f0;">while</span> (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file)))
            buf[i++] = get_char(file, pos);
    }

    <span style="color: #a020f0;">if</span> (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #a020f0;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #008b8b;">NULL</span>);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">read_int</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">base</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">buf</span>) {
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>, <span style="color: #a0522d;">i</span> = 0;

    assert(base == 8 || base == 16);

    <span style="color: #a020f0;">for</span> (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        <span style="color: #a020f0;">if</span> ((base == 16 &amp;&amp; isxdigit(chr)) || (chr &gt;= <span style="color: #8b2252;">'0'</span> &amp;&amp; chr &lt;= <span style="color: #8b2252;">'7'</span>))
            buf[i++] = chr;
        <span style="color: #a020f0;">else</span>
            <span style="color: #a020f0;">break</span>;
    }

    <span style="color: #a020f0;">if</span> (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #a020f0;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #008b8b;">NULL</span>);
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_number</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buf</span>[NUMBER_LENGTH_MAX + 1];
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">inum</span>;

    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = NUMBER;

    <span style="color: #a020f0;">switch</span> (next_char(file)) {
    <span style="color: #a020f0;">case</span> NUMBER_FORMAT_HEX_CHAR:
        get_char(file, pos);
        read_int(file, pos, 16, buf);
        sscanf(buf, <span style="color: #8b2252;">"%x"</span>, &amp;inum);
        expr-&gt;u.number = inum;
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> NUMBER_FORMAT_OCT_CHAR:
        get_char(file, pos);
        read_int(file, pos, 8, buf);
        sscanf(buf, <span style="color: #8b2252;">"%o"</span>, &amp;inum);
        expr-&gt;u.number = inum;
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">default</span>:
        read_double(file, pos, buf);
        sscanf(buf, <span style="color: #8b2252;">"%lf"</span>, &amp;expr-&gt;u.number);
        <span style="color: #a020f0;">break</span>;
    }

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_symbol</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buf</span>[NUMBER_LENGTH_MAX + 1];
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>, <span style="color: #a0522d;">chr2</span>, <span style="color: #a0522d;">i</span> = 0;

    <span style="color: #a020f0;">for</span> (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) {
        chr = next_char(file);
        <span style="color: #a020f0;">if</span> (chr == BLOCK_COMMENT_CHAR1) {
            get_char(file, pos);
            chr2 = next_char(file);
            ungetc(chr2, file);
            pos-&gt;chr--;

            <span style="color: #a020f0;">if</span> (chr2 == BLOCK_COMMENT_CHAR2)
                <span style="color: #a020f0;">break</span>;
        }
        <span style="color: #a020f0;">if</span> (chr &gt;= <span style="color: #8b2252;">'!'</span> &amp;&amp; chr &lt;= <span style="color: #8b2252;">'~'</span> &amp;&amp; chr != LINE_COMMENT_CHAR &amp;&amp;
                    chr != LIST_OPEN_BRACE_CHAR &amp;&amp; chr != LIST_CLOSE_BRACE_CHAR &amp;&amp;
                    chr != LIST_DOT_CHAR &amp;&amp; chr != STRING_DELIMITER_CHAR &amp;&amp;
            chr != NUMBER_PREFIX_CHAR)
            buf[i++] = chr;
        <span style="color: #a020f0;">else</span>
            <span style="color: #a020f0;">break</span>;
    }

    <span style="color: #a020f0;">if</span> (i &amp;&amp; i &lt; SYMBOL_LENGTH_MAX)
        buf[i] = 0;
    <span style="color: #a020f0;">else</span>
        error(BAD_SYNTAX_MSG, pos, <span style="color: #008b8b;">NULL</span>);

    <span style="color: #a020f0;">if</span>(!strcmp(buf, NIL_SYMBOL_STR))
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">if</span>(!strcmp(buf, TRUE_SYMBOL_STR))
        <span style="color: #a020f0;">return</span> true_();

    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = SYMBOL;
    expr-&gt;u.symbol = alloc_mem(i + 1);
    strcpy(expr-&gt;u.symbol, buf);

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">parse_s_expr</span> (<span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>;

    chr = get_significant_char(file, pos);

    <span style="color: #a020f0;">switch</span> (chr) {
    <span style="color: #a020f0;">case</span> EOF:
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">case</span> LIST_OPEN_BRACE_CHAR:
        expr = parse_list(file, pos);
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> STRING_DELIMITER_CHAR:
        expr = parse_string(file, pos);
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">case</span> NUMBER_PREFIX_CHAR:
        expr = parse_number(file, pos);
        <span style="color: #a020f0;">break</span>;
    <span style="color: #a020f0;">default</span>:
        ungetc(chr, file);
        pos-&gt;chr--;
        expr = parse_symbol(file, pos);
        <span style="color: #a020f0;">break</span>;
    }

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">next</span>;
};

<span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">do_trace</span> = 0;

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">s_expr_string</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>*);

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">trace_put</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">format</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr1</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr2</span>,
                <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #a020f0;">if</span> (do_trace) {
        printf(<span style="color: #8b2252;">"Trace: "</span>);
        printf(format, s_expr_string(expr1, env), s_expr_string(expr2, env));
        puts(<span style="color: #8b2252;">""</span>);
    }
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #0000ff;">add_symbol</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>,
                          <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">append</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">new_env</span>;
    new_env = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*new_env));
    new_env-&gt;symbol = symbol, new_env-&gt;expr = expr;
    <span style="color: #a020f0;">if</span> (append)
        env-&gt;next = new_env, new_env-&gt;next = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">else</span>
        new_env-&gt;next = env;
    <span style="color: #a020f0;">return</span> new_env;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> * <span style="color: #0000ff;">add_built_in</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">macro</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>, <span style="color: #228b22;">built_in</span> <span style="color: #a0522d;">bi</span>,
                             <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span> = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = macro ? BUILT_IN_MACRO : BUILT_IN_FUNCTION;
    expr-&gt;u.built_in = bi;
    <span style="color: #a020f0;">return</span> add_symbol(symbol, expr, env, 0);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">find_symbol</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> **<span style="color: #a0522d;">env</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">next</span> = *env;
    <span style="color: #a020f0;">for</span> (; next; *env = next, next = next-&gt;next)
        <span style="color: #a020f0;">if</span> (!strcmp(symbol, next-&gt;symbol)) {
            *env = next;
            <span style="color: #a020f0;">return</span> 1;
        }
    <span style="color: #a020f0;">return</span> 0;
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">str_cat</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">dest</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">dest_size</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">src</span>) {
    <span style="color: #a020f0;">if</span> (strlen(src) &gt; dest_size - 1 - strlen(dest))
        error(STRING_OVERFLOW_MSG, <span style="color: #008b8b;">NULL</span>, <span style="color: #008b8b;">NULL</span>);
    <span style="color: #a020f0;">return</span> strcat(dest, src);
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">list_string</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">list</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">buf</span>[S_EXPR_LENGTH_MAX + 1] = { LIST_OPEN_BRACE_CHAR, 0 };
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">psep</span>[] = { <span style="color: #8b2252;">' '</span>, LIST_DOT_CHAR, <span style="color: #8b2252;">' '</span>, 0 };
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">cbrc</span>[] = { LIST_CLOSE_BRACE_CHAR, 0 };

    <span style="color: #a020f0;">for</span> (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        <span style="color: #a020f0;">if</span> (buf[1])
            str_cat(buf, S_EXPR_LENGTH_MAX + 1, <span style="color: #8b2252;">" "</span>);
        str_cat(buf, S_EXPR_LENGTH_MAX + 1,
                s_expr_string(list-&gt;u.pair.first, env));
    }

    <span style="color: #a020f0;">if</span> (list)
        str_cat(str_cat(buf, S_EXPR_LENGTH_MAX + 1, psep),
                S_EXPR_LENGTH_MAX + 1, s_expr_string(list, env));

    str_cat(buf, S_EXPR_LENGTH_MAX + 1, cbrc);

    <span style="color: #a020f0;">return</span> strcpy(alloc_mem(strlen(buf) + 1), buf);
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">string_string</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">ptr</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>) {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span> = alloc_mem(size + 3);
    str[0] = str[size + 1] = <span style="color: #8b2252;">'"'</span>;
    memcpy(str + 1, ptr, size);
    str[size + 2] = 0;
    <span style="color: #a020f0;">return</span> str;
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">number_string</span> (<span style="color: #228b22;">double</span> <span style="color: #a0522d;">number</span>) {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span> = alloc_mem(NUMBER_LENGTH_MAX + 2);
    str[0] = NUMBER_PREFIX_CHAR;
    sprintf(str + 1, <span style="color: #8b2252;">"%g"</span>, number);
    <span style="color: #a020f0;">return</span> str;
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">function_string</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">macro</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span>;

    <span style="color: #a020f0;">for</span> (; env; env = env-&gt;next)
        <span style="color: #a020f0;">if</span> (env-&gt;expr == expr)
            <span style="color: #a020f0;">break</span>;

    str = alloc_mem((macro ? <span style="color: #a020f0;">sizeof</span>(MACRO_STR_FORMAT) :
                     <span style="color: #a020f0;">sizeof</span>(FUNCTION_STR_FORMAT)) +
                    (env ? strlen(env-&gt;symbol) : 0) - 1);

    sprintf(str, macro ? MACRO_STR_FORMAT : FUNCTION_STR_FORMAT,
            env ? env-&gt;symbol : <span style="color: #8b2252;">""</span>);

    <span style="color: #a020f0;">return</span> str;
}

<span style="color: #228b22;">char</span> *<span style="color: #0000ff;">s_expr_string</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #a020f0;">if</span> (!expr)
        <span style="color: #a020f0;">return</span> NIL_SYMBOL_STR;

    <span style="color: #a020f0;">switch</span> (expr-&gt;type) {
    <span style="color: #a020f0;">case</span> DOTTED_PAIR:
        <span style="color: #a020f0;">return</span> list_string(expr, env);
    <span style="color: #a020f0;">case</span> STRING:
        <span style="color: #a020f0;">return</span> string_string(expr-&gt;u.string.ptr, expr-&gt;u.string.size);
    <span style="color: #a020f0;">case</span> SYMBOL:
        <span style="color: #a020f0;">return</span> expr-&gt;u.symbol;
    <span style="color: #a020f0;">case</span> NUMBER:
        <span style="color: #a020f0;">return</span> number_string(expr-&gt;u.number);
    <span style="color: #a020f0;">case</span> FUNCTION:
    <span style="color: #a020f0;">case</span> BUILT_IN_FUNCTION:
        <span style="color: #a020f0;">return</span> function_string(expr, 0, env);
    <span style="color: #a020f0;">case</span> MACRO:
    <span style="color: #a020f0;">case</span> BUILT_IN_MACRO:
        <span style="color: #a020f0;">return</span> function_string(expr, 1, env);
    <span style="color: #a020f0;">default</span>:
        assert(0);
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">proper_listp</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>) {
    <span style="color: #a020f0;">while</span> (expr &amp;&amp; expr-&gt;type == DOTTED_PAIR)
        expr = expr-&gt;u.pair.rest;
    <span style="color: #a020f0;">return</span> expr == <span style="color: #008b8b;">NULL</span>;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">search_symbol</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">list</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">symbol</span>) {
    <span style="color: #a020f0;">for</span> (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) {
        assert(list-&gt;u.pair.first-&gt;type == SYMBOL);
        <span style="color: #a020f0;">if</span> (!strcmp(list-&gt;u.pair.first-&gt;u.symbol, symbol))
            <span style="color: #a020f0;">return</span> list;
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">check_fargs</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">fargs</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = fargs;

    <span style="color: #a020f0;">if</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp;
        !rest-&gt;u.pair.first &amp;&amp; rest-&gt;u.pair.rest-&gt;type == SYMBOL)
        <span style="color: #a020f0;">return</span>;

    <span style="color: #a020f0;">for</span> (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        <span style="color: #a020f0;">if</span> (!rest-&gt;u.pair.first || rest-&gt;u.pair.first-&gt;type != SYMBOL ||
            search_symbol(fargs, rest-&gt;u.pair.first-&gt;u.symbol) != rest)
            error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));

    <span style="color: #a020f0;">if</span> (rest &amp;&amp; (rest-&gt;type != SYMBOL || search_symbol(fargs, rest-&gt;u.symbol)))
        error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env));
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">check_aargs</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">count</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">va</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = args;

    <span style="color: #a020f0;">for</span> (; count &amp;&amp; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; count--)
        rest = rest-&gt;u.pair.rest;

    <span style="color: #a020f0;">if</span> (count || (!va &amp;&amp; rest) || !proper_listp(rest))
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_list</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span>*);
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_s_expr</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span>*, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span>*);

<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ARG1</span>(<span style="color: #a0522d;">args</span>) args-&gt;u.pair.first
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ARG2</span>(<span style="color: #a0522d;">args</span>) args-&gt;u.pair.rest-&gt;u.pair.first
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ARG3</span>(<span style="color: #a0522d;">args</span>) args-&gt;u.pair.rest-&gt;u.pair.rest-&gt;u.pair.first

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">trace</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                      <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    do_trace = 1;
    expr = eval_list(args, env, pos);
    do_trace = 0;
    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">quote</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                      <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    check_aargs(args, 1, 0, env, pos);
    <span style="color: #a020f0;">return</span> ARG1(args);
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">car</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    check_aargs(args, 1, 0, env, pos);
    <span style="color: #a020f0;">if</span> (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env));
    <span style="color: #a020f0;">return</span> ARG1(args) ? ARG1(args)-&gt;u.pair.first : <span style="color: #008b8b;">NULL</span>;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">cdr</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    check_aargs(args, 1, 0, env, pos);
    <span style="color: #a020f0;">if</span> (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR)
        error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env));
    <span style="color: #a020f0;">return</span> ARG1(args) ? ARG1(args)-&gt;u.pair.rest : <span style="color: #008b8b;">NULL</span>;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">cons</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                     <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    check_aargs(args, 2, 0, env, pos);
    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = DOTTED_PAIR;
    expr-&gt;u.pair.first = ARG1(args);
    expr-&gt;u.pair.rest = ARG2(args);
    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">if_</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    check_aargs(args, 3, 0, env, pos);
    <span style="color: #a020f0;">return</span> eval_s_expr(ARG1(args), env, pos) ?
        eval_s_expr(ARG2(args), env, pos) :
        eval_s_expr(ARG3(args), env, pos);
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">function</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                         <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">macro</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    check_aargs(args, 1, 1, env, pos);
    check_fargs(ARG1(args), env, pos);
    expr = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
    expr-&gt;type = macro ? MACRO : FUNCTION;
    expr-&gt;u.function.expr = args;
    expr-&gt;u.function.env = env;
    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">lambda</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                       <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">return</span> function(args, env, pos, 0);
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">macro</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                      <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">return</span> function(args, env, pos, 1);
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">setq</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                     <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = args, *<span style="color: #a0522d;">expr</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">senv</span>;

    <span style="color: #a020f0;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        <span style="color: #a020f0;">if</span> (ARG1(rest) &amp;&amp; ARG1(rest)-&gt;type == SYMBOL &amp;&amp;
            rest-&gt;u.pair.rest &amp;&amp; rest-&gt;u.pair.rest-&gt;type == DOTTED_PAIR) {
            expr = eval_s_expr(ARG2(rest), env, pos), senv = env;
            <span style="color: #a020f0;">if</span> (find_symbol(ARG1(rest)-&gt;u.symbol, &amp;senv)) {
                trace_put(<span style="color: #8b2252;">"%s =&gt; %s [assign]"</span>, expr, ARG1(rest), env);
                senv-&gt;expr = expr;
            }
            <span style="color: #a020f0;">else</span> {
                trace_put(<span style="color: #8b2252;">"%s =&gt; %s [global]"</span>, expr, ARG1(rest), env);
                add_symbol(ARG1(rest)-&gt;u.symbol, expr, senv, 1);
            }
        }
        <span style="color: #a020f0;">else</span>
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        rest = rest-&gt;u.pair.rest-&gt;u.pair.rest;
    }

    <span style="color: #a020f0;">if</span> (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">plus</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                     <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = args;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">sum</span> = 0;

    <span style="color: #a020f0;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp; ARG1(rest)-&gt;type == NUMBER)
        sum += ARG1(rest)-&gt;u.number, rest = rest-&gt;u.pair.rest;

    <span style="color: #a020f0;">if</span> (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    rest = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*rest));
    rest-&gt;type = NUMBER;
    rest-&gt;u.number = sum;
    <span style="color: #a020f0;">return</span> rest;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">greater</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">args</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                        <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = args, *<span style="color: #a0522d;">num</span>;
    <span style="color: #228b22;">double</span> <span style="color: #a0522d;">prev</span> = DBL_MAX;

    <span style="color: #a020f0;">while</span> (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) {
        num = eval_s_expr(ARG1(rest), env, pos);

        <span style="color: #a020f0;">if</span> (!num || num-&gt;type != NUMBER)
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

        <span style="color: #a020f0;">if</span> (prev - num-&gt;u.number &lt; DBL_EPSILON)
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;

        prev = num-&gt;u.number, rest = rest-&gt;u.pair.rest;
    }

    <span style="color: #a020f0;">if</span> (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env));

    <span style="color: #a020f0;">return</span> true_();
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #0000ff;">create_env</span> () {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span> = <span style="color: #008b8b;">NULL</span>;
    env = add_built_in(1, TRACE_SYMBOL_STR, trace, env);
    env = add_built_in(1, QUOTE_SYMBOL_STR, quote, env);
    env = add_built_in(0, CAR_SYMBOL_STR, car, env);
    env = add_built_in(0, CDR_SYMBOL_STR, cdr, env);
    env = add_built_in(0, CONS_SYMBOL_STR, cons, env);
    env = add_built_in(1, IF_SYMBOL_STR, if_, env);
    env = add_built_in(1, LAMBDA_SYMBOL_STR, lambda, env);
    env = add_built_in(1, MACRO_SYMBOL_STR, macro, env);
    env = add_built_in(1, SETQ_SYMBOL_STR, setq, env);
    env = add_built_in(0, PLUS_SYMBOL_STR, plus, env);
    env = add_built_in(1, GREATER_SYMBOL_STR, greater, env);
    <span style="color: #a020f0;">return</span> env;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">map_eval</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">list</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                         <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span> = <span style="color: #008b8b;">NULL</span>, *<span style="color: #a0522d;">rest</span>;

    <span style="color: #a020f0;">while</span> (list) {
        <span style="color: #a020f0;">if</span> (list-&gt;type != DOTTED_PAIR)
            error(NON_LIST_MSG, pos, s_expr_string(list, env));
        <span style="color: #a020f0;">if</span> (expr) {
            rest-&gt;u.pair.rest = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
            rest = rest-&gt;u.pair.rest;
        }
        <span style="color: #a020f0;">else</span>
            expr = rest = alloc_mem(<span style="color: #a020f0;">sizeof</span>(*expr));
        rest-&gt;type = DOTTED_PAIR;
        rest-&gt;u.pair.first = eval_s_expr(list-&gt;u.pair.first, env, pos);
        list = list-&gt;u.pair.rest;
    }

    <span style="color: #a020f0;">if</span> (expr)
        rest-&gt;u.pair.rest = <span style="color: #008b8b;">NULL</span>;

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #0000ff;">apply_args</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">fargs</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">aargs</span>,
                          <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">rest</span> = aargs;

    <span style="color: #a020f0;">if</span> (!fargs || fargs-&gt;u.pair.first)
        <span style="color: #a020f0;">while</span> (fargs &amp;&amp; fargs-&gt;type == DOTTED_PAIR) {
            <span style="color: #a020f0;">if</span> (!rest || rest-&gt;type != DOTTED_PAIR)
                error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
            assert(fargs-&gt;u.pair.first-&gt;type == SYMBOL);
            trace_put(<span style="color: #8b2252;">"%s =&gt; %s [local]"</span>, rest-&gt;u.pair.first,
                      fargs-&gt;u.pair.first, env);
            env = add_symbol(fargs-&gt;u.pair.first-&gt;u.symbol,
                             rest-&gt;u.pair.first, env, 0);
            fargs = fargs-&gt;u.pair.rest, rest = rest-&gt;u.pair.rest;
        }
    <span style="color: #a020f0;">else</span>
        fargs = fargs-&gt;u.pair.rest;

    <span style="color: #a020f0;">if</span> (fargs) {
        assert(fargs-&gt;type == SYMBOL);
        <span style="color: #a020f0;">if</span> (rest &amp;&amp; !proper_listp(rest))
            error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));
        trace_put(<span style="color: #8b2252;">"%s =&gt; %s [local]"</span>, rest, fargs, env);
        env = add_symbol(fargs-&gt;u.symbol, rest, env, 0);
    }
    <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (rest)
        error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env));

    <span style="color: #a020f0;">return</span> env;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_list</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">list</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                          <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span> = <span style="color: #008b8b;">NULL</span>, *<span style="color: #a0522d;">rest</span> = list;

    <span style="color: #a020f0;">for</span> (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest)
        expr = eval_s_expr(rest-&gt;u.pair.first, env, pos);

    <span style="color: #a020f0;">if</span> (rest)
        error(NON_LIST_MSG, pos, s_expr_string(list, env));

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_s_expr</span> (<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>,
                            <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> *<span style="color: #a0522d;">pos</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">first</span>, *<span style="color: #a0522d;">in</span> = expr;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">benv</span>;

    trace_put(<span style="color: #8b2252;">"%s -&gt; ..."</span>, in, <span style="color: #008b8b;">NULL</span>, env);

    <span style="color: #a020f0;">if</span> (expr)
        <span style="color: #a020f0;">if</span> (expr-&gt;type == SYMBOL)
            <span style="color: #a020f0;">if</span> (find_symbol(expr-&gt;u.symbol, &amp;env))
                expr = env-&gt;expr;
            <span style="color: #a020f0;">else</span>
                error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol);
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (expr-&gt;type == DOTTED_PAIR) {
            first = eval_s_expr(expr-&gt;u.pair.first, env, pos);

            <span style="color: #a020f0;">if</span> (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL ||
                first-&gt;type == STRING || first-&gt;type == NUMBER)
                error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env));

                  expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ?
                      map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest;

                  <span style="color: #a020f0;">if</span> (first-&gt;type == FUNCTION || first-&gt;type == MACRO) {
                      assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR);

                      benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr,
                                        first-&gt;u.function.env, pos);

                      expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos);

                      <span style="color: #a020f0;">if</span> (first-&gt;type == MACRO) {
                          trace_put(<span style="color: #8b2252;">"%s ~&gt; %s"</span>, in, expr, env);
                          expr = eval_s_expr(expr, env, pos);
                      }
                  }
                  <span style="color: #a020f0;">else</span>
                      expr = first-&gt;u.built_in(expr, env, pos);
        }

    trace_put(<span style="color: #8b2252;">"%s -&gt; %s"</span>, in, expr, env);

    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #0000ff;">eval_file</span> (<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">filename</span>, <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">file_pos</span> <span style="color: #a0522d;">pos</span>, <span style="color: #a0522d;">prev_pos</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">s_expr</span> *<span style="color: #a0522d;">expr</span>;
    <span style="color: #228b22;">FILE</span> *<span style="color: #a0522d;">file</span>;
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">chr</span>;

    file = fopen(filename, <span style="color: #8b2252;">"r"</span>);
    <span style="color: #a020f0;">if</span> (!file) {
        printf(<span style="color: #8b2252;">"Failed to open file '%s'\n"</span>, filename);
        exit(1);
    }

    pos.filename = filename, pos.line = pos.chr = 1;
    expr = <span style="color: #008b8b;">NULL</span>;

    <span style="color: #a020f0;">while</span> (1) {
        chr = get_significant_char(file, &amp;pos);
        <span style="color: #a020f0;">if</span> (chr == EOF)
            <span style="color: #a020f0;">break</span>;
        ungetc(chr, file);
        pos.chr--, prev_pos = pos;
        expr = eval_s_expr(parse_s_expr(file, &amp;pos), env, &amp;prev_pos);
    }

    fclose(file);
    <span style="color: #a020f0;">return</span> expr;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">argv</span>[]) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">l_env</span> *<span style="color: #a0522d;">env</span>;

    <span style="color: #a020f0;">if</span> (argc != 2) {
        puts(<span style="color: #8b2252;">"Usage: int source"</span>);
        exit(1);
    }

    env = create_env();
    puts(s_expr_string(eval_file(argv[1], env), env));

    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Лисп-часть</h2>
<div class="outline-text-2" id="text-6">
<p>
Я решил ввести более лаконичные названия для базовых и произвольных функций и
макросов. В классическом LISP (и, особенно, в Common Lisp) меня немного напрягает
многословность базовых примитивов. С одной стороны, я не хотел усложнять парсер, потому
quote и backquote синтаксис им не поддерживается, только скобочная нотация. С другой
стороны, стремился компенсировать избыточную скобочность широким использованием
специальных символов для лаконичности. Кому-то это покажется весьма спорным решением.
</p>

<p>
Имена я старался подбирать в соответствии с их ассоциативным рядом:
</p>

<p>
_ — заменяет nil
! — заменяет lambda
</p>
<p>
? — заменяет if с обязательным третим параметром
^ — заменяет cons
@ — заменяет car
% — заменяет cdr
= — заменяет setq
</p>


<p>
Соответственно, имена производных функций и макросов во многом стали производными от имён базовых:
</p>

<p>
!! — заменяет defun
## — заменяет defmacro
^^ — заменяет list
@% — заменяет cadr
%% — заменяет cddr
</p>
<pre class="example">
— заменяет let для одной переменной
</pre>
<p>
:: — заменяет let без избыточных скобок
&amp; — заменяет and
</p>
<table>


<colgroup>
<col  class="left">
</colgroup>
<tbody>
<tr>
<td class="left">— заменяет or</td>
</tr>
</tbody>
</table>

<p>
Теперь рассмотрим производные определения. Вначале определим базовые сокращения:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setq cadr (<span style="color: #a020f0;">lambda</span> (list) (car (cdr list))))
(setq cddr (<span style="color: #a020f0;">lambda</span> (list) (cdr (cdr list))))
(setq list (<span style="color: #a020f0;">lambda</span> (nil . elts) elts))

(setq defmacro (defmacro-anon (name fargs . body)
                   (list setq name (cons defmacro-anon (cons fargs body)))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defun</span> (name fargs . body)
  (list setq name (cons lambda (cons fargs body))))
</pre>
</div>

<p>
Обратите внимание на точечную нотацию списка формальных аргументов. Символ после
точки захватывает оставшиеся фактические параметры. Случай, когда все аргументы
необязательны, описывается специальной нотацией (nil . rest-args). Далее определим
классический map и два парных разбиения списка:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map</span> (func list)
  (<span style="color: #a020f0;">if</span> list (cons (func (car list)) (map func (cdr list))) nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pairs1</span> (list) <span style="color: #b22222;">; (a b c d) -&gt; ((a b) (b c) (c d))</span>
  (<span style="color: #a020f0;">if</span> (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pairs2</span> (list) <span style="color: #b22222;">; (a b c d) -&gt; ((a b) (c d))</span>
  (<span style="color: #a020f0;">if</span> list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))
</pre>
</div>

<p>
Определяем два варианта let
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">let</span> (name value . body) <span style="color: #b22222;">; simplified let</span>
  (list (cons lambda (cons (list name) body)) value))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">let</span> (vars . body) <span style="color: #b22222;">; let without redundant braces</span>
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))
</pre>
</div>

<p>
Классический reverse и левую свёртку
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reverse</span> (list)
  (<span style="color: #a020f0;">let</span> reverse+ nil
       (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reverse+</span> (list rlist)
         (<span style="color: #a020f0;">if</span> list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fold</span> (list func last) <span style="color: #b22222;">; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))</span>
  (<span style="color: #a020f0;">if</span> list (func (car list) (fold (cdr list) func last)) last))
</pre>
</div>

<p>
Теперь логические операторы на основе iflet
</p>

<div class="org-src-container">

<pre class="src src-lisp">(setq t (' t)) <span style="color: #b22222;">; true constant</span>
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">~</span> (bool) (<span style="color: #a020f0;">if</span> bool nil t)) <span style="color: #b22222;">; not</span>
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">and</span> (nil . bools) <span style="color: #b22222;">; and</span>
  (<span style="color: #a020f0;">let</span> and (<span style="color: #a020f0;">lambda</span> (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">or</span> (nil . bools) <span style="color: #b22222;">; or</span>
  (<span style="color: #a020f0;">let</span> or (<span style="color: #a020f0;">lambda</span> (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))
</pre>
</div>

<p>
И, наконец, операторы сравнения на основе встроенного &gt; (greater)let
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> defcmp (<span style="color: #a020f0;">lambda</span> (cmp)
              (defmacro-anon (nil . nums)
                  (<span style="color: #a020f0;">let</span> cmp+ (<span style="color: #a020f0;">lambda</span> (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (<span style="color: #a020f0;">lambda</span> (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (<span style="color: #a020f0;">lambda</span> (num1 num2) (list ~ (list &gt; num2 num1))))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">&lt;</span> (nil . nums) (cons &gt; (reverse nums)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">&lt;setq</span> (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>

<p>
Обратите внимание, что в последнем блоке определений явно используется замыкание.
</p>

<p>
Полный тест файла lib.l
</p>

<div class="org-src-container">

<pre class="src src-lisp"><span style="color: #b22222;">#|</span>
<span style="color: #b22222;">                                        ;</span>
<span style="color: #b22222;">Formal argument list notationlet</span>
<span style="color: #b22222;">  ([{arg1 [arg2 [arg3 ...]] or nil} [. args]])</span>

<span style="color: #b22222;">Number notationlet</span>
<span style="color: #b22222;">  ${double or ooctal or hhex} ; $4 $-2.2e3 $o376 $h7EF</span>

<span style="color: #b22222;">Built-in symbolslet</span>
<span style="color: #b22222;">  nil ; nil</span>

<span style="color: #b22222;">Built-in functionslet</span>
<span style="color: #b22222;">  car (list) ; car</span>
<span style="color: #b22222;">  cdr (list) ; cdr</span>
<span style="color: #b22222;">  cons (first rest) ; cons</span>
<span style="color: #b22222;">  + (nil . nums)</span>

<span style="color: #b22222;">Built-in macroslet</span>
<span style="color: #b22222;">  trace (nil . body)</span>
<span style="color: #b22222;">  ' (expr)</span>
<span style="color: #b22222;">  if (cond texpr fexpr) ; if with mandatory fexpr</span>
<span style="color: #b22222;">  lambda (args . body) ; lambda</span>
<span style="color: #b22222;">  defmacro-anon (args . body) ; creates anonymous macro</span>
<span style="color: #b22222;">  &gt; (nil . nums)</span>
<span style="color: #b22222;">or;</span>
<span style="color: #b22222;">|#</span>

(setq cadr (<span style="color: #a020f0;">lambda</span> (list) (car (cdr list)))) <span style="color: #b22222;">; cadr</span>
(setq cddr (<span style="color: #a020f0;">lambda</span> (list) (cdr (cdr list)))) <span style="color: #b22222;">; cddr</span>
(setq list (<span style="color: #a020f0;">lambda</span> (nil . elts) elts)) <span style="color: #b22222;">; list</span>

(setq defmacro (defmacro-anon (name fargs . body) <span style="color: #b22222;">; defmacro</span>
                   (list setq name (cons defmacro-anon (cons fargs body)))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defun</span> (name fargs . body) <span style="color: #b22222;">; defun</span>
  (list setq name (cons lambda (cons fargs body))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map</span> (func list)
  (<span style="color: #a020f0;">if</span> list (cons (func (car list)) (map func (cdr list))) nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pairs1</span> (list) <span style="color: #b22222;">; (a b c d) -&gt; ((a b) (b c) (c d))</span>
  (<span style="color: #a020f0;">if</span> (cdr list) (cons (list (car list) (cadr list)) (pairs1 (cdr list))) nil))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pairs2</span> (list) <span style="color: #b22222;">; (a b c d) -&gt; ((a b) (c d))</span>
  (<span style="color: #a020f0;">if</span> list (cons (list (car list) (cadr list)) (pairs2 (cddr list))) nil))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">let</span> (name value . body) <span style="color: #b22222;">; simplified let</span>
  (list (cons lambda (cons (list name) body)) value))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">let</span> (vars . body) <span style="color: #b22222;">; let without redundant braces</span>
  (setq vars (pairs2 vars))
  (cons (cons lambda (cons (map car vars) body)) (map cadr vars)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reverse</span> (list)
  (<span style="color: #a020f0;">let</span> reverse+ nil
       (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reverse+</span> (list rlist)
         (<span style="color: #a020f0;">if</span> list (reverse+ (cdr list) (cons (car list) rlist)) rlist))
       (reverse+ list nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fold</span> (list func last) <span style="color: #b22222;">; (fold (' (a b)) f l) &lt;setq&gt; (f a (f b l))</span>
  (<span style="color: #a020f0;">if</span> list (func (car list) (fold (cdr list) func last)) last))

(setq t (' t)) <span style="color: #b22222;">; true constant</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">~</span> (bool) (<span style="color: #a020f0;">if</span> bool nil t)) <span style="color: #b22222;">; not</span>

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">and</span> (nil . bools) <span style="color: #b22222;">; and</span>
  (<span style="color: #a020f0;">let</span> and (<span style="color: #a020f0;">lambda</span> (bool1 bool2) (list if bool1 (list if bool2 t nil) nil))
       (fold bools and t)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">or</span> (nil . bools) <span style="color: #b22222;">; or</span>
  (<span style="color: #a020f0;">let</span> or (<span style="color: #a020f0;">lambda</span> (bool1 bool2) (list if bool1 t (list if bool2 t nil)))
       (fold bools or nil)))

(<span style="color: #a020f0;">let</span> defcmp (<span style="color: #a020f0;">lambda</span> (cmp)
              (defmacro-anon (nil . nums)
                  (<span style="color: #a020f0;">let</span> cmp+ (<span style="color: #a020f0;">lambda</span> (pair bool)
                              (list and (cmp (car pair) (cadr pair)) bool))
                       (fold (pairs1 nums) cmp+ t))))
     (setq setqsetq (defcmp (<span style="color: #a020f0;">lambda</span> (num1 num2) (list and (list ~ (list &gt; num1 num2))
                                                      (list ~ (list &gt; num2 num1))))))
     (setq &gt;setq (defcmp (<span style="color: #a020f0;">lambda</span> (num1 num2) (list ~ (list &gt; num2 num1))))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">&lt;</span> (nil . nums) (cons &gt; (reverse nums)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">&lt;setq</span> (nil . nums) (cons &gt;setq (reverse nums)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Полезные ссылки</h2>
<div class="outline-text-2" id="text-7">
<p>
<a href="https://habrahabr.ru/post/115206/">https://habrahabr.ru/post/115206/</a>
</p>
</div>
</div>
</div>
</body>
</html>
