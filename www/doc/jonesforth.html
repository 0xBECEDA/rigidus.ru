<!DOCTYPE html>
<html>
<head>
<title>Минимальный Forth</title>
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="rigidus">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<h1 class="title">Минимальный Forth</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#unnumbered-1">Интро</a></li>
<li><a href="#unnumbered-2">Сборка</a></li>
<li><a href="#unnumbered-3">Внутреннее устройство Forth-машины</a>
<ul>
<li><a href="#unnumbered-4">Словарь</a></li>
<li><a href="#unnumbered-5">Прямой шитый код</a></li>
<li><a href="#unnumbered-6">Коссвенный шитый код</a></li>
<li><a href="#unnumbered-7">Интерпретатор и стек возвратов</a></li>
<li><a href="#unnumbered-8">Начинаем</a></li>
<li><a href="#unnumbered-9">Встроенные слова</a></li>
<li><a href="#unnumbered-10">Возвращение из форт-слов</a></li>
<li><a href="#unnumbered-11">Литералы</a></li>
<li><a href="#unnumbered-12">Память</a></li>
<li><a href="#unnumbered-13">Встроенные переменные</a></li>
<li><a href="#unnumbered-14">Встроенные константы</a></li>
<li><a href="#unnumbered-15">Стек возвратов</a></li>
<li><a href="#unnumbered-16">Стек параметров (данных)</a></li>
<li><a href="#unnumbered-17">Ввод и вывод</a></li>
<li><a href="#unnumbered-18">Просмотр словаря</a></li>
<li><a href="#unnumbered-19">Компиляция</a></li>
<li><a href="#unnumbered-20">Расширение компилятора</a></li>
<li><a href="#unnumbered-21">Ветвление</a></li>
<li><a href="#unnumbered-22">Строковые литералы</a></li>
<li><a href="#unnumbered-23">QUIT и INTERPRET</a></li>
<li><a href="#unnumbered-24">ODDS и ENDS</a></li>
<li><a href="#unnumbered-25">Сегмент данных</a></li>
</ul>
</li>
<li><a href="#unnumbered-26">Forth-код</a>
<ul>
<li><a href="#unnumbered-27">DIVMOD</a></li>
<li><a href="#unnumbered-28">Символьные константы</a></li>
<li><a href="#unnumbered-29">COMPILE</a></li>
<li><a href="#unnumbered-30">RECURSE</a></li>
<li><a href="#unnumbered-31">Управляющие выражения</a></li>
<li><a href="#unnumbered-32">Циклы</a>
<ul>
<li><a href="#unnumbered-33">BEGIN - UNTIL</a></li>
<li><a href="#unnumbered-34">BEGIN - AGAIN</a></li>
<li><a href="#unnumbered-35">BEGIN - WHILE - REPEAT</a></li>
</ul>
</li>
<li><a href="#unnumbered-36">Unless</a></li>
<li><a href="#unnumbered-37">Комментарии</a></li>
<li><a href="#unnumbered-38">Стековая нотация</a></li>
<li><a href="#unnumbered-39">Печать чисел</a></li>
<li><a href="#unnumbered-40">Еще полезные слова</a></li>
<li><a href="#unnumbered-41">Строки</a></li>
<li><a href="#unnumbered-42">Константы и переменные</a>
<ul>
<li><a href="#unnumbered-43">CONSTANT</a></li>
<li><a href="#unnumbered-44">VARIABLE</a></li>
</ul>
</li>
<li><a href="#unnumbered-45">VALUE</a></li>
<li><a href="#unnumbered-46">Печать словаря</a></li>
<li><a href="#unnumbered-47">Забывание</a></li>
<li><a href="#unnumbered-48">Дамп</a></li>
<li><a href="#unnumbered-49">Case</a></li>
<li><a href="#unnumbered-50">Декомпилятор</a></li>
<li><a href="#unnumbered-51">Токены выполнения</a></li>
<li><a href="#unnumbered-52">Исключения</a></li>
<li><a href="#unnumbered-53">Строки языка Си</a></li>
<li><a href="#unnumbered-54">Окружение</a></li>
<li><a href="#unnumbered-55">Системные вызовы и файлы</a></li>
<li><a href="#unnumbered-56">Заметка</a></li>
<li><a href="#unnumbered-57">Приветствие</a></li>
</ul>
</li>
<li><a href="#unnumbered-58">Резюме</a></li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Интро</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
Forth - один из тех инопланетных языков программирования, который большинство
программистов относят к категории странных, вроде Haskell, Lisp и.т.д. Настолько
странных, что они предпочли бы не думать об этом и продолжать писать код, за который им
платят. Но это, конечно неверно, и если вы настоящий программист, вы должны хотя бы
понимать этот язык, даже если вы никогда не будете его использовать.
</p>

<p>
Если вам не чуждо чувство прекрасного, и при достаточном везении, возможно вы сможете
даже полюбить его и тогда он откроет вам могущественные возможности и понимание
аспектов программирования, которые вы вряд-ли сможете найти в других языках.
</p>

<p>
<code>Lisp</code> является вершиной языков высокого уровня, и возможности из <code>Lisp</code> вот уже
десятки лет добавляются в более распространенные языки. Но Forth в этом смысле является
вершиной низкоуровневых языков. Из коробки у него нет возможностей вроде динамического
управления памятью и даже строк. Фактически, в его примитивном варианте отсутствуют
даже такие базовые концепции как IF-выражения и циклы.
</p>

<p>
Почему же тогда вы могли бы хотеть узнать Forth? На это есть несколько очень веских
причин:
</p>
<ul class="org-ul">
<li>Прежде всего, Forth минимален. Вы действительно можете написать Forth целиком в,
скажем, 2000 строк кода. Я имею в виду не только программу Forth, я имею в виду
полную "операционную систему" Forth, среду, и язык. Вы можете загружать такой Forth
на голом ПК, и он выдаст подсказку, командную строку, где вы можете начать делать
какую-то полезную работу. Forth, который написан ниже, не минимален и использует
Linux-процесс как его "базовый ПК" исключительно для обучающих целей). Это позволяет
полностью понять систему. Кто может сказать, что он полностью понимает, как работает
Linux, или gcc?
</li>
<li>Во-вторых, у Forth есть своеобразное свойство <code>bootstarp</code>-инга.. Под этим я
подразумеваю, что после написания небольшого ассемблерного кода, для общения с
оборудованием и реализации нескольких примитивов, весь остальной язык и компилятор
написан в самом Forth. Помните, я уже говорил, что Forth не хватает IF-выражений и
циклов? Конечно, на самом деле это не так, потому что такой язык был бы бесполезен,
но я имел в виду, что IF-утверждения и циклы написаны в самом Forth. Теперь, конечно,
это распространено и на других языках, и на этих языках мы называем это
"библиотеками". Например, в Си <code>printf</code> представляет собой библиотечную функцию,
написанную на Си. Но в Forth это выходит за рамки просто библиотек. Можете ли вы
представить, как написать на Cи <code>if</code>?
</li>
<li>И это подводит нас к третьей причине: если вы можете написать <code>if</code> в Forth, то зачем
ограничивать себя обычными конструкциями <code>if</code>, <code>while</code>, <code>for</code>, <code>switch</code>? Вам нужен
итератор по списку чисел? Вы можете добавить её в язык. Как насчет оператора, который
извлекает переменные непосредственно из файла конфигурации и делает их доступными как
переменные Forth? Или как насчет добавления языка зависимостей вроде <code>Makefile</code> к
языку? В Forth в этом нет проблем. Как насчет модификации компилятора Forth, чтобы
позволить сложные стратегии инлайнинга? - да легко! Эта концепция не распространена в
языках программирования, но имеет имя (на самом деле два имени): <code>макросы</code> (под
которыми я имею в виду макросы в стиле <code>Lisp</code>, а не хромой препроцессор Cи) и <code>языки
  предметной области</code> (Domain Specific Language - DSL). Иногда также встречается термин
Программирование, ориентированное на языки (Language Oriented Programming - LOP).
</li>
</ul>

<p>
Эта статья не посвящена изучению Forth как языка, здесь только рассказывается о том,
как написать Forth. Фактически, пока вы не поймете, как написан Forth, у вас будет
только очень поверхностное понимание того, как его использовать.
</p>
</div>
</div>

<div id="outline-container-unnumbered-2" class="outline-2">
<h2 id="unnumbered-2">Сборка</h2>
<div class="outline-text-2" id="text-unnumbered-2">
<p>
Если вы хотите запустить этот Forth, а не просто прочитать его, вам понадобится Linux
на процессоре не ниже i386. Linux, потому что вместо того, чтобы напрямую
программировать на на голом ПК (что вполне возможно), я использую более простое, для
учебных целей, предположение, о том, что "оборудование" - это процесс Linux с
несколькими базовыми системными вызовами (чтение, запись, выход, etc). i386
необходим, потому что мне пришлось написать немного кода на ассемблере, а i386 на
сегодняшний день является наиболее распространенным. Конечно, когда я говорю «i386»,
любой 32-разрядный или 64-разрядный процессор x86 подойдет. Я компилирую все это на
64-битном процессоре. Технически вы можете заменить весь ассемблер на какой-нибудь
другой host-язык в целях переносимости или по каким-либо иным соображениям.
</p>

<p>
Итак, чтобы собрать все это, вам понадобится <code>gcc</code> и <code>GAS</code> (GNU-ассемблер). Команды для
сборки и запуска кода (сохраните файл как 'jonesforth.S') такие:
</p>

<div class="org-src-container">

<pre class="src src-sh">gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
cat jonesforth.f - | ./jonesforth
</pre>
</div>

<p>
Если вы хотите запустить свои собственные программы Forth, вы можете:
</p>

<div class="org-src-container">

<pre class="src src-sh">cat jonesforth.f myprog.f | ./jonesforth
</pre>
</div>

<p>
Если вы хотите загрузить свой собственный код Forth, а затем продолжить чтение
пользовательских команд, вы можете сделать следующее:
</p>

<div class="org-src-container">

<pre class="src src-sh">cat jonesforth.f myfunctions.f - | ./jonesforth
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-2">
<h2 id="unnumbered-3">Внутреннее устройство Forth-машины</h2>
<div class="outline-text-2" id="text-unnumbered-3">
</div><div id="outline-container-unnumbered-4" class="outline-3">
<h3 id="unnumbered-4">Словарь</h3>
<div class="outline-text-3" id="text-unnumbered-4">
<p>
В Forth, как вы узнаете, функции называются «словами», и, так же, как и на других
языках, у них есть <code>имя</code> и <code>определение</code>. Вот два слова Forth:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE DUP + ;              <span style="color: #af0000;">\ &#1080;&#1084;&#1103;: "DOUBLE"     &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;: "DUP +"
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">QUADRUPLE </span>DOUBLE DOUBLE ;   <span style="color: #af0000;">\ &#1080;&#1084;&#1103;: "QUADRUPLE"  &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;: "DOUBLE DOUBLE"
</span>
</pre>
</div>

<p>
Слова, как встроенные, так и те, которые программист определяет позже, хранятся в
словаре, который является только связанным списком записей словаря.
</p>


<div class="figure">
<p><img src="../../img/forth-dict-list.png" alt="forth-dict-list.png">
</p>
</div>

<p>
Мы дойдем до определения слова позже. Сейчас просто посмотрите на его заголовок
(dictionary entry / header). Первые 4 байта - это указатель ссылки. Он указывает на
предыдущее слово в словаре, и для первого слова в словаре является указателем
<code>NULL</code>. Затем появляется байт длины/флагов. Длина слова может составлять до 31 символа
(используется 5 бит), а три верхних бита используются для различных флагов, про которые
я расскажу позже. За этим следует само имя, и в этой реализации имя всегда кратно 4
байтам, и первоначально заполнено нулевыми байтами. Это просто для того, чтобы
определение начиналось с 32-битной границы.
</p>

<p>
Переменная Forth, называемая <code>LATEST</code>, содержит указатель на последнее заданное слово,
другими словами, <code>голову</code> этого связанного списка.
</p>

<p>
<code>DOUBLE</code> и <code>QUADRUPLE</code> могут выглядеть так::
</p>


<div class="figure">
<p><img src="../../img/forth-dict-2words.png" alt="forth-dict-2words.png">
</p>
</div>

<p>
Вы должны увидеть из этого, как можно реализовать поиск слова в словаре (просто пройти
по записям, начинающимся с той, на которую указывает LATEST, и сопоставляя имена, пока
вы не найдете совпадение или не наткнетесь на указатель NULL в конце словаря).
</p>

<p>
И как добавить слово в словарь (создать новое определение, установить его LINK в LATEST
и установить LATEST, чтобы он указывал на новое слово). Мы увидим именно эти функции,
реализованные в ассемблере позже.
</p>

<p>
Одним из интересных последствий использования связанного списка является то, что вы
можете переопределять слова, и более новое определение слова переопределяет более
старое. Это важная концепция в Forth, потому что это означает, что любое слово (даже
"встроенные" или "стандартные" слова) могут быть переопределены новым определением,
либо для его улучшения, либо для его ускорения или даже для его отключения. Однако
из-за того, как компилируются слова Forth, которые вы поймете ниже, слова, определенные
с использованием старого определения слова, продолжают использовать старое
определение. Только новые слова, определенные после нового определения, используют
новое определение.
</p>
</div>
</div>

<div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">Прямой шитый код</h3>
<div class="outline-text-3" id="text-unnumbered-5">
<p>
Теперь мы перейдем к действительно важному, для пониманию Forth, аспекту. Если вы не
поймете этот раздел, то вы не поймете как работает Forth, и это будет неудачей с моей
стороны.
</p>

<p>
Давайте поговорим сначала о том, что означает "шитый код". Представьте себе
своеобразную версию Cи, где вам разрешено вызывать только функции без аргументов. (Не
беспокойтесь, о том, что такой язык будет совершенно бесполезен) Итак, в нашем
своеобразном Cи код будет выглядеть так:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #0000ff;">f</span> () {
    a ();
    b ();
    c ();
}
</pre>
</div>

<p>
&#x2026;и так далее. Как бы функция, скажем, <code>f</code> выше, была скомпилирована стандартным
компилятором Cи в машинный код? Например для i386 так:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #0000ff;">f</span>:
    <span style="color: #af00ff;">CALL</span> a          #  E8 08 00 00 00
    <span style="color: #af00ff;">CALL</span> b          #  E8 1C 00 00 00
    <span style="color: #af00ff;">CALL</span> c          #  E8 2C 00 00 00
    <span style="color: #af0000;">;;  </span><span style="color: #af0000;">&#1089;&#1077;&#1081;&#1095;&#1072;&#1089; &#1084;&#1099; &#1087;&#1086;&#1082;&#1072; &#1080;&#1075;&#1085;&#1086;&#1088;&#1080;&#1088;&#1091;&#1077;&#1084; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080;</span>
</pre>
</div>

<p>
<code>E8</code> - это машинный код x86 для «CALL» функции. В первые 20 лет компьютерная память
была ужасно дорогой, и мы могли бы беспокоиться о том, что расходуем впустую
память повторенными байтами «E8». Мы можем сэкономить 20% в размере кода (и,
следовательно, дорогостоящей памяти), сжав это:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #0000ff;">08</span> <span style="color: #af00ff;">00</span> 00 00   #  &#1055;&#1088;&#1086;&#1089;&#1090;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1081;, &#1073;&#1077;&#1079; CALL
<span style="color: #0000ff;">1C</span> <span style="color: #af00ff;">00</span> 00 00
<span style="color: #0000ff;">2C</span> <span style="color: #af00ff;">00</span> 00 00
</pre>
</div>

<p>
На 16-битной машине, подобной той, на которой Forth был запущен в первый раз, экономия
еще больше - 33%.
</p>

<p>
Историческое примечание: Если модель исполнения, используемая Forth, кажется странной,
то она была полностью мотивирована необходимостью экономить память на ранних
компьютерах. Это сжатие не так важно сейчас, когда наши машины имеют больше памяти в
своих кэшах L1, чем в ранних компьютерах, но модель исполнения по-прежнему обладает
некоторыми полезными свойствами. Кроме того, на современных процессорах, Forth-система
способна целиком поместиться в кеше процессора, что делает ее прямо таки чудовищно
быстрой.
</p>

<p>
Конечно, этот сжатый код, из которого убраны <code>E8</code>, больше не будет работать
непосредственно на процессоре. Вместо этого нам нужно написать интерпретатор, который
берет каждый адрес и вызывает его.
</p>

<p>
На машине i386 получается, что этот интерпретатор можно легко написать в двух
ассемблерных инструкциях, которые превращаются всего в 3 байта машинного кода. Давайте
сохраним в регистре <code>%esi</code> указатель на следующее слово для выполнения:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-01.png" alt="forth-interpret-01.png">
</p>
</div>

<p>
В i386 есть инструкция <code>LODSL</code> (или в терминологии руководств Intel, <code>LODSW</code>). Она
делает две вещи:
</p>
<ul class="org-ul">
<li>читает из памяти, на которую указывает <code>%esi</code> 4 байта в регистр <code>%eax</code>
</li>
<li>увеличивает значение в регистре <code>%esi</code> на 4
</li>
</ul>

<p>
Итак, после выполнения инструкции <code>LODSL</code> ситуация выглядит так:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-02.png" alt="forth-interpret-02.png">
</p>
</div>

<p>
Сейчас нам надо сделать <code>jmp</code> на адрес, содержащийся в <code>%eax</code>. Это снова всего одна
x86-инструкция, которая записывается как <code>JMP *(%eax)</code>. И после того как мы сделаем JMP
ситуация выглядит так:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-03.png" alt="forth-interpret-03.png">
</p>
</div>

<p>
Для выполнения этой работы каждая подпрограмма сопровождается двумя инструкциями:
<code>LODSL; JMP *(%eax)</code>, которые буквально переходят к следующей подпрограмме.
</p>

<p>
И это подводит нас к нашей первой части реального кода! Ну, то есть, это макрос.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="macro_next"><span style="color: #af00ff;">.macro</span> NEXT
    <span style="color: #af00ff;">lodsl</span>
    <span style="color: #af00ff;">jmp</span> *(<span style="color: #af5f00;">%eax</span>)
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<p>
Этот макрос называется <code>NEXT</code>. Это "фортизм". Он раскрывается в эти две инструкции.
</p>

<p>
Каждый примитив Forth, который мы пишем, должен быть завершен <code>NEXT</code>. Думайте об
этом как о <code>return</code>.
</p>

<p>
Все, что описано выше, называется <code>прямым шитым кодом</code>.
</p>

<p>
Подводя итог: мы сжимаем наши вызовы функций до списка адресов и используем макрос,
чтобы переходить к следующей функции в списке. Мы также используем один регистр
(<code>%esi</code>), как своего рода указатель инструкции, указывая на следующую функцию в списке.
</p>

<p>
Я просто дам вам намек на то, что должно произойти, сказав, что определение Forth,
такое как:
</p>

<div class="org-src-container">

<pre class="src src-forth">: QUADRUPLE DOUBLE DOUBLE ;   <span style="color: #af0000;">\ &#1080;&#1084;&#1103;: "QUADRUPLE"  &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1077;: "DOUBLE DOUBLE"
</span>
</pre>
</div>

<p>
на самом деле компилирует (не совсем точно, но мы сразу увидим, почему) список адресов
функций для DOUBLE, DOUBLE и специальную функцию EXIT для завершения.
</p>

<p>
На данный момент, остроглазые эксперты ассемблера могут воскликнуть: "вы сделали
ошибку!".
</p>

<p>
Ага, я лгал вам о <code>JMP *(%eax)</code>.
</p>
</div>
</div>

<div id="outline-container-unnumbered-6" class="outline-3">
<h3 id="unnumbered-6">Коссвенный шитый код</h3>
<div class="outline-text-3" id="text-unnumbered-6">
<p>
Оказывается, что <code>прямой шитый код</code> интересен, но только если вы хотите просто
выполнить список функций, написанных на ассемблере. Поэтому QUADRUPLE будет работать
только в том случае, если DOUBLE является функцией языка ассемблера. В <code>прямом шитом
коде</code> QUADRUPLE будет выглядеть так:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-04.png" alt="forth-interpret-04.png">
</p>
</div>

<p>
Мы можем добавить дополнительный уровень косвенности, позволяющей нам запускать как
слова, написанные на ассемблере (примитивы, написанные для скорости), так и слова,
написанные на Forth-е, как списки адресов.
</p>

<p>
Дополнительная косвенность является причиной скобок в <code>JMP *(%eax)</code>.
</p>

<p>
Давайте посмотрим, как QUADRUPLE и DOUBLE действительно выглядят в Forth:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-05.png" alt="forth-interpret-05.png">
</p>
</div>

<p>
Это та часть, где вам может понадобиться дополнительная чашка кофе. Что изменилось, так
это то, что я добавил дополнительный указатель на начало определения. В Forth это
называют <code>codeword</code> - кодовое слово. <code>codeword</code> является указателем на интерпретатор
для запуска функции. Для примитивов, написанных на языке ассемблера, <code>codeword</code> просто
указывает на сам код - его не нужно интерпретировать, он просто запускается.
</p>

<p>
В словах, написанных в Forth (например, QUADRUPLE и DOUBLE), кодовое слово указывает на
функцию-интерпретатор.
</p>

<p>
Я вскоре покажу вам функцию-интерпретатор, но давайте вспомним наш косвенный <code>JMP
*(%eax)</code> с "дополнительными" скобками. Возьмем случай, когда мы выполняем DOUBLE, как
показано, и вызывается DUP. Обратите внимание, что <code>%esi</code> указывает на адрес <code>+</code>
</p>

<p>
Ассемблерный код для DUP в конце делает <code>NEXT</code>. Это:
</p>
<ul class="org-ul">
<li>читает адрес <code>+</code> в <code>%eax</code> - теперь <code>%eax</code> указывает на <code>codeword</code> для кода <code>+</code>
</li>
<li>увеличивает <code>%esi</code> на 4
</li>
<li>выполняет <code>jmp</code> на содержимое того адреса, который лежит в <code>%eax</code> → т.е. <code>jmp</code> по
адресу, лежащему в <code>codeword</code> слова <code>+</code>, → т.е. <code>jmp</code> на ассемблерный код, реализующий
<code>+</code>.
</li>
</ul>


<div class="figure">
<p><img src="../../img/forth-interpret-06.png" alt="forth-interpret-06.png">
</p>
</div>

<p>
Поэтому я надеюсь, что я убедил вас, что <code>NEXT</code> делает примерно то, что вы
ожидаете. Это <code>коссвенный шитый код</code>.
</p>

<p>
Я не сказал о четырех вещах. Интересно, сможете ли вы догадаться о них, не читая
дальше?
</p>

<p>
Вот список этих вещей:
</p>
<ul class="org-ul">
<li>что делает <code>EXIT</code>?
</li>
<li>как происходит вызов функции, т.е. как <code>%esi</code> начинает указывать на часть QUADRUPLE,
а затем указывать на часть DOUBLE?
</li>
<li>Что входит в <code>codeword</code> для слов, написанных на Forth?
</li>
<li>Как компилировать функцию, которая делает что-то еще, кроме вызова других функций,
например функцию, которая содержит число, такую как <code>: DOUBLE 2 * ;</code>?
</li>
</ul>
</div>
</div>

<div id="outline-container-unnumbered-7" class="outline-3">
<h3 id="unnumbered-7">Интерпретатор и стек возвратов</h3>
<div class="outline-text-3" id="text-unnumbered-7">
<p>
Не останавливаясь на этом, давайте поговорим о третьей и второй проблемах,
интерпретаторе и стек возврата.
</p>

<p>
Слова, которые определены в Forth, нуждаются в <code>codeword</code>, которое указывает на
небольшое количество кода, который протягивает им "руку помощи". Им не нужно многого,
но им нужно то, что известно как <code>интерпретатор</code>, хотя на самом деле он не является
интерпретатором в том же смысле, как, например, медленный интерпретатор байт-кода
Java. Этот интерпретатор просто устанавливает несколько машинных регистров, чтобы затем
слово могло выполняться на полной скорости с использованием модели коссвенного шитого
кода, показанной выше.
</p>

<p>
Одна из вещей, которые должны произойти, когда QUADRUPLE вызывает DOUBLE, заключается в
том, что мы сохраняем старый указатель инструкций <code>%esi</code> и создаем новый, указывающий
на первое слово в DOUBLE. Поскольку нам нужно будет восстановить старый <code>%esi</code> в конце
слова DOUBLE (в конце концов, это как вызов функции), нам понадобится стек для хранения
этих "адресов возврата" (старых значений <code>%esi</code>).
</p>

<p>
Как вы, наверно видели в документации, Forth имеет два стека, обычный <code>стек параметров</code>
и <code>стек возвратов</code>, который немного загадочен. Но наш <code>стек возвратов</code> - это просто тот
стек, о котором я говорил в предыдущем абзаце, используемый для сохранения <code>%esi</code> когда
из одного слова Forth вызывается другое слово Forth.
</p>

<p>
В этом Forth мы используем указатель обычного стека (<code>%esp</code>) для <code>стека параметров</code>. Мы
будем использовать другой указатель стека i386 (<code>%ebp</code>, обычно называемый "указателем
фрейма") для <code>стека возвратов</code>.
</p>

<p>
У меня есть два макроса, которые просто оборачивают детали использования <code>%ebp</code> для
<code>стека возвратов</code>. Вы используете их, например, <code>PUSHRSP %eax</code> (<code>push</code> %eax в стек
возвратов) или <code>POPRSP %ebx</code> (<code>pop</code> значение, на которое указывает вершина стека
возвратов %ebp в регистр <code>%ebx</code>).
</p>

<div class="org-src-container">

<pre class="src src-asm" id="macro_pushrsp"><span style="color: #af00ff;">.macro</span> PUSHRSP reg
    <span style="color: #af00ff;">lea</span> -4(<span style="color: #af5f00;">%ebp</span>), <span style="color: #af5f00;">%ebp</span>      # push reg &#1074; &#1089;&#1090;&#1077;&#1082; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090;&#1086;&#1074;
    <span style="color: #af00ff;">movl</span> \reg, (<span style="color: #af5f00;">%ebp</span>)
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<div class="org-src-container">

<pre class="src src-asm" id="macro_poprsp"><span style="color: #af00ff;">.macro</span> POPRSP reg
    <span style="color: #af00ff;">mov</span> (<span style="color: #af5f00;">%ebp</span>),\reg         # pop &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1091; &#1089;&#1090;&#1077;&#1082;&#1072; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090;&#1086;&#1074; &#1074; reg
    <span style="color: #af00ff;">lea</span> 4(<span style="color: #af5f00;">%ebp</span>), <span style="color: #af5f00;">%ebp</span>
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<p>
И с этим мы теперь можем поговорить об <code>интерпретаторе</code>.
</p>

<p>
В Forth функция-интерпретатор часто называется DOCOL (я думаю, что это означает "DO
COLON", потому что все определения Forth начинаются с двоеточия, как например в
выражении <code>: DOUBLE DUP ;</code>
</p>

<p>
Интерпретатору (на самом деле это не "интерпретация") нужно push-нуть старый <code>%esi</code> в
стек и установить <code>%esi</code> так, чтобы он указывал на первое слово в определении. Помните,
как мы перешли к функции с помощью <code>JMP *(%eax)</code>? Вследствие этого удобно, что <code>%eax</code>
содержит адрес этого <code>codeword</code>, поэтому просто добавляя к нему 4, мы получаем адрес
первого слова данных. Наконец, после установки <code>%esi</code>, он просто делает NEXT, который
вызывает запуск первого слова.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="docol">    <span style="color: #af00ff;">.text</span>
    <span style="color: #af00ff;">.align</span> 4
<span style="color: #0000ff;">DOCOL</span>:
    <span style="color: #af00ff;">PUSHRSP</span> <span style="color: #af5f00;">%esi</span>            # push <span style="color: #af5f00;">%esi</span> on to the return stack
    <span style="color: #af00ff;">addl</span>    $4, <span style="color: #af5f00;">%eax</span>        # <span style="color: #af5f00;">%eax</span> points to codeword, so make
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%esi</span>      # <span style="color: #af5f00;">%esi</span> point to first data word
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
Чтобы это было совершенно ясно, посмотрим, как работает DOCOL при прыжке с QUADRUPLE в
DOUBLE:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-07.png" alt="forth-interpret-07.png">
</p>
</div>

<p>
Во-первых, вызов DOUBLE вызывает DOCOL (кодовое слово DOUBLE). DOCOL делает следующее:
он push-ит старый <code>%esi</code> на стек возвратов. <code>%eax</code> указывает на <code>codeword</code> DOUBLE,
поэтому мы просто добавляем к нему 4, чтобы получить наш новый <code>%esi</code>:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-08.png" alt="forth-interpret-08.png">
</p>
</div>

<p>
Затем он делает NEXT и так как из-за магии шитого кода, это увеличивает <code>%esi</code> снова,
то вызывается DUP.
</p>

<p>
Ну, похоже, это работает.
</p>

<p>
Здесь есть одна второстепенная вещь. Поскольку DOCOL - это первый кусок ассемблерного
кода, который должен быть определен в этом файле (остальные - только макросы), и
поскольку я обычно компилирую этот код с сегментом <code>.text</code>, начинающимся с адреса 0,
DOCOL имеет адрес 0. Поэтому, если вы дизассемблируете код и увидите слово с <code>codeword</code>
0, вы сразу же поймете, что это слово Forth (а не ассемблерный примитив), и поэтому
использует DOCOL в качестве интерпретатора.
</p>
</div>
</div>

<div id="outline-container-unnumbered-8" class="outline-3">
<h3 id="unnumbered-8">Начинаем</h3>
<div class="outline-text-3" id="text-unnumbered-8">
<p>
Теперь давайте перейдем к гайкам и болтам. Когда мы запускаем программу, нам нужно
настроить несколько вещей, таких как стек возвратов. Но как только мы сможем, мы хотим
перейти в код Forth (хотя большая часть «раннего» кода Forth все равно должна быть
написана как примитивы на host-языке).
</p>

<p>
Это то, что делает код настройки:
</p>
<ul class="org-ul">
<li>Делает небольшую вступительную часть
</li>
<li>Настраивает отдельный стек возврата (NB: Linux уже дает нам обычный стек параметров)
</li>
<li>затем сразу переходит к слову Forth, называемому QUIT. Несмотря на свое название QUIT
никуда не выходит. Он сбрасывает некоторое внутреннее состояние и начинает чтение и
интерпретацию команд. (Причина, по которой он называется QUIT, заключается в том, что
вы можете вызывать QUIT из вашего собственного кода Forth, чтобы «выйти» из вашей
программы и вернуться к интерпретации).
</li>
</ul>

<div class="org-src-container">

<pre class="src src-asm" id="asm_entry">    <span style="color: #af0000;">/* </span><span style="color: #af0000;">Assembler entry point. */</span>
    <span style="color: #af00ff;">.text</span>
    <span style="color: #af00ff;">.globl</span>  _start
<span style="color: #0000ff;">_start</span>:
    <span style="color: #af00ff;">cld</span>
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%esp</span>, var_S0            # Save the initial data stack pointer in Forth variable S0.
    <span style="color: #af00ff;">mov</span>     $return_stack_top, <span style="color: #af5f00;">%ebp</span> # Initialise the return stack.
    <span style="color: #af00ff;">call</span>    set_up_data_segment

    <span style="color: #af00ff;">mov</span>     $cold_start, <span style="color: #af5f00;">%esi</span>        # Initialise interpreter.
    <span style="color: #af00ff;">NEXT</span>                            # Run interpreter!

    <span style="color: #af00ff;">.section</span> .rodata
<span style="color: #0000ff;">cold_start</span>:                         # High-level code without a codeword.
    <span style="color: #af00ff;">.int</span> QUIT
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-9" class="outline-3">
<h3 id="unnumbered-9">Встроенные слова</h3>
<div class="outline-text-3" id="text-unnumbered-9">
<p>
Помните наши словарные записи? Давайте приведем их вместе с кодовым словом и словами
данных, чтобы увидеть, как
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE DUP <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
действительно выглядит в памяти.
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-09.png" alt="forth-interpret-09.png">
</p>
</div>

<p>
Вначале мы не можем просто написать буквально <code>: DOUBLE DUP;</code> , потому что нам еще пока
нечем читать строку, разбивать ее на пробелы, анализировать каждое слово и.т.д. Поэтому
вместо этого нам придется определять встроенные слова, используя конструкторы данных
ассемблера GNU (например, .int, .byte, .string, .ascii и.т.д.)
</p>

<div class="org-src-container">

<pre class="src src-asm">    <span style="color: #af00ff;">.int</span>  &lt;&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1077;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086;&gt;
    <span style="color: #af00ff;">.byte</span> 6         # len
    <span style="color: #af00ff;">.ascii</span> <span style="color: #87005f;">"DOUBLE"</span> # name
    <span style="color: #af00ff;">.byte</span> 0         # padding
<span style="color: #0000ff;">DOUBLE</span>:
    <span style="color: #af00ff;">.int</span> DOCOL      # codeword
    <span style="color: #af00ff;">.int</span> DUP        # &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; codeword DUP
    <span style="color: #af00ff;">.int</span> PLUS       # &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; codeword +
    <span style="color: #af00ff;">.int</span> EXIT       # &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; codeword EXIT
</pre>
</div>

<p>
Но это быстро утомляет, поэтому я определяю ассемблерный макрос, чтобы я мог просто
написать:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #0000ff;">defword</span> <span style="color: #87005f;">"DOUBLE"</span>,6,,DOUBLE
    <span style="color: #af00ff;">.int</span> DUP,PLUS,EXIT
</pre>
</div>

<p>
и получить точно такой же эффект. Не беспокойтесь о деталях реализации этого макроса -
он может показаться сложным.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="macro_defword">    <span style="color: #af0000;">/* </span><span style="color: #af0000;">Flags - &#1101;&#1090;&#1086; &#1084;&#1099; &#1086;&#1073;&#1089;&#1091;&#1076;&#1080;&#1084; &#1087;&#1086;&#1090;&#1086;&#1084; */</span>
    <span style="color: #af00ff;">.set</span> F_IMMED,0x80
    <span style="color: #af00ff;">.set</span> F_HIDDEN,0x20
    <span style="color: #af00ff;">.set</span> F_LENMASK,0x1f  # length mask

    <span style="color: #af0000;">// </span><span style="color: #af0000;">Store the chain of links.</span>
    <span style="color: #af00ff;">.set</span> link,0

<span style="color: #af00ff;">.macro</span> defword name, namelen, flags=0, label
    <span style="color: #af00ff;">.section</span> .rodata
    <span style="color: #af00ff;">.align</span> 4
    <span style="color: #af00ff;">.globl</span> name_\label
    <span style="color: #af00ff;">name_</span>\label :
    <span style="color: #af00ff;">.int</span> link               # link
    <span style="color: #af00ff;">.set</span> link,name_\label
    <span style="color: #af00ff;">.byte</span> \flags+\namelen   # flags + &#1073;&#1072;&#1081;&#1090; &#1076;&#1083;&#1080;&#1085;&#1099;
    <span style="color: #af00ff;">.ascii</span> <span style="color: #87005f;">"\name"</span>          # &#1080;&#1084;&#1103;
    <span style="color: #af00ff;">.align</span> 4                # &#1074;&#1099;&#1088;&#1072;&#1074;&#1085;&#1080;&#1074;&#1072;&#1085;&#1080;&#1077; &#1085;&#1072; 4-&#1093; &#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1091;&#1102; &#1075;&#1088;&#1072;&#1085;&#1080;&#1094;&#1091;
    <span style="color: #af00ff;">.globl</span> \label
    \label :
    <span style="color: #af00ff;">.int</span> DOCOL              # codeword - &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1102;-&#1080;&#1085;&#1090;&#1077;&#1087;&#1088;&#1077;&#1090;&#1072;&#1090;&#1086;&#1088;
    # list of word pointers follow
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<p>
Таким образом я хочу писать слова, написанные на ассемблере. Мы должны написать
некоторое количество базового кода, прежде чем будет достаточно "инфраструктуры", чтобы
начать писать слова на Forth, но также я хочу определить некоторые общие слова Forth в
языке ассемблера для скорости, хотя я мог бы написать их на Forth.
</p>

<p>
Вот как DUP выглядит в памяти:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-10.png" alt="forth-interpret-10.png">
</p>
</div>

<p>
Опять же, для краткости я собираюсь написать макрос ассемблера с именем <code>defcode</code>. Как
и в случае с <code>defword</code> выше, не беспокойтесь о сложных деталях макроса.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="macro_defcode"><span style="color: #af00ff;">.macro</span> defcode name, namelen, flags=0, label
    <span style="color: #af00ff;">.section</span> .rodata
    <span style="color: #af00ff;">.align</span> 4
    <span style="color: #af00ff;">.globl</span> name_\label
<span style="color: #0000ff;">name</span>_\label :
    <span style="color: #af00ff;">.int</span>    link               # link
    <span style="color: #af00ff;">.set</span>    link,name_\label
    <span style="color: #af00ff;">.byte</span>   \flags+\namelen    # flags + &#1073;&#1072;&#1081;&#1090; &#1076;&#1083;&#1080;&#1085;&#1099;
    <span style="color: #af00ff;">.ascii</span>  <span style="color: #87005f;">"\name"</span>            # &#1080;&#1084;&#1103;
    <span style="color: #af00ff;">.align</span>  4                  # &#1074;&#1099;&#1088;&#1072;&#1074;&#1085;&#1080;&#1074;&#1072;&#1085;&#1080;&#1077; &#1085;&#1072; 4-&#1093; &#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1091;&#1102; &#1075;&#1088;&#1072;&#1085;&#1080;&#1094;&#1091;
    <span style="color: #af00ff;">.globl</span>  \label
\label :
    <span style="color: #af00ff;">.int</span>    code_\label        # codeword
    <span style="color: #af00ff;">.text</span>
    <span style="color: #af0000;">//</span><span style="color: #af0000;">.align 4</span>
    <span style="color: #af00ff;">.globl</span>  code_\label
    <span style="color: #af00ff;">code_</span>\label :              # &#1076;&#1072;&#1083;&#1077;&#1077; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1072;&#1089;&#1089;&#1077;&#1084;&#1073;&#1083;&#1077;&#1088;&#1085;&#1099;&#1081; &#1082;&#1086;&#1076;
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<p>
Теперь несколько простых примитивов Forth. Они написаны на ассемблере для
скорости. Если вы понимаете язык ассемблера i386, то стоит их прочитать.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="simple_primitives"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"DROP"</span>,4,,DROP
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"SWAP"</span>,4,,SWAP
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1087;&#1086;&#1084;&#1077;&#1085;&#1103;&#1090;&#1100; &#1084;&#1077;&#1089;&#1090;&#1072;&#1084;&#1080; &#1076;&#1074;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1093; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"DUP"</span>,3,,DUP
    <span style="color: #af00ff;">mov</span>     (<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%eax</span>    # &#1076;&#1091;&#1073;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"OVER"</span>,4,,OVER
    <span style="color: #af00ff;">mov</span>     4(<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%eax</span>   # &#1074;&#1079;&#1103;&#1090;&#1100; &#1074;&#1090;&#1086;&#1088;&#1086;&#1081; &#1086;&#1090; &#1074;&#1077;&#1088;&#1093;&#1072; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # &#1080; &#1087;&#1086;&#1083;&#1086;&#1078;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; &#1082;&#1086;&#1087;&#1080;&#1102; &#1089;&#1074;&#1077;&#1088;&#1093;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"ROT"</span>,3,,ROT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"-ROT"</span>,4,,NROT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"2DROP"</span>,5,,TWODROP
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1076;&#1074;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1093; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"2DUP"</span>,4,,TWODUP
    <span style="color: #af00ff;">mov</span>     (<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%eax</span>    # &#1076;&#1091;&#1073;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1076;&#1074;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1093; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;
    <span style="color: #af00ff;">mov</span>     4(<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"2SWAP"</span>,5,,TWOSWAP
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1087;&#1086;&#1084;&#1077;&#1085;&#1103;&#1090;&#1100; &#1084;&#1077;&#1089;&#1090;&#1072;&#1084;&#1080; &#1076;&#1074;&#1077; &#1087;&#1072;&#1088;&#1099; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1086;&#1074; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"?DUP"</span>,4,,QDUP
    <span style="color: #af00ff;">movl</span>    (<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%eax</span>    # &#1076;&#1091;&#1073;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1077;&#1089;&#1083;&#1080; &#1086;&#1085; &#1085;&#1077; &#1085;&#1091;&#1083;&#1077;&#1074;&#1086;&#1081;
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">jz</span>      1f
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
<span style="color: #0000ff;">1</span>:
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"1+"</span>,2,,INCR
    <span style="color: #af00ff;">incl</span>    (<span style="color: #af5f00;">%esp</span>)          # &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1072; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"1-"</span>,2,,DECR
    <span style="color: #af00ff;">decl</span>    (<span style="color: #af5f00;">%esp</span>)          # &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1080;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1072; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"4+"</span>,2,,INCR4
    <span style="color: #af00ff;">addl</span>    $4, (<span style="color: #af5f00;">%esp</span>)      # &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1072; 4
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"4-"</span>,2,,DECR4
    <span style="color: #af00ff;">subl</span>    $4, (<span style="color: #af5f00;">%esp</span>)      # &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1080;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1072; 4
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"+"</span>,1,,ADD
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1074;&#1079;&#1103;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">addl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%esp</span>)    # &#1087;&#1088;&#1080;&#1073;&#1072;&#1074;&#1080;&#1100; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1082; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1091;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1089;&#1090;&#1072;&#1083; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1084;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"-"</span>,1,,SUB
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1074;&#1079;&#1103;&#1090;&#1100; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072;
    <span style="color: #af00ff;">subl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%esp</span>)    # &#1074;&#1099;&#1095;&#1077;&#1089;&#1090;&#1100; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1089;&#1090;&#1072;&#1083; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1084;
    <span style="color: #af00ff;">&#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1084;</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"*"</span>,1,,MUL
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1074;&#1079;&#1103;&#1090;&#1100; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1074;&#1079;&#1103;&#1090;&#1100; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;
    <span style="color: #af00ff;">imull</span>   <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%eax</span>      # &#1091;&#1084;&#1085;&#1086;&#1078;&#1080;&#1090;&#1100; &#1080;&#1093; &#1076;&#1088;&#1091;&#1075; &#1085;&#1072; &#1076;&#1088;&#1091;&#1075;&#1072;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # &#1080;&#1075;&#1085;&#1086;&#1088;&#1080;&#1088;&#1091;&#1077;&#1084; &#1087;&#1077;&#1088;&#1077;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1080;&#1077;
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
В этом Forth только <code>/MOD</code> примитив. Позже мы определим слова <code>/</code> и <code>MOD</code> в терминах
примитива <code>/MOD</code>. Конструкция ассемблерной команды <code>idiv</code>, которая оставляет как частное,
так и остаток, делает этот выбор очевидным.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="mod"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"/MOD"</span>,4,,DIVMOD
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">idivl</span>   <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edx</span>            # push &#1086;&#1089;&#1090;&#1072;&#1090;&#1086;&#1082;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push &#1095;&#1072;&#1089;&#1090;&#1085;&#1086;&#1077;
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
Множество сравнительных операций, таких как <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, и.т.д
</p>

<p>
Стандарт ANSI Forth говорит, что слова сравнения должны возвращать все двоичные разряды
равные единице для TRUE, и все двоичные разряды равные нулю для FALSE. Однако это
немного странное соглашение, поэтому этот Forth не следует ему и возвращает более
нормальное (для программистов на Си) значение <code>1</code> для TRUE и <code>0</code> для FALSE.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="comparison"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"="</span>,1,,EQU
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1076;&#1074;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1093; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1090;&#1077;&#1082;&#1072; &#1088;&#1072;&#1074;&#1085;&#1099;?
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">sete</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&lt;&gt;"</span>,2,,NEQU
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1076;&#1074;&#1072; &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1093; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1077; &#1088;&#1072;&#1074;&#1085;&#1099;?
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setne</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&lt;"</span>,1,,LT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">setl</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&gt;"</span>,1,,GT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">setg</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&lt;="</span>,2,,LE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">setle</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&gt;="</span>,2,,GE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">setge</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0="</span>,2,,ZEQU
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1088;&#1072;&#1074;&#1077;&#1085; &#1085;&#1091;&#1083;&#1102;?
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setz</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0&lt;&gt;"</span>,3,,ZNEQU
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1074;&#1077;&#1088;&#1093;&#1085;&#1080;&#1081; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1090;&#1077;&#1082;&#1072; &#1085;&#1077; &#1088;&#1072;&#1074;&#1077;&#1085; &#1085;&#1091;&#1083;&#1102;?
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setnz</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0&lt;"</span>,2,,ZLT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # comparisons with 0
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setl</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0&gt;"</span>,2,,ZGT
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setg</span>    <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0&lt;="</span>,3,,ZLE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setle</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0&gt;="</span>,3,,ZGE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">setge</span>   <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">movzbl</span>  <span style="color: #af5f00;">%al</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pushl</span>   <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"AND"</span>,3,,AND
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1073;&#1080;&#1090;&#1086;&#1074;&#1099;&#1081; AND
    <span style="color: #af00ff;">andl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%esp</span>)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"OR"</span>,2,,OR
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1073;&#1080;&#1090;&#1086;&#1074;&#1099;&#1081; OR
    <span style="color: #af00ff;">orl</span>     <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%esp</span>)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"XOR"</span>,3,,XOR
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1073;&#1080;&#1090;&#1086;&#1074;&#1099;&#1081; XOR
    <span style="color: #af00ff;">xorl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%esp</span>)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"INVERT"</span>,6,,INVERT
    <span style="color: #af00ff;">notl</span>    (<span style="color: #af5f00;">%esp</span>)          # &#1101;&#1090;&#1086; &#1073;&#1080;&#1090;&#1086;&#1074;&#1072;&#1103; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1103; <span style="color: #87005f;">"NOT"</span> (&#1089;&#1084;. NEGATE and NOT)
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-10" class="outline-3">
<h3 id="unnumbered-10">Возвращение из форт-слов</h3>
<div class="outline-text-3" id="text-unnumbered-10">
<p>
Время поговорить о том, что происходит, когда мы делаем EXIT. На этой диаграмме
QUADRUPLE вызывает DOUBLE, и DOUBLE собирается сделать EXIT (посмотрите, куда указывает
<code>%esi</code>)
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-11.png" alt="forth-interpret-11.png">
</p>
</div>

<p>
Что происходит, когда функция выполняет NEXT? Выполняется следующий код:
</p>

<div class="org-src-container">

<pre class="src src-asm" id="exit"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"EXIT"</span>,4,,EXIT
    <span style="color: #af00ff;">POPRSP</span>  <span style="color: #af5f00;">%esi</span>            # pop return stack into <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
EXIT получает старый <code>%esi</code>, который мы сохранили ранее в <code>стеке возвратов</code>, и помещает
его в <code>%esi</code>. Итак, после этого (но до NEXT) мы получаем:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-12.png" alt="forth-interpret-12.png">
</p>
</div>

<p>
И NEXT просто завершает работу, в этом случае, просто вызвав DOUBLE снова.
</p>
</div>
</div>

<div id="outline-container-unnumbered-11" class="outline-3">
<h3 id="unnumbered-11">Литералы</h3>
<div class="outline-text-3" id="text-unnumbered-11">
<p>
Последний момент, который я "замалчивал" раньше, заключался в том, как иметь дело с
функциями, которые делают что-либо помимо вызова других функций. Например, предположим,
что DOUBLE был определен следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE 2 * <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Он делает то же самое, но как мы его скомпилируем, если он содержит буквально цифру 2?
Одним из способов было бы иметь функцию под названием <code>2</code> (которую вы должны были бы
написать на ассемблере), но вам понадобится такая функция для каждого отдельного
литерала, который вы бы хотели использовать.
</p>

<p>
Forth решает это, компилируя функцию, используя специальное слово LIT:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-13.png" alt="forth-interpret-13.png">
</p>
</div>

<p>
LIT выполняется обычным способом, но то, что он делает дальше, определенно не
нормально. Он смотрит на <code>%esi</code> (который теперь указывает на число 2), захватывает его
(число 2), кладет его в стек, а затем манипулирует <code>%esi</code>, чтобы пропустить номер, как
если бы он никогда не был там.
</p>

<p>
Что интересно, так это то, что весь захват и манипуляция может быть выполнена с
использованием одной байтовой команды i386, нашего старого друга <code>LODSL</code>. Вместо того,
чтобы рисовать диаграммы, посмотрите, можете ли вы узнать, как работает <code>LIT</code>:
</p>

<div class="org-src-container">

<pre class="src src-asm" id="exit"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"LIT"</span>,3,,LIT
    # <span style="color: #af5f00;">%esi</span> &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1090; &#1085;&#1072; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1091;&#1102; &#1082;&#1086;&#1084;&#1072;&#1085;&#1076;&#1091;, &#1085;&#1086; &#1074; &#1101;&#1090;&#1086;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077; &#1101;&#1090;&#1086; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081;
    # &#1083;&#1080;&#1090;&#1077;&#1088;&#1072;&#1083;, &#1087;&#1088;&#1077;&#1076;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1102;&#1097;&#1080;&#1081; &#1089;&#1086;&#1073;&#1086;&#1081; 4 &#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;. &#1055;&#1086;&#1083;&#1091;&#1095;&#1077;&#1085;&#1080;&#1077; &#1101;&#1090;&#1086;&#1075;&#1086; &#1083;&#1080;&#1090;&#1077;&#1088;&#1072;&#1083;&#1072; &#1074; <span style="color: #af5f00;">%eax</span>
    # &#1080; &#1080;&#1085;&#1082;&#1088;&#1077;&#1084;&#1077;&#1085;&#1090; <span style="color: #af5f00;">%esi</span> &#1085;&#1072; x86 -  &#1101;&#1090;&#1086; &#1091;&#1076;&#1086;&#1073;&#1085;&#1072;&#1103; &#1086;&#1076;&#1085;&#1086;&#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1072;&#1103; &#1080;&#1085;&#1089;&#1090;&#1088;&#1091;&#1082;&#1094;&#1080;&#1103;! (&#1089;&#1084;. NEXT macro)
    <span style="color: #af00ff;">lodsl</span>
    # push literal &#1074; &#1089;&#1090;&#1077;&#1082;
    <span style="color: #af00ff;">push</span> <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-12" class="outline-3">
<h3 id="unnumbered-12">Память</h3>
<div class="outline-text-3" id="text-unnumbered-12">
<p>
Важным моментом в Forth является то, что он дает вам прямой доступ к самым низким
деталям машины. Манипулирование памятью часто осуществляется в Forth, и вот примитивы
для этого:
</p>

<div class="org-src-container">

<pre class="src src-asm" id="store"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"!"</span>,1,,STORE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1082;&#1091;&#1076;&#1072; &#1073;&#1091;&#1076;&#1077;&#1084; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1090;&#1100;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077; &#1073;&#1091;&#1076;&#1077;&#1084; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1090;&#1100;
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%ebx</span>)    # &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1087;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"@"</span>,1,,FETCH
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081;, &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1081; &#1085;&#1072;&#1076;&#1086; &#1074;&#1077;&#1088;&#1085;&#1091;&#1090;&#1100;
    <span style="color: #af00ff;">mov</span>     (<span style="color: #af5f00;">%ebx</span>), <span style="color: #af5f00;">%eax</span>    # &#1074;&#1099;&#1103;&#1089;&#1085;&#1103;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1086; &#1101;&#1090;&#1086;&#1084;&#1091; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push-&#1080;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1074; &#1089;&#1090;&#1077;&#1082;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"+!"</span>,2,,ADDSTORE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1091;&#1102; &#1073;&#1091;&#1076;&#1077;&#1084; &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1090;&#1100;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1073;&#1091;&#1076;&#1077;&#1084; &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1090;&#1100;
    <span style="color: #af00ff;">addl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%ebx</span>)    # &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1082; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; &#1087;&#1086; &#1101;&#1090;&#1086;&#1084;&#1091; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"-!"</span>,2,,SUBSTORE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1091;&#1102; &#1073;&#1091;&#1076;&#1077;&#1084; &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1072;&#1090;&#1100;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1073;&#1091;&#1076;&#1077;&#1084; &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1072;&#1090;&#1100;
    <span style="color: #af00ff;">subl</span>    <span style="color: #af5f00;">%eax</span>, (<span style="color: #af5f00;">%ebx</span>)    # &#1074;&#1099;&#1095;&#1080;&#1090;&#1072;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1080;&#1079; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; &#1087;&#1086; &#1101;&#1090;&#1086;&#1084;&#1091; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
<code>!</code> и <code>@</code> (STORE и FETCH) работают с 32-битными словами. Также полезно иметь
возможность читать и писать байты, поэтому мы также определяем стандартные слова <code>C@</code> и
<code>C!</code>. Байт-ориентированные операции работают только на архитектуре, которая их
разрешает (i386 является одним из них).
</p>

<div class="org-src-container">

<pre class="src src-asm" id="char_store"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"C!"</span>,2,,STOREBYTE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089;, &#1082;&#1091;&#1076;&#1072; &#1073;&#1091;&#1076;&#1077;&#1084; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1090;&#1100;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077; &#1073;&#1091;&#1076;&#1077;&#1084; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1090;&#1100;
    <span style="color: #af00ff;">movb</span>    <span style="color: #af5f00;">%al</span>, (<span style="color: #af5f00;">%ebx</span>)     # &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1103;&#1077;&#1084; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1087;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"C@"</span>,2,,FETCHBYTE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # &#1079;&#1072;&#1073;&#1080;&#1088;&#1072;&#1077;&#1084; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081;, &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1081; &#1085;&#1072;&#1076;&#1086; &#1074;&#1077;&#1088;&#1085;&#1091;&#1090;&#1100;
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>      # &#1086;&#1095;&#1080;&#1097;&#1072;&#1077;&#1084; &#1088;&#1077;&#1075;&#1080;&#1089;&#1090;&#1088; <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%ebx</span>), <span style="color: #af5f00;">%al</span>     # &#1074;&#1099;&#1103;&#1089;&#1085;&#1103;&#1077;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1086; &#1101;&#1090;&#1086;&#1084;&#1091; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push-&#1080;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1074; &#1089;&#1090;&#1077;&#1082;
    <span style="color: #af00ff;">NEXT</span>

# C@C! - &#1101;&#1090;&#1086; &#1087;&#1086;&#1083;&#1077;&#1079;&#1085;&#1099;&#1081; &#1087;&#1088;&#1080;&#1084;&#1080;&#1090;&#1080;&#1074; &#1076;&#1083;&#1103; &#1082;&#1086;&#1087;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; &#1073;&#1072;&#1081;&#1090;
<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"C@C!"</span>,4,,CCOPY
    <span style="color: #af00ff;">movl</span>    4(<span style="color: #af5f00;">%esp</span>), <span style="color: #af5f00;">%ebx</span>   # &#1072;&#1076;&#1088;&#1077;&#1089; &#1080;&#1089;&#1090;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%ebx</span>), <span style="color: #af5f00;">%al</span>     # &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; &#1080;&#1079; &#1080;&#1089;&#1090;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>            # &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1088;&#1080;&#1077;&#1084;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">stosb</span>                   # &#1082;&#1086;&#1087;&#1080;&#1088;&#1091;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; &#1074; &#1087;&#1088;&#1080;&#1077;&#1084;&#1085;&#1080;&#1082;
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edi</span>            # &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1088;&#1080;&#1077;&#1084;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">incl</span>    4(<span style="color: #af5f00;">%esp</span>)         # &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1072;&#1076;&#1088;&#1077;&#1089; &#1080;&#1089;&#1090;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">NEXT</span>

# CMOVE - &#1086;&#1087;&#1077;&#1088;&#1072;&#1094;&#1080;&#1103; &#1082;&#1086;&#1087;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; &#1073;&#1083;&#1086;&#1082;&#1072; &#1073;&#1072;&#1081;&#1090;&#1086;&#1074;
<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"CMOVE"</span>,5,,CMOVE
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%esi</span>, <span style="color: #af5f00;">%edx</span>      # &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1084; <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # length
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>            # &#1072;&#1076;&#1088;&#1077;&#1089; &#1087;&#1088;&#1080;&#1077;&#1084;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%esi</span>            # &#1072;&#1076;&#1088;&#1077;&#1089; &#1080;&#1089;&#1090;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072;
    <span style="color: #af00ff;">rep</span>     movsb           # &#1082;&#1086;&#1087;&#1080;&#1088;&#1091;&#1077;&#1084; &#1080;&#1089;&#1090;&#1086;&#1095;&#1085;&#1080;&#1082; &#1074; &#1087;&#1088;&#1080;&#1077;&#1084;&#1085;&#1080;&#1082; length &#1088;&#1072;&#1079;
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%esi</span>      # &#1074;&#1086;&#1089;&#1089;&#1090;&#1072;&#1085;&#1072;&#1074;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-13" class="outline-3">
<h3 id="unnumbered-13">Встроенные переменные</h3>
<div class="outline-text-3" id="text-unnumbered-13">
<p>
Это некоторые встроенные переменные и соответствующие стандартные слова Forth. Из них
единственное, что мы обсуждали до сих пор, было LATEST, что указывает на последнее
(последнее определенное) слово в словаре Forth. LATEST также является словом Forth,
которое выталкивает адрес переменнуй LATEST в стек, поэтому вы можете читать или писать
ее с помощью операторов <code>@</code> и <code>!</code>. Например, чтобы напечатать текущее значение LATEST
(и это применимо к любой переменной Forth), вы должны:
</p>

<div class="org-src-container">

<pre class="src src-forth">LATEST @ . CR
</pre>
</div>

<p>
Чтобы уменьшить определение переменных, я использую макрос <code>defvar</code>, похожий на
<code>defword</code> и <code>defcode</code> выше. (Фактически, <code>defvar</code> макрос использует <code>defcode</code> для
создания заголовка в словаре).
</p>

<div class="org-src-container">

<pre class="src src-asm" id="macro_defvar"><span style="color: #af00ff;">.macro</span> defvar name, namelen, flags=0, label, initial=0
    <span style="color: #af00ff;">defcode</span> \name,\namelen,\flags,\label
    <span style="color: #af00ff;">push</span>    $var_\name
    <span style="color: #af00ff;">NEXT</span>
    <span style="color: #af00ff;">.data</span>
    <span style="color: #af00ff;">.align</span> 4
    <span style="color: #af00ff;">var_</span>\name :
    <span style="color: #af00ff;">.int</span> \initial
<span style="color: #af00ff;">.endm</span>
</pre>
</div>

<p>
Встроенные переменные:
</p>
<ul class="org-ul">
<li>STATE   - состояние интерпретации(0) или компиляции слова (отличным от нуля)
</li>
<li>LATEST  - указатель на последнее заданное слово в словаре.
</li>
<li>HERE    - указатель на следующий свободный байт памяти. При компиляции скомпилированные слова
помещаются тут.
</li>
<li>S0      - хранит адрес верхней части стека параметров.
</li>
<li>BASE    - текущая база для печати и чтения чисел.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-asm" id="built_in_vars"><span style="color: #0000ff;">defvar</span> <span style="color: #87005f;">"STATE"</span>,5,,STATE
<span style="color: #0000ff;">defvar</span> <span style="color: #87005f;">"HERE"</span>,4,,HERE
<span style="color: #0000ff;">defvar</span> <span style="color: #87005f;">"LATEST"</span>,6,,LATEST,name_SYSCALL0   # SYSCALL0 must be last in built-in dictionary
<span style="color: #0000ff;">defvar</span> <span style="color: #87005f;">"S0"</span>,2,,SZ
<span style="color: #0000ff;">defvar</span> <span style="color: #87005f;">"BASE"</span>,4,,BASE,10
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-14" class="outline-3">
<h3 id="unnumbered-14">Встроенные константы</h3>
<div class="outline-text-3" id="text-unnumbered-14">
<p>
Встроенные константы:
</p>
<ul class="org-ul">
<li>VERSION   - это текущая версия этого Forth.
</li>
<li>R0        - адрес вершины стека возвратов.
</li>
<li>DOCOL     - Указатель на DOCOL.
</li>
<li>F<sub>IMMED</sub>   - текущее значение флага IMMEDIATE.
</li>
<li>F<sub>HIDDEN</sub>  - Текущее значение флага HIDDEN.
</li>
<li>F<sub>LENMASK</sub> - Маска длины в  flags/len байте
</li>
<li>SYS_ * и числовые коды различных системных вызовов Linux (из &lt;asm/unistd.h&gt;)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-asm" id="built_in_constants"><span style="color: #af0000;">//</span><span style="color: #af0000;">#include &lt;asm-i386/unistd.h&gt;  // &#1074;&#1072;&#1084; &#1084;&#1086;&#1078;&#1077;&#1090; &#1087;&#1086;&#1085;&#1072;&#1076;&#1086;&#1073;&#1080;&#1090;&#1100;&#1089;&#1103; &#1101;&#1090;&#1086; &#1074;&#1084;&#1077;&#1089;&#1090;&#1086; &#1101;&#1090;&#1086;&#1075;&#1086;</span>
<span style="color: #5f5f87;">#include</span> <span style="color: #87005f;">&lt;asm/unistd.h&gt;</span>

<span style="color: #af00ff;">.macro</span> defconst name, namelen, flags=0, label, value
    <span style="color: #af00ff;">defcode</span> \name,\namelen,\flags,\label
    <span style="color: #af00ff;">push</span> $\value
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #af00ff;">.endm</span>

<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"VERSION"</span>,7,,VERSION,JONES_VERSION
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"R0"</span>,2,,RZ,return_stack_top
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"DOCOL"</span>,5,,__DOCOL,DOCOL
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"F_IMMED"</span>,7,,__F_IMMED,F_IMMED
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"F_HIDDEN"</span>,8,,__F_HIDDEN,F_HIDDEN
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"F_LENMASK"</span>,9,,__F_LENMASK,F_LENMASK

<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_EXIT"</span>,8,,SYS_EXIT,__NR_exit
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_OPEN"</span>,8,,SYS_OPEN,__NR_open
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_CLOSE"</span>,9,,SYS_CLOSE,__NR_close
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_READ"</span>,8,,SYS_READ,__NR_read
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_WRITE"</span>,9,,SYS_WRITE,__NR_write
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_CREAT"</span>,9,,SYS_CREAT,__NR_creat
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"SYS_BRK"</span>,7,,SYS_BRK,__NR_brk

<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_RDONLY"</span>,8,,__O_RDONLY,0
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_WRONLY"</span>,8,,__O_WRONLY,1
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_RDWR"</span>,6,,__O_RDWR,2
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_CREAT"</span>,7,,__O_CREAT,0100
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_EXCL"</span>,6,,__O_EXCL,0200
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_TRUNC"</span>,7,,__O_TRUNC,01000
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_APPEND"</span>,8,,__O_APPEND,02000
<span style="color: #0000ff;">defconst</span> <span style="color: #87005f;">"O_NONBLOCK"</span>,10,,__O_NONBLOCK,04000
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-15" class="outline-3">
<h3 id="unnumbered-15">Стек возвратов</h3>
<div class="outline-text-3" id="text-unnumbered-15">
<p>
Эти слова позволяют получить доступ к стеку возвратов. Напомним, что регистр %ebp всегда
указывает на вершину стека возвратов.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="return_stack_words"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"&gt;R"</span>,2,,TOR
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # pop parameter stack into <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">PUSHRSP</span> <span style="color: #af5f00;">%eax</span>            # push it on to the return stack
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"R&gt;"</span>,2,,FROMR
    <span style="color: #af00ff;">POPRSP</span>  <span style="color: #af5f00;">%eax</span>            # pop return stack on to <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # and push on to parameter stack
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"RSP@"</span>,4,,RSPFETCH
    <span style="color: #af00ff;">push</span>     <span style="color: #af5f00;">%ebp</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"RSP!"</span>,4,,RSPSTORE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebp</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"RDROP"</span>,5,,RDROP
    <span style="color: #af00ff;">addl</span>    $4, <span style="color: #af5f00;">%ebp</span>        # pop return stack and throw away
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-16" class="outline-3">
<h3 id="unnumbered-16">Стек параметров (данных)</h3>
<div class="outline-text-3" id="text-unnumbered-16">
<p>
Эти функции позволяют вам управлять стеком параметров. Напомним, что Linux
устанавливает для нас стек параметров, и он доступен через регистр <code>%esp</code>.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="data_stack_words"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"DSP@"</span>,4,,DSPFETCH
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%esp</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"DSP!"</span>,4,,DSPSTORE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%esp</span>
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-17" class="outline-3">
<h3 id="unnumbered-17">Ввод и вывод</h3>
<div class="outline-text-3" id="text-unnumbered-17">
<p>
Это наши первые действительно сложные примитивы Forth. Я решил написать их на
ассемблере, но удивительно, что в реальных реализациях Forth они часто пишутся в
терминах более фундаментальных примитивов Forth.
</p>

<p>
Я решил избежать этого, потому что я думаю, что это просто скрывает реализацию. В конце
концов, вы можете не понимать ассемблер, но вы можете просто подумать об этом как о
непрозрачном блоке кода, который делает то, что он говорит.
</p>

<p>
Давайте сначала обсудим ввод.
</p>

<p>
Слово KEY считывает следующий байт из stdin (и push-ит его на стек
параметров). Поэтому, если KEY вызывается, и кто-то нажимает на клавишу пробела, то
число 32 (ASCII-код пробела) помещается в стек.
</p>

<p>
В Forth нет различий между чтением кода и чтением ввода. Мы могли бы читать и
компилировать код, мы могли бы читать слова для выполнения, мы могли бы попросить
пользователя набрать свое имя - в конечном итоге все это происходит через KEY.
</p>

<p>
Реализация KEY использует входной буфер определенного размера (определенный в конце
этого файла). Он вызывает системный вызов Linux read(2) для заполнения этого буфера и
отслеживает его положение в буфере с помощью пары переменных, и если у него
заканчивается входной буфер, он автоматически заполняет его. Если KEY обнаруживает, что
stdin закрыт, он выходит из программы, поэтому, когда вы нажимаете ^D, система Forth
полностью завершается.
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-14.png" alt="forth-interpret-14.png">
</p>
</div>

<div class="org-src-container">

<pre class="src src-asm" id="word_key">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"KEY"</span>,3,,KEY
    <span style="color: #af00ff;">call</span> _KEY
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push return value on stack
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #0000ff;">_KEY</span>:
    <span style="color: #af00ff;">mov</span>     (currkey), <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">cmp</span>     (bufftop), <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">jge</span>     1f              # exhausted the input buffer?
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">mov</span>     (<span style="color: #af5f00;">%ebx</span>), <span style="color: #af5f00;">%al</span>     # get next key from input buffer
    <span style="color: #af00ff;">inc</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ebx</span>,(currkey)  # increment currkey
    <span style="color: #af00ff;">ret</span>
<span style="color: #0000ff;">1</span>:
    # Out of input, use read(2) to fetch more input from stdin.
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>      # 1st param: stdin
    <span style="color: #af00ff;">mov</span>     $buffer, <span style="color: #af5f00;">%ecx</span>   # 2nd param: buffer
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ecx</span>,currkey
    <span style="color: #af00ff;">mov</span>     $BUFFER_SIZE, <span style="color: #af5f00;">%edx</span>  # 3rd param: max length
    <span style="color: #af00ff;">mov</span>     $__NR_read, <span style="color: #af5f00;">%eax</span> # syscall: read
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>      # If <span style="color: #af5f00;">%eax</span> &lt;= 0, then exit.
    <span style="color: #af00ff;">jbe</span>     2f
    <span style="color: #af00ff;">addl</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ecx</span>      # buffer+<span style="color: #af5f00;">%eax</span> = bufftop
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ecx</span>,bufftop
    <span style="color: #af00ff;">jmp</span>     _KEY
<span style="color: #0000ff;">2</span>:
    # Error or end of input: exit the program.
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">mov</span>     $__NR_exit, <span style="color: #af5f00;">%eax</span> # syscall: exit
    <span style="color: #af00ff;">int</span>     $0x80

    <span style="color: #af00ff;">.data</span>
    <span style="color: #af00ff;">.align</span> 4
<span style="color: #0000ff;">currkey</span>:
    # Current place in input buffer (next character to read).
    <span style="color: #af00ff;">.int</span> buffer
<span style="color: #0000ff;">bufftop</span>:
    # Last valid data in input buffer + 1.
    <span style="color: #af00ff;">.int</span> buffer
</pre>
</div>

<p>
Напротив, выход намного проще. Слово EMIT выводит один байт в stdout. Эта реализация
просто использует системный вызов <code>write</code>. Никакой попытки сделать буфер не
производится, но было бы хорошим упражнением добавить его.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_emit">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"EMIT"</span>,4,,EMIT
    <span style="color: #af00ff;">pop</span> <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">call</span> _EMIT
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #0000ff;">_EMIT</span>:
    <span style="color: #af00ff;">mov</span>     $1, <span style="color: #af5f00;">%ebx</span>        # 1st param: stdout

    # write needs the address of the byte to write
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%al</span>, emit_scratch
    <span style="color: #af00ff;">mov</span>     $emit_scratch, <span style="color: #af5f00;">%ecx</span> # 2nd param: address

    <span style="color: #af00ff;">mov</span>     $1, <span style="color: #af5f00;">%edx</span>        # 3rd param: nbytes = 1

    <span style="color: #af00ff;">mov</span>     $__NR_write, <span style="color: #af5f00;">%eax</span>   # write syscall
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">ret</span>

    <span style="color: #af00ff;">.data</span>           # NB: easier to fit in the .data section
<span style="color: #0000ff;">emit_scratch</span>:
    <span style="color: #af00ff;">.space</span> 1        # scratch used by EMIT
</pre>
</div>

<p>
Вернемся к вводу. WORD - это слово , которое читает следующее полное слово со
стандартного ввода. Если подробнее, он сначала пропускает любые пробелы (пробелы,
вкладки, символы новой строки и.т.д.). Затем он вызывает KEY, чтобы читать символы во
внутреннем буфере, пока не наткнется на пробел. Затем он вычисляет длину прочитанного
слова и возвращает адрес и длину как два слова в стеке (с длиной в верхней части
стека).
</p>

<p>
Обратите внимание, что WORD имеет единственный внутренний буфер, который он
перезаписывает каждый раз (скорее, как статическая строка в си). Также обратите
внимание, что внутренний буфер WORD составляет всего 32 байта, и нет проверки для
переполнения. 31 байт - это максимальная длина слова Forth, которое мы поддерживаем, и
это то, для чего WORD и используется: чтения слов Forth при компиляции и выполнении
кода. Возвращенные строки не заканчиваются NUL.
</p>

<p>
Начальный адрес и длина строки - это обычный способ представления строк в Forth (не
заканчивающийся символом ASCII NUL, как в C), и поэтому строки Forth могут содержать
любой символ, включая NUL, и могут быть любой длины.
</p>

<p>
WORD не подходит для простого считывания строк (например, пользовательского ввода)
из-за всех вышеперечисленных особенностей и ограничений.
</p>

<p>
Обратите внимание, что при выполнении вы увидите:
</p>

<div class="org-src-container">

<pre class="src src-forth">WORD FOO
</pre>
</div>

<p>
который помещает «FOO» и длину 3 в стек, но при компиляции:
</p>

<div class="org-src-container">

<pre class="src src-forth">: BAR WORD FOO <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
будет ошибка (или, по крайней мере, это не сделает то, что вы можете ожидать). Позже мы
поговорим о компиляции и про <code>режим немедленного исполнения</code>, и вы поймете, почему.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_word">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"WORD"</span>,4,,WORD
    <span style="color: #af00ff;">call</span>    _WORD
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edi</span>            # push base address
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>            # push length
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #0000ff;">_WORD</span>:
    # Search for first non-blank character.  Also skip \ comments.
<span style="color: #0000ff;">1</span>:
    <span style="color: #af00ff;">call</span>    _KEY            # get next key, returned in <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">cmpb</span>    $'\\', <span style="color: #af5f00;">%al</span>      # start of a comment?
    <span style="color: #af00ff;">je</span>      3f              # if so, skip the comment
    <span style="color: #af00ff;">cmpb</span>    $' ', <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">jbe</span>     1b              # if so, keep looking

    # Search for the end of the word, storing chars as we go.
    <span style="color: #af00ff;">mov</span>     $word_buffer, <span style="color: #af5f00;">%edi</span>  # pointer to return buffer
<span style="color: #0000ff;">2</span>:
    <span style="color: #af00ff;">stosb</span>                   # add character to return buffer
    <span style="color: #af00ff;">call</span>    _KEY            # get next key, returned in <span style="color: #af5f00;">%al</span>
    <span style="color: #af00ff;">cmpb</span>    $' ', <span style="color: #af5f00;">%al</span>       # is blank?
    <span style="color: #af00ff;">ja</span>      2b              # if not, keep looping

    # Return the word (well, the static buffer) and length. */
    <span style="color: #af00ff;">sub</span>     $word_buffer, <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%edi</span>, <span style="color: #af5f00;">%ecx</span>      # return length of the word
    <span style="color: #af00ff;">mov</span>     $word_buffer, <span style="color: #af5f00;">%edi</span>  # return address of the word
    <span style="color: #af00ff;">ret</span>

    # Code to skip \ comments to end of the current line.
<span style="color: #0000ff;">3</span>:
    <span style="color: #af00ff;">call</span>    _KEY
    <span style="color: #af00ff;">cmpb</span>    $'\n', <span style="color: #af5f00;">%al</span>      # end of line yet?
    <span style="color: #af00ff;">jne</span>     3b
    <span style="color: #af00ff;">jmp</span>     1b

    <span style="color: #af00ff;">.data</span>                   # NB: easier to fit in the .data section
    # A static buffer where WORD returns.  Subsequent calls
    # overwrite this buffer.  Maximum word length is 32 chars.
<span style="color: #0000ff;">word_buffer</span>:
    <span style="color: #af00ff;">.space</span> 32
</pre>
</div>

<p>
Помимо чтения слов, нам нужно будет читать цифры, и для этого мы используем функцию
NUMBER. Она анализирует числовую строку, например, возвращаемую WORD, и push-ит число в
стек параметров.
</p>

<p>
эта функция использует переменную BASE в качестве базы (radix) для преобразования,
поэтому, например, если BASE равна 2, мы ожидаем двоичное число. Обычно BASE составляет
</p>
<ol class="org-ol">
<li></li>
</ol>

<p>
Если слово начинается с символа '-', тогда возвращаемое значение отрицательно.
</p>

<p>
Если строка не может быть проанализирована как число (или содержит символы за пределами
текущей BASE), тогда нам нужно вернуть индикацию ошибки. Таким образом, NUMBER
фактически возвращает два элемента в стеке. В верхней части стека мы возвращаем
количество несконвертированных символов (т. Е. Если 0, то все символы были
преобразованы, поэтому нет ошибки). Второй элемент от вершины стека - это
распарсенное число или частичное значение, если произошла ошибка.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_number">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"NUMBER"</span>,6,,NUMBER
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # length of string
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>            # start address of string
    <span style="color: #af00ff;">call</span>    _NUMBER
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # parsed number
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>            # number of unparsed characters (0 = no error)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">_NUMBER</span>:
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>

    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%ecx</span>, <span style="color: #af5f00;">%ecx</span>      # trying to parse a zero-length string is an error, but will return 0.
    <span style="color: #af00ff;">jz</span>      5f

    <span style="color: #af00ff;">movl</span>    var_BASE, <span style="color: #af5f00;">%edx</span>  # get BASE (in <span style="color: #af5f00;">%dl</span>)

    # Check if first character is '-'.
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%edi</span>), <span style="color: #af5f00;">%bl</span>     # <span style="color: #af5f00;">%bl</span> = first character in string
    <span style="color: #af00ff;">inc</span>     <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push 0 on stack
    <span style="color: #af00ff;">cmpb</span>    $'-', <span style="color: #af5f00;">%bl</span>       # negative number?
    <span style="color: #af00ff;">jnz</span>     2f
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>            # push &lt;&gt; 0 on stack, indicating negative
    <span style="color: #af00ff;">dec</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">jnz</span>     1f
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # error: string is only '-'.
    <span style="color: #af00ff;">movl</span>    $1, <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">ret</span>
    # Loop reading digits.
<span style="color: #0000ff;">1</span>:
    <span style="color: #af00ff;">imull</span>   <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%eax</span>      # <span style="color: #af5f00;">%eax</span> *= BASE
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%edi</span>), <span style="color: #af5f00;">%bl</span>     # <span style="color: #af5f00;">%bl</span> = next character in string
    <span style="color: #af00ff;">inc</span>     <span style="color: #af5f00;">%edi</span>
    # Convert 0-9, A-Z to a number 0-35.
<span style="color: #0000ff;">2</span>:
    <span style="color: #af00ff;">subb</span>    $'0', <span style="color: #af5f00;">%bl</span>       # &lt; '0'?
    <span style="color: #af00ff;">jb</span>      4f
    <span style="color: #af00ff;">cmp</span>     $10, <span style="color: #af5f00;">%bl</span>        # &lt;= '9'?
    <span style="color: #af00ff;">jb</span>      3f
    <span style="color: #af00ff;">subb</span>    $17, <span style="color: #af5f00;">%bl</span>        # &lt; 'A'? (17 is 'A'-'0')
    <span style="color: #af00ff;">jb</span>      4f
    <span style="color: #af00ff;">addb</span>    $10, <span style="color: #af5f00;">%bl</span>
<span style="color: #0000ff;">3</span>:
    <span style="color: #af00ff;">cmp</span>     <span style="color: #af5f00;">%dl</span>, <span style="color: #af5f00;">%bl</span>        # &gt;= BASE?
    <span style="color: #af00ff;">jge</span>     4f
    # OK, so add it to <span style="color: #af5f00;">%eax</span> and loop.
    <span style="color: #af00ff;">add</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">dec</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">jnz</span>     1b
    # Negate the result if first character was '-' (saved on the stack).
<span style="color: #0000ff;">4</span>:
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">jz</span>      5f
    <span style="color: #af00ff;">neg</span>     <span style="color: #af5f00;">%eax</span>
<span style="color: #0000ff;">5</span>:
    <span style="color: #af00ff;">ret</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-18" class="outline-3">
<h3 id="unnumbered-18">Просмотр словаря</h3>
<div class="outline-text-3" id="text-unnumbered-18">
<p>
Мы подходим к нашей прелюдии о том, как компилируется код Forth, но сначала нам нужно
еще немного инфраструктуры.
</p>

<p>
Слово FIND принимает строку (слово, которое анализируется WORD - см. выше) и находит
его его в словаре. Фактически он возвращает адрес заголовка словаря, если он находит
его, или 0, в противном случае
</p>

<p>
Поэтому, если DOUBLE определен в словаре, тогда
</p>

<div class="org-src-container">

<pre class="src src-forth">WORD DOUBLE FIND
</pre>
</div>

<p>
возвращает следующий указатель:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-15.png" alt="forth-interpret-15.png">
</p>
</div>

<p>
See also &gt;CFA and &gt;DFA.
</p>

<p>
FIND не находит словарные записи, помеченные как HIDDEN. См. ниже, почему.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_number">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"FIND"</span>,4,,FIND
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # <span style="color: #af5f00;">%ecx</span> = length
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>            # <span style="color: #af5f00;">%edi</span> = address
    <span style="color: #af00ff;">call</span>    _FIND
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # <span style="color: #af5f00;">%eax</span> = address of dictionary entry (or NULL)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">_FIND</span>:
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%esi</span>            # Save <span style="color: #af5f00;">%esi</span> so we can use it in string comparison.

    # Now we start searching backwards through the dictionary for this word.
    <span style="color: #af00ff;">mov</span>     var_LATEST, <span style="color: #af5f00;">%edx</span> # LATEST points to name header of the latest word in the dictionary
<span style="color: #0000ff;">1</span>:
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%edx</span>      # NULL pointer?  (end of the linked list)
    <span style="color: #af00ff;">je</span>      4f

    # Compare the length expected and the length of the word.
    # Note that if the F_HIDDEN flag is set on the word, then by a bit of trickery
    # this won't pick the word (the length will appear to be wrong).
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movb</span>    4(<span style="color: #af5f00;">%edx</span>), <span style="color: #af5f00;">%al</span>    # <span style="color: #af5f00;">%al</span> = flags+length field
    <span style="color: #af00ff;">andb</span>    $(F_HIDDEN|F_LENMASK), <span style="color: #af5f00;">%al</span> # <span style="color: #af5f00;">%al</span> = name length
    <span style="color: #af00ff;">cmpb</span>    <span style="color: #af5f00;">%cl</span>, <span style="color: #af5f00;">%al</span>        # Length is the same?
    <span style="color: #af00ff;">jne</span>     2f

    # Compare the strings in detail.
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ecx</span>            # Save the length
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edi</span>            # Save the address (repe cmpsb will move this pointer)
    <span style="color: #af00ff;">lea</span>     5(<span style="color: #af5f00;">%edx</span>), <span style="color: #af5f00;">%esi</span>   # Dictionary string we are checking against.
    <span style="color: #af00ff;">repe</span>    cmpsb           # Compare the strings.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">jne</span>     2f              # Not the same.

    # The strings are the same - return the header pointer in <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">ret</span>
<span style="color: #0000ff;">2</span>:
    <span style="color: #af00ff;">mov</span>     (<span style="color: #af5f00;">%edx</span>), <span style="color: #af5f00;">%edx</span>    # Move back through the link field to the previous word
    <span style="color: #af00ff;">jmp</span>     1b              # .. and loop.
<span style="color: #0000ff;">4</span>:
    # Not found.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>      # Return zero to indicate not found.
    <span style="color: #af00ff;">ret</span>
</pre>
</div>

<p>
FIND возвращает указатель словаря, но при компиляции нам нужен указатель кодового слова
(напомним, что определения Forth скомпилированы в списки указателей на
<code>codeword</code>-ы). Стандартное слово <code>&gt;CFA</code> превращает указатель словаря в указатель на
<code>codeword</code>.
</p>

<p>
В приведенном ниже примере показан результат:
</p>

<div class="org-src-container">

<pre class="src src-forth">WORD DOUBLE FIND &gt;CFA
</pre>
</div>


<div class="figure">
<p><img src="../../img/forth-interpret-16.png" alt="forth-interpret-16.png">
</p>
</div>

<p>
NB: поскольку имена различаются по длине, это не просто простое приращение.
</p>

<p>
В этом Forth вы не можете легко превратить указатель кодового слова обратно в указатель
на элемент словаря, но это не так для большинства реализаций Forth, где они хранят
обратный указатель в определении (с очевидной стоимостью памяти / сложности).
</p>

<p>
Причина, по которой они делают это, заключается в том, что это бывает полезно, чтобы
быстро декомпилировать определения Forth.
</p>

<p>
Что означает <code>CFA</code>? Мое лучшее предположение - "Code Field Address"
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_number">    <span style="color: #af00ff;">defcode</span> <span style="color: #87005f;">"&gt;CFA"</span>,4,,TCFA
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">call</span>    _TCFA
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #0000ff;">_TCFA</span>:
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">add</span>     $4, <span style="color: #af5f00;">%edi</span>        # Skip link pointer.
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%edi</span>), <span style="color: #af5f00;">%al</span>     # Load flags+len into <span style="color: #af5f00;">%al</span>.
    <span style="color: #af00ff;">inc</span>     <span style="color: #af5f00;">%edi</span>            # Skip flags+len byte.
    <span style="color: #af00ff;">andb</span>    $F_LENMASK, <span style="color: #af5f00;">%al</span> # Just the length, not the flags.
    <span style="color: #af00ff;">add</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%edi</span>      # Skip the name.
    <span style="color: #af00ff;">addl</span>    $3, <span style="color: #af5f00;">%edi</span>        # The codeword is 4-byte aligned.
    <span style="color: #af00ff;">andl</span>    $~3, <span style="color: #af5f00;">%edi</span>
    <span style="color: #af00ff;">ret</span>
</pre>
</div>

<p>
В связи с &gt;CFA рассмотрим &gt;DFA, который берет адрес записи словаря, возвращаемый FIND,
и возвращает указатель на первое поле данных.
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-17.png" alt="forth-interpret-17.png">
</p>
</div>

<p>
(Обратите внимание на этот момент, кто знаком с исходным кодом FIG-Forth / ciforth: Это
&gt;DFA определение отличается от их, потому что у них есть дополнительная косвенность).
</p>

<p>
Как легко можно увидеть &gt;DFA легко определяется в Forth, просто путем добавления 4 к
результату &gt;CFA.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_number"><span style="color: #0000ff;">defword</span> <span style="color: #87005f;">"&gt;DFA"</span>,4,,TDFA
    <span style="color: #af00ff;">.int</span> TCFA       # &gt;CFA     (get code field address)
    <span style="color: #af00ff;">.int</span> INCR4      # 4+       (add 4 to it to get to next word)
    <span style="color: #af00ff;">.int</span> EXIT       # EXIT     (return from Forth word)
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-19" class="outline-3">
<h3 id="unnumbered-19">Компиляция</h3>
<div class="outline-text-3" id="text-unnumbered-19">
<p>
Теперь мы поговорим о том, как Forth компилирует слова. Напомним, что определение слова
выглядит следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE DUP + <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
и мы должны превратить это в:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-18.png" alt="forth-interpret-18.png">
</p>
</div>

<p>
Теперь нам нужно решить несколько задач:
</p>
<ul class="org-ul">
<li>Куда поместить новое слово?
</li>
<li>Как мы читаем слова?
</li>
<li>Как мы определяем слова <code>:</code> (COLON) и <code>;</code> (SEMICOLON)?
</li>
</ul>

<p>
Forth решает это довольно изящно и, как вы можете ожидать, очень низкоуровневым
способом, который позволяет вам изменить способ работы компилятора над вашим
собственным кодом.
</p>

<p>
Forth имеет функцию INTERPRET (настоящий интерпретатор на этот раз, а не DOCOL),
которая работает в цикле, читая слова (используя WORD), просматривая их (используя
FIND), превращая их в указатели кодового слова (используя &gt;CFA) и решая, что с ними
делать.
</p>

<p>
То, что он делает, зависит от режима интерпретатора (в переменной STATE).
</p>

<p>
Когда STATE равно нулю, интерпретатор просто запускает каждое слово, когда оно
находит их. Это называется "немедленным режимом" (immediate mode).
</p>

<p>
Интересные вещи происходят, когда STATE не равен нулю - "режим компиляции" (compiling
mode). В этом режиме интерпретатор добавляет указатель <code>codeword</code> в
пользовательскую память (переменная HERE указывает на следующий свободный байт
пользовательской памяти - см. Раздел СЕГМЕНТ ДАННЫХ ниже).
</p>

<p>
Таким образом, вы сможете увидеть, как мы можем определить <code>:</code> (COLON). Общий план:
</p>
<ul class="org-ul">
<li>(1) Использовать WORD для чтения имени определяемой функции.
</li>
<li>(2) Построить запись словаря - только часть заголовка - в пользовательской памяти:
</li>
</ul>


<div class="figure">
<p><img src="../../img/forth-interpret-19.png" alt="forth-interpret-19.png">
</p>
</div>

<ul class="org-ul">
<li>(3) Установить LATEST, чтобы указать на новое слово, &#x2026;
</li>
<li>(4) .. и самое главное оставить ЗДЕСЬ, указывая сразу после нового <code>codeword</code>. Здесь
интерпретатор будет добавлять кодовые слова.
</li>
<li>(5) Установить STATE в 1. Это вызовет переход в режим компиляции, поэтому интерпретатор
начинает добавлять кодовые слова к нашему частично сформированному заголовку.
</li>
</ul>

<p>
После того, как <code>:</code> запущен, наш вход находится здесь:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-20.png" alt="forth-interpret-20.png">
</p>
</div>

<p>
поэтому интерпретатор (теперь он находится в режиме компиляции, поэтому я думаю, что
это на самом деле компилятор) читает "DUP", просматривает его в словаре, получает его
указатель на кодовое слово и добавляет его.
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-21.png" alt="forth-interpret-21.png">
</p>
</div>

<p>
Затем мы читаем <code>+</code>, получаем указатель его <code>codeword</code> и добавляем его:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-22.png" alt="forth-interpret-22.png">
</p>
</div>

<p>
Теперь проблема заключается в следующем. Очевидно, что мы не хотим, чтобы мы читали <code>;</code>
скомпилировали его и продолжали компилировать все подряд.
</p>

<p>
На этом этапе Forth использует трюк. Помните, что длина байта в определении словаря не
просто байт длины, но также может содержать флаги. Один флаг называется флагом
IMMEDIATE (F<sub>IMMED</sub> в этом коде). Если слово в словаре помечено как IMMEDIATE, тогда
интерпретатор запускает его немедленно <span class="underline">даже если он находится в режиме компиляции</span>.
</p>

<p>
Вот как это слово <code>;</code> (SEMICOLON) работает - как слово, помеченное в словаре как
IMMEDIATE.
</p>

<p>
Все, что оно делает, - это добавляет кодовое слово для EXIT в текущее определение и
возвращает к немедленному режиму (установкой STATE на 0). Вскоре мы увидим его
фактическое определение; и мы увидим, что это действительно очень простое определение,
объявленное IMMEDIATE.
</p>

<p>
После чтения интерпретатором <code>;</code> и выполнения его "немедленно", мы получаем это:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-23.png" alt="forth-interpret-23.png">
</p>
</div>

<p>
и STATE установлена в 0;
</p>

<p>
И это вся работа, наше новое определение скомпилировано, и мы вернулись в
непосредственный режим, простых чтений и выполнений слов, возможно, включая вызов,
чтобы проверить наше новое слово DOUBLE.
</p>

<p>
Единственная последняя заминка в том, что, хотя пока слово компилируется, оно было в
полуготовом состоянии. Мы, разумеется, не хотели бы, чтобы DOUBLE был вызван кем-то в
это время. Есть несколько способов сделать это это, но в Forth мы устанавливаем байт
длины слова с флагом HIDDEN (F_<sub>HIDDEN</sub> в этом коде) во время его компиляции. Это предотвращает
обнаружение компилируемого слова с помощью FIND и, таким образом, теоретически
предотвращает любой шанс его вызова.
</p>

<p>
Вышеприведенное объясняет, как компилировать <code>:</code> (COLON) и <code>;</code> (SEMICOLON), и через
мгновение я их определю. Функция: (COLON) может быть сделана немного более общей, если
написать ее в двух частях. Первая часть, называемая CREATE, создает только заголовок:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-24.png" alt="forth-interpret-24.png">
</p>
</div>

<p>
и вторая часть, фактическое определение <code>:</code> (COLON), вызывает CREATE и добавляет кодовое
слово DOCOL:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-25.png" alt="forth-interpret-25.png">
</p>
</div>

<p>
CREATE является стандартным словом Forth, и преимущество этого разделения состоит в
том, что мы можем его повторно использовать для создания других типов слов (а не только
тех, которые содержат код, но например и таких, которые содержат переменные, константы
и другие данные).
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_number"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"CREATE"</span>,6,,CREATE

    # Get the name length and address.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # <span style="color: #af5f00;">%ecx</span> = length
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # <span style="color: #af5f00;">%ebx</span> = address of name

    # Link pointer.
    <span style="color: #af00ff;">movl</span>    var_HERE, <span style="color: #af5f00;">%edi</span>  # <span style="color: #af5f00;">%edi</span> is the address of the header
    <span style="color: #af00ff;">movl</span>    var_LATEST, <span style="color: #af5f00;">%eax</span>    # Get link pointer
    <span style="color: #af00ff;">stosl</span>                   # and store it in the header.

    # Length byte and the word itself.
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%cl</span>,<span style="color: #af5f00;">%al</span>         # Get the length.
    <span style="color: #af00ff;">stosb</span>                   # Store the length/flags byte.
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%esi</span>      # <span style="color: #af5f00;">%esi</span> = word
    <span style="color: #af00ff;">rep</span>     movsb           # Copy the word
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">addl</span>    $3, <span style="color: #af5f00;">%edi</span>        # Align to next 4 byte boundary.
    <span style="color: #af00ff;">andl</span>    $~3, <span style="color: #af5f00;">%edi</span>

    # Update LATEST and HERE.
    <span style="color: #af00ff;">movl</span>    var_HERE, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, var_LATEST
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%edi</span>, var_HERE
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
Поскольку я хочу определить <code>:</code> (COLON) в Forth, а не в ассемблере, нам нужно еще
несколько слов Forth.
</p>

<p>
Первый - это ~,~ (COMMA), который является стандартным словом Forth, которое добавляет
32-битное целое к пользовательской памяти, на которое указывает HERE, а потом добавляет 4 к
HERE. Таким образом, действие ~,~ (COMMA):
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-26.png" alt="forth-interpret-26.png">
</p>
</div>

<p>
DATA - любое 32-битное значение, которое лежит на вершине стека
</p>

<p>
~,~ (COMMA) является довольно фундаментальной операцией при компиляции. Он используется
для добавления <code>codeword</code>-ов в текущее слово, которое компилируется.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_comma"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">","</span>,1,,COMMA
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>        # Code pointer to store.
    <span style="color: #af00ff;">call</span>    _COMMA
    <span style="color: #af00ff;">NEXT</span>
<span style="color: #0000ff;">_COMMA</span>:
    <span style="color: #af00ff;">movl</span>    var_HERE, <span style="color: #af5f00;">%edi</span>  # HERE
    <span style="color: #af00ff;">stosl</span>                   # Store it.
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%edi</span>, var_HERE  # Update HERE (incremented)
    <span style="color: #af00ff;">ret</span>
</pre>
</div>

<p>
Наши определения <code>:</code> (COLON) и <code>;</code> (SEMICOLON) необходимо будет переключать в режим
компиляции и из него.
</p>

<p>
Глобальная переменная STATE определяет текущий режим (<code>немедленный</code> или <code>режим
компиляции</code>) и, изменяя эту переменную, мы можем переключаться между этими двумя
режимами.
</p>

<p>
По различным причинам, которые проявятся позже, Forth определяет два стандартных слова,
называемых <code>[</code> и <code>]</code> (LBRAC и RBRAC), которые переключают между этими режимами:
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Слово</th>
<th scope="col" class="left">Ассемблерное имя</th>
<th scope="col" class="left">Действие</th>
<th scope="col" class="left">Эффект</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">[</td>
<td class="left">LBRAC</td>
<td class="left">STATE = 0</td>
<td class="left">Переключение в немедленный режим.</td>
</tr>

<tr>
<td class="left">]</td>
<td class="left">RBRAC</td>
<td class="left">STATE = 1</td>
<td class="left">Переключение в режим компиляции.</td>
</tr>
</tbody>
</table>

<p>
<code>[</code> (LBRAC) является НЕМЕДЛЕННЫМ (IMMEDIATE) словом. Причина такова: если бы это было
не так и мы находились в режиме компиляции, и интерпретатор увидел <code>[</code> - тогда он
скомпилировал бы ее, а не выполнил бы ее. И мы никогда не смогли бы вернуться к
немедленному режиму! Поэтому мы помечаем слово как IMMEDIATE, так что даже в режиме
компиляции <code>[</code> запускается в немедленном режиме, переключая нас обратно в немедленный
режим.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_rbrac"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"["</span>,1,F_IMMED,LBRAC
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, var_STATE # Set STATE to 0.
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"]"</span>,1,,RBRAC
    <span style="color: #af00ff;">movl</span>    $1, var_STATE   # Set STATE to 1.
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
Теперь мы можем определить <code>:</code> (COLON), используя CREATE. Он просто вызывает CREATE,
добавляет DOCOL (как <code>codeword</code>), устанавливает HIDDEN и переходит в режим компиляции.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_colon"><span style="color: #0000ff;">defword</span> <span style="color: #87005f;">":"</span>,1,,COLON
    <span style="color: #af00ff;">.int</span> WORD               # Get the name of the new word
    <span style="color: #af00ff;">.int</span> CREATE             # CREATE the dictionary entry / header
    <span style="color: #af00ff;">.int</span> LIT, DOCOL, COMMA  # &#1044;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; DOCOL  (&#1082;&#1072;&#1082; codeword).
    <span style="color: #af00ff;">.int</span> LATEST, FETCH, HIDDEN # &#1044;&#1077;&#1083;&#1072;&#1077;&#1090; &#1089;&#1083;&#1086;&#1074;&#1086; &#1089;&#1082;&#1088;&#1099;&#1090;&#1099;&#1084; (&#1089;&#1084;. &#1085;&#1080;&#1078;&#1077; &#1076;&#1083;&#1103; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103;).
    <span style="color: #af00ff;">.int</span> RBRAC              # &#1055;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076;&#1080;&#1084; &#1074; &#1088;&#1077;&#1078;&#1080;&#1084; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1080;
    <span style="color: #af00ff;">.int</span> EXIT               # &#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1080;
</pre>
</div>

<p>
<code>;</code> (SEMICOLON) также элегантно прост. Обратите внимание на флаг F<sub>IMMED</sub>.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_semicolon"><span style="color: #0000ff;">defword</span> <span style="color: #87005f;">";"</span>,1,F_IMMED,SEMICOLON
    <span style="color: #af00ff;">.int</span> LIT, EXIT, COMMA   # Append EXIT (so the word will return).
    <span style="color: #af00ff;">.int</span> LATEST, FETCH, HIDDEN # &#1055;&#1077;&#1088;&#1077;&#1082;&#1083;&#1102;&#1095;&#1072;&#1077;&#1084; hidden flag  (&#1089;&#1084;. &#1085;&#1080;&#1078;&#1077; &#1076;&#1083;&#1103; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103;).
    <span style="color: #af00ff;">.int</span> LBRAC              # &#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084;&#1089;&#1103; &#1074; IMMEDIATE &#1088;&#1077;&#1078;&#1080;&#1084;.
    <span style="color: #af00ff;">.int</span> EXIT               # &#1042;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1080;&#1079; &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-20" class="outline-3">
<h3 id="unnumbered-20">Расширение компилятора</h3>
<div class="outline-text-3" id="text-unnumbered-20">
<p>
Слова, помеченные IMMEDIATE (F<sub>IMMED</sub>), предназначены не только для использования
компилятором Forth. Вы также можете определить свои собственные слова IMMEDIATE, и это
важный аспект при расширении базового Forth, поскольку он позволяет фактически
расширять сам компилятор. GCC позволяет вам это делать?
</p>

<p>
Стандартные слова Forth, такие как <code>IF</code>, <code>WHILE</code>, ~."~ и.т.д., Все написаны как
расширения базового компилятора, и все это IMMEDIATE слова.
</p>

<p>
Слово IMMEDIATE переключает флаг F<sub>IMMED</sub> (IMMEDIATE) на последнее определенное слово
или на текущее слово, если вы вызываете его в середине определения.
</p>

<p>
Типичное использование:
</p>

<div class="org-src-container">

<pre class="src src-forth">: MYIMMEDWORD <span style="color: #af00ff;">IMMEDIATE</span>
    ...definition...
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
но некоторые программисты Forth пишут это вместо этого:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">MYIMMEDWORD
</span>    ...definition...
<span style="color: #af00ff;">; IMMEDIATE</span>
</pre>
</div>

<p>
Эти два способа использования эквивалентны в первом приближении.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_immediate"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"IMMEDIATE"</span>,9,F_IMMED,IMMEDIATE
    <span style="color: #af00ff;">movl</span>    var_LATEST, <span style="color: #af5f00;">%edi</span>    # LATEST word.
    <span style="color: #af00ff;">addl</span>    $4, <span style="color: #af5f00;">%edi</span>        # Point to name/flags byte.
    <span style="color: #af00ff;">xorb</span>    $F_IMMED, (<span style="color: #af5f00;">%edi</span>)    # Toggle the IMMED bit.
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
<code>addr HIDDEN</code> переключает hidden флаг (F<sub>HIDDEN</sub>) слова, определенного в addr. Чтобы
скрыть последнее заданное слово (используемое выше в <code>:</code> и <code>;</code> определениях), вы
должны:
</p>

<div class="org-src-container">

<pre class="src src-forth">LATEST @ HIDDEN
</pre>
</div>

<p>
<code>HIDE word</code> переключает флаг названного слова <code>word</code>.
</p>

<p>
Установка этого флага останавливает поиск слова FIND, поэтому его можно использовать
для создания "private" слов. Например, чтобы разбить большое слово на более мелкие
части, вы можете сделать:
</p>

<div class="org-src-container">

<pre class="src src-forth">: SUB1 ... subword ... <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">SUB2 </span>... subword ... <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">SUB3 </span>... subword ... <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">MAIN </span>... defined in terms of SUB1, SUB2, SUB3 ... <span style="color: #af00ff;">;</span>
HIDE SUB1
HIDE SUB2
HIDE SUB3
</pre>
</div>

<p>
После этого только MAIN "экспортируется" или видимо для остальной части программы.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_hidden"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"IMMEDIATE"</span>,9,F_IMMED,IMMEDIATE
    <span style="color: #af00ff;">movl</span>    var_LATEST, <span style="color: #af5f00;">%edi</span>    # LATEST word.
    <span style="color: #af00ff;">addl</span>    $4, <span style="color: #af5f00;">%edi</span>        # Point to name/flags byte.
    <span style="color: #af00ff;">xorb</span>    $F_IMMED, (<span style="color: #af5f00;">%edi</span>)    # Toggle the IMMED bit.
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>

<p>
' (TICK) - это стандартное слово Forth, которое возвращает указатель <code>codeword</code>
следующего слова.
</p>

<p>
Общее использование:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #af00ff;">' </span><span style="color: #0000ff;">FOO </span>,
</pre>
</div>

<p>
это способ добавить <code>codeword</code> FOO к текущему слову, которое мы определяем (это
работает только в компилируемом коде).
</p>

<p>
Вы, как правило, используете ' в IMMEDIATE словах. Например, альтернативный (и довольно
бесполезный) способ определения литерала 2 может быть:
</p>

<div class="org-src-container">

<pre class="src src-forth">: LIT2 <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>LIT ,   <span style="color: #af0000;">\ &#1044;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; LIT &#1082; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1103;&#1077;&#1084;&#1086;&#1084;&#1091; &#1074; &#1085;&#1072;&#1089;&#1090;&#1086;&#1103;&#1097;&#1080;&#1081; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090; &#1089;&#1083;&#1086;&#1074;&#1091;
</span>    <span style="color: #008787;">2 </span>,       <span style="color: #af0000;">\ &#1044;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1095;&#1080;&#1089;&#1083;&#1086; 2 &#1082; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1103;&#1077;&#1084;&#1086;&#1084;&#1091; &#1074; &#1085;&#1072;&#1089;&#1090;&#1086;&#1103;&#1097;&#1080;&#1081; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090; &#1089;&#1083;&#1086;&#1074;&#1091;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Таким образом, вы можете сделать:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE LIT2 * <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
(Если вы не понимаете, как работает LIT2, вы должны просмотреть материал о компиляции
слов и немедленном режиме).
</p>

<p>
Это ассемблерное определение ' использует чит, который я скопировал из buzzard92. В
результате он работает только в скомпилированном коде. Можно написать версию ' на
основе WORD, FIND, &gt;CFA, которая также работает в непосредственном режиме.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_tick"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"'"</span>,1,,TICK
    <span style="color: #af00ff;">lodsl</span>                   # &#1055;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; &#1080; &#1087;&#1088;&#1086;&#1087;&#1091;&#1089;&#1090;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086;
    <span style="color: #af00ff;">pushl</span>    <span style="color: #af5f00;">%eax</span>           # Push &#1077;&#1075;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-21" class="outline-3">
<h3 id="unnumbered-21">Ветвление</h3>
<div class="outline-text-3" id="text-unnumbered-21">
<p>
Оказывается, все, что вам нужно для определения циклов, IF-выражений и.т.д. - это два
примитива.
</p>

<p>
BRANCH - безусловная ветвь (эквивалентная команде безусловного перехода
ассемблера). 0BRANCH - условная ветвь (переход будет осуществлен, если значение на
вершине стека равно нулю).
</p>

<p>
Диаграмма ниже показывает, как BRANCH работает в некотором мнимом скомпилированном
слове. Когда BRANCH выполняется, <code>%esi</code> начинается с указания на поле смещения
(сравните с LIT выше):
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-27.png" alt="forth-interpret-27.png">
</p>
</div>

<p>
Смещение добавляется в <code>%esi</code>, чтобы создать новый <code>%esi</code>, и результатом является то,
что при выполнении NEXT выполнение продолжается по целевому адресу ветки. Отрицательные
смещения тоже работают, как ожидается.
</p>

<p>
0BRANCH - это то же самое, за исключением того, что ветвление происходит по условию.
</p>

<p>
Теперь стандартные FORTH слова, такие как IF, THEN, ELSE, WHILE, REPEAT и т. Д., Могут
быть полностью реализованы в FORTH. Это НЕМЕДЛЕННЫЕ слова, которые добавляют различные
комбинации BRANCH или 0BRANCH в слово, которое в настоящее время компилируется.
</p>

<p>
Например, код, написанный следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition-code IF true-part <span style="color: #ff0000; font-weight: bold;">THEN </span>rest-code
</pre>
</div>

<p>
компилируется в:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-28.png" alt="forth-interpret-28.png">
</p>
</div>

<p>
Вот определение:
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_branch"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"BRANCH"</span>,6,,BRANCH
    <span style="color: #af00ff;">add</span>     (<span style="color: #af5f00;">%esi</span>),<span style="color: #af5f00;">%esi</span>     # add the offset to the instruction pointer
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"0BRANCH"</span>,7,,ZBRANCH
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, eax       # top of stack is zero?
    <span style="color: #af00ff;">jz</span>      code_BRANCH     # if so, jump back to the branch function above
    <span style="color: #af00ff;">lodsl</span>                   # otherwise we need to skip the offset
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-22" class="outline-3">
<h3 id="unnumbered-22">Строковые литералы</h3>
<div class="outline-text-3" id="text-unnumbered-22">
<p>
LITSTRING - это примитив, используемый для реализации операторов ~."~ И ~S"~ (которые
написаны в формате FORTH). См. ниже определение этих операторов.
</p>

<p>
TELL просто печатает строку. Это более эффективно определять в ассемблере, потому что
мы можем сделать это одним из системных вызовов Linux.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_lit"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"LITSTRING"</span>,9,,LITSTRING
    <span style="color: #af00ff;">lodsl</span>                   # get the length of the string
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%esi</span>            # push the address of the start of the string
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # push it on the stack
    <span style="color: #af00ff;">addl</span>    <span style="color: #af5f00;">%eax</span>,<span style="color: #af5f00;">%esi</span>       # skip past the string
    <span style="color: #af00ff;">addl</span>    $3,<span style="color: #af5f00;">%esi</span>         # but round up to next 4 byte boundary
    <span style="color: #af00ff;">andl</span>    $~3,<span style="color: #af5f00;">%esi</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"TELL"</span>,4,,TELL
    <span style="color: #af00ff;">mov</span>     $1,<span style="color: #af5f00;">%ebx</span>         # 1st param: stdout
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edx</span>            # 3rd param: length of string
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # 2nd param: address of string
    <span style="color: #af00ff;">mov</span>     $__NR_write,<span style="color: #af5f00;">%eax</span>    # write syscall
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-23" class="outline-3">
<h3 id="unnumbered-23">QUIT и INTERPRET</h3>
<div class="outline-text-3" id="text-unnumbered-23">
<p>
QUIT - первая функция FORTH, вызываемая почти сразу после того, как система FORTH
"загружается". Как объяснялось ранее, QUIT никуда не "уходит". Она выполняет некоторую
инициализацию (в частности, он очищает возвращаемый стек), и вызывает INTERPRET в цикле
для интерпретации команд. Причина, по которой он называется QUIT, заключается в том,
что вы можете вызвать его из собственных слов FORTH, чтобы "выйти" из вашей программы и
начать снова работать в режиме приема команд от пользователя.
</p>

<p>
INTERPRET является REPL (см.: <a href="http://en.wikipedia.org/wiki/REPL">http://en.wikipedia.org/wiki/REPL</a>) внутри FORTH.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_quit"># QUIT must not return (ie. must not call EXIT).
<span style="color: #0000ff;">defword</span> <span style="color: #87005f;">"QUIT"</span>,4,,QUIT
    <span style="color: #af00ff;">.int</span> RZ,RSPSTORE    # R0 RSP!, clear the return stack
    <span style="color: #af00ff;">.int</span> INTERPRET      # interpret the next word
    <span style="color: #af00ff;">.int</span> BRANCH,-8      # and loop (indefinitely)
</pre>
</div>

<p>
Этот интерпретатор довольно прост, но помните, что в FORTH вы всегда можете
переопределить его более мощным!
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_interpret"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"INTERPRET"</span>,9,,INTERPRET
    <span style="color: #af00ff;">call</span>    _WORD           # Returns <span style="color: #af5f00;">%ecx</span> = length, <span style="color: #af5f00;">%edi</span> = pointer to word.

    # Is it in the dictionary?
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, interpret_is_lit  # Not a literal number (not yet anyway ...)
    <span style="color: #af00ff;">call</span>    _FIND           # Returns <span style="color: #af5f00;">%eax</span> = pointer to header or 0 if not found.
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>      # Found?
    <span style="color: #af00ff;">jz</span>  1f

    # In the dictionary.  Is it an IMMEDIATE codeword?
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%edi</span>      # <span style="color: #af5f00;">%edi</span> = dictionary entry
    <span style="color: #af00ff;">movb</span>    4(<span style="color: #af5f00;">%edi</span>), <span style="color: #af5f00;">%al</span>    # Get name+flags.
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ax</span>             # Just save it for now.
    <span style="color: #af00ff;">call</span>    _TCFA           # Convert dictionary entry (in <span style="color: #af5f00;">%edi</span>) to codeword pointer.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ax</span>
    <span style="color: #af00ff;">andb</span>    $F_IMMED, <span style="color: #af5f00;">%al</span>   # Is IMMED flag set?
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%edi</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">jnz</span>     4f              # If IMMED, jump straight to executing.

    <span style="color: #af00ff;">jmp</span> 2f

<span style="color: #0000ff;">1</span>:
    # Not in the dictionary (not a word) so assume it's a literal number.
    <span style="color: #af00ff;">incl</span>    interpret_is_lit
    <span style="color: #af00ff;">call</span>    _NUMBER         # Returns the parsed number in <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ecx</span> &gt; 0 if error
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%ecx</span>, <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">jnz</span>     6f
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">mov</span>     $LIT, <span style="color: #af5f00;">%eax</span>      # The word is LIT

<span style="color: #0000ff;">2</span>:
    # Are we compiling or executing?
    <span style="color: #af00ff;">movl</span>    var_STATE, <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">jz</span>  4f                  # Jump if executing.

    # Compiling - just append the word to the current dictionary definition.
    <span style="color: #af00ff;">call</span>    _COMMA
    <span style="color: #af00ff;">mov</span>     interpret_is_lit, <span style="color: #af5f00;">%ecx</span> # Was it a literal?
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%ecx</span>, <span style="color: #af5f00;">%ecx</span>
    <span style="color: #af00ff;">jz</span>  3f
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%eax</span>      # Yes, so LIT is followed by a number.
    <span style="color: #af00ff;">call</span>    _COMMA
<span style="color: #0000ff;">3</span>:
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">4</span>:
    # Executing - run it!
    <span style="color: #af00ff;">mov</span>     interpret_is_lit, <span style="color: #af5f00;">%ecx</span> # Literal?
    <span style="color: #af00ff;">test</span>    <span style="color: #af5f00;">%ecx</span>, <span style="color: #af5f00;">%ecx</span>      # Literal?
    <span style="color: #af00ff;">jnz</span>     5f

    # Not a literal, execute it now.  This never returns, but the codeword will
    # eventually call NEXT which will reenter the loop in QUIT.
    <span style="color: #af00ff;">jmp</span>     *(<span style="color: #af5f00;">%eax</span>)

<span style="color: #0000ff;">5</span>:
    # Executing a literal, which means push it on the stack.
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%ebx</span>
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">6</span>:
    # Parse error (not a known word or a number in the current BASE).
    # Print an error message followed by up to 40 characters of context.
    <span style="color: #af00ff;">mov</span>     $2, <span style="color: #af5f00;">%ebx</span>        # 1st param: stderr
    <span style="color: #af00ff;">mov</span>     $errmsg, <span style="color: #af5f00;">%ecx</span>   # 2nd param: error message
    <span style="color: #af00ff;">mov</span>     $errmsgend-errmsg, <span style="color: #af5f00;">%edx</span> # 3rd param: length of string
    <span style="color: #af00ff;">mov</span>     $__NR_write, <span style="color: #af5f00;">%eax</span>    # write syscall
    <span style="color: #af00ff;">int</span>     $0x80

    <span style="color: #af00ff;">mov</span>     (currkey), <span style="color: #af5f00;">%ecx</span> # the error occurred just before currkey position
    <span style="color: #af00ff;">mov</span>     <span style="color: #af5f00;">%ecx</span>, <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">sub</span>     $buffer, <span style="color: #af5f00;">%edx</span>   # <span style="color: #af5f00;">%edx</span> = currkey - buffer (length in buffer before currkey)
    <span style="color: #af00ff;">cmp</span>     $40, <span style="color: #af5f00;">%edx</span>       # if &gt; 40, then print only 40 characters
    <span style="color: #af00ff;">jle</span>     7f
    <span style="color: #af00ff;">mov</span>     $40, <span style="color: #af5f00;">%edx</span>
<span style="color: #0000ff;">7</span>:
    <span style="color: #af00ff;">sub</span>     <span style="color: #af5f00;">%edx</span>, <span style="color: #af5f00;">%ecx</span>      # <span style="color: #af5f00;">%ecx</span> = start of area to print, <span style="color: #af5f00;">%edx</span> = length
    <span style="color: #af00ff;">mov</span>     $__NR_write, <span style="color: #af5f00;">%eax</span>    # write syscall
    <span style="color: #af00ff;">int</span>     $0x80

    <span style="color: #af00ff;">mov</span>     $errmsgnl, <span style="color: #af5f00;">%ecx</span> # newline
    <span style="color: #af00ff;">mov</span>     $1, <span style="color: #af5f00;">%edx</span>
    <span style="color: #af00ff;">mov</span>     $__NR_write, <span style="color: #af5f00;">%eax</span>    # write syscall
    <span style="color: #af00ff;">int</span>     $0x80

    <span style="color: #af00ff;">NEXT</span>

    <span style="color: #af00ff;">.section</span> .rodata
<span style="color: #0000ff;">errmsg</span>:  .ascii <span style="color: #87005f;">"PARSE ERROR: "</span>
<span style="color: #0000ff;">errmsgend</span>:
<span style="color: #0000ff;">errmsgnl</span>:    .ascii <span style="color: #87005f;">"\n"</span>

    <span style="color: #af00ff;">.data</span>                   # NB: easier to fit in the .data section
    <span style="color: #af00ff;">.align</span> 4
<span style="color: #0000ff;">interpret_is_lit</span>:
    <span style="color: #af00ff;">.int</span> 0                  # Flag used to record if reading a literal
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-24" class="outline-3">
<h3 id="unnumbered-24">ODDS и ENDS</h3>
<div class="outline-text-3" id="text-unnumbered-24">
<p>
CHAR помещает код ASCII первого символа следующего слова в стек. Например, <code>CHAR A</code>
кладет 65 в стек.
</p>

<p>
EXECUTE используется для запуска токенов выполнения. См. обсуждение токенов выполнения
в коде FORTH для получения более подробной информации.
</p>

<p>
SYSCALL0, SYSCALL1, SYSCALL2, SYSCALL3 делают стандартный системный вызов Linux.  (См.
список номеров системных вызовов). Как видно из названия, эти формы занимают от 0 до 3
параметров syscall, а также номер системного вызова.
</p>

<p>
В этом FORTH SYSCALL0 должен быть последним словом во встроенном (ассемблерном)
словаре, потому что мы инициализируем переменную LATEST, чтобы указать на нее. Это
означает, что если вы хотите расширить ассемблерную часть, вы должны поместить новые
слова перед SYSCALL0 или изменить способ инициализации LATEST.
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_sys"><span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"CHAR"</span>,4,,CHAR
    <span style="color: #af00ff;">call</span>    _WORD           # Returns <span style="color: #af5f00;">%ecx</span> = length, <span style="color: #af5f00;">%edi</span> = pointer to word.
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">movb</span>    (<span style="color: #af5f00;">%edi</span>), <span style="color: #af5f00;">%al</span>     # Get the first character of the word.
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # Push it onto the stack.
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"EXECUTE"</span>,7,,EXECUTE
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # Get xt into <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">jmp</span>     *(<span style="color: #af5f00;">%eax</span>)         # and jump to it.
    # After xt runs its NEXT will continue executing the current word.

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"SYSCALL3"</span>,8,,SYSCALL3
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # System call number (see &lt;asm/unistd.h&gt;)
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # First parameter.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # Second parameter
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%edx</span>            # Third parameter
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # Result (negative for -errno)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"SYSCALL2"</span>,8,,SYSCALL2
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # System call number (see &lt;asm/unistd.h&gt;)
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # First parameter.
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ecx</span>            # Second parameter
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # Result (negative for -errno)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"SYSCALL1"</span>,8,,SYSCALL1
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # System call number (see &lt;asm/unistd.h&gt;)
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%ebx</span>            # First parameter.
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # Result (negative for -errno)
    <span style="color: #af00ff;">NEXT</span>

<span style="color: #0000ff;">defcode</span> <span style="color: #87005f;">"SYSCALL0"</span>,8,,SYSCALL0
    <span style="color: #af00ff;">pop</span>     <span style="color: #af5f00;">%eax</span>            # System call number (see &lt;asm/unistd.h&gt;)
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">push</span>    <span style="color: #af5f00;">%eax</span>            # Result (negative for -errno)
    <span style="color: #af00ff;">NEXT</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-25" class="outline-3">
<h3 id="unnumbered-25">Сегмент данных</h3>
<div class="outline-text-3" id="text-unnumbered-25">
<p>
Здесь мы настраиваем сегмент данных Linux, используемый для пользовательских
определений и по-разному известный как "data segment", "user memory" или "user
definitions area". Это область памяти, которая растет вверх и хранит как вновь
определенные слова FORTH, так и глобальные переменные различного рода.
</p>

<p>
Это полностью аналогично "кучe" в языке Си, за исключением того, что не существует
обобщенного «malloc» и «free» (но, как и все в FORTH, написать такие функции просто
было бы простым вопросом программирования). Вместо этого в обычном использовании
сегмент данных просто растет вверх, когда к нему добавляются/определяются новые слова
FORTH.
</p>

<p>
Cуществуют различные "возможности" тулчейна GNU, которые делают настройку сегмента
данных более сложной, чем это действительно необходимо. Одним из них является
GNU-компоновщик, который вставляет случайный "build ID" сегмент . Другим является
рандомизация адресного пространства (ASLR), что означает, что мы не можем определить,
где ядро поместит сегмент данных (или, например, стека).
</p>

<p>
Поэтому запись этой ассемблерной процедуры <code>set_up_data_segment</code> немного сложнее, чем
это действительно должно быть. Мы спрашиваем ядро Linux, где начинается сегмент данных,
используя для этого системный вызов brk(2), затем просим зарезервировать некоторое
начальное пространство (также используя brk(2)).
</p>

<div class="org-src-container">

<pre class="src src-asm" id="word_sys">    <span style="color: #af00ff;">.text</span>
    <span style="color: #af00ff;">.set</span> INITIAL_DATA_SEGMENT_SIZE,65536
<span style="color: #0000ff;">set_up_data_segment</span>:
    <span style="color: #af00ff;">xor</span>     <span style="color: #af5f00;">%ebx</span>, <span style="color: #af5f00;">%ebx</span>      # Call brk(0)
    <span style="color: #af00ff;">movl</span>    $__NR_brk, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, var_HERE  # Initialise HERE to point at beginning of data segment.
    <span style="color: #af00ff;">addl</span>    $INITIAL_DATA_SEGMENT_SIZE, <span style="color: #af5f00;">%eax</span>  # Reserve nn bytes of memory for initial data segment.
    <span style="color: #af00ff;">movl</span>    <span style="color: #af5f00;">%eax</span>, <span style="color: #af5f00;">%ebx</span>      # Call brk(HERE+INITIAL_DATA_SEGMENT_SIZE)
    <span style="color: #af00ff;">movl</span>    $__NR_brk, <span style="color: #af5f00;">%eax</span>
    <span style="color: #af00ff;">int</span>     $0x80
    <span style="color: #af00ff;">ret</span>

    <span style="color: #af0000;">/*</span>
<span style="color: #af0000;">    We allocate static buffers for the return static and input buffer (used when</span>
<span style="color: #af0000;">    reading in files and text that the user types in).</span>
<span style="color: #af0000;">    */</span>
    <span style="color: #af00ff;">.set</span> RETURN_STACK_SIZE,8192
    <span style="color: #af00ff;">.set</span> BUFFER_SIZE,4096

    <span style="color: #af00ff;">.bss</span>
    <span style="color: #af0000;">/* </span><span style="color: #af0000;">FORTH return stack. */</span>
    <span style="color: #af00ff;">.align</span> 4096
<span style="color: #0000ff;">return_stack</span>:
    <span style="color: #af00ff;">.space</span> RETURN_STACK_SIZE
<span style="color: #0000ff;">return_stack_top</span>:           # Initial top of return stack.

    <span style="color: #af0000;">/* </span><span style="color: #af0000;">This is used as a temporary input buffer when reading from files or the terminal. */</span>
    <span style="color: #af00ff;">.align</span> 4096
<span style="color: #0000ff;">buffer</span>:
    <span style="color: #af00ff;">.space</span> BUFFER_SIZE
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-26" class="outline-2">
<h2 id="unnumbered-26">Forth-код</h2>
<div class="outline-text-2" id="text-unnumbered-26">
<p>
Теперь мы достигли стадии, на которой работает self-hosted FORTH. Все дальнейшие слова
могут быть записаны как слова FORTH, включая такие слова, как IF, THEN, и.т.д., которые
на большинстве языков будут считаться весьма фундаментальными.
</p>

<p>
Некоторые примечания о коде:
</p>

<p>
Я использую отступы для отображения структуры. Количество пробелов не имеет никакого
значения для FORTH, кроме того, кроме того, что вы должны использовать по крайней мере
один пробельный символ между словами, а сами слова не могут содержать пробелы. FORTH
чувствителен к регистру. Используйте CAPS LOCK.
</p>
</div>

<div id="outline-container-unnumbered-27" class="outline-3">
<h3 id="unnumbered-27">DIVMOD</h3>
<div class="outline-text-3" id="text-unnumbered-27">
<p>
Примитивное слово <code>/MOD</code> (DIVMOD) оставляет как частное, так и остаток в стеке. (В i386
команда idivl дает оба значения). Теперь мы можем определить <code>/</code> и <code>MOD</code> на основе
<code>/MOD</code> и нескольких других примитивов.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth-divmod">: / /MOD SWAP DROP <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">MOD </span>/MOD DROP <span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-28" class="outline-3">
<h3 id="unnumbered-28">Символьные константы</h3>
<div class="outline-text-3" id="text-unnumbered-28">
<p>
Определим некоторые символьные константы:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth-some-constants">: '\n' 10 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">BL </span>  32 ; <span style="color: #af0000;">\ BL (BLank) &#1089;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#1076;&#1083;&#1103; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1072;
</span>
<span style="color: #af0000;">\ CR &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1090; &#1082;&#1072;&#1088;&#1077;&#1090;&#1082;&#1080;
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">CR </span>'\n' EMIT <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">\ SPACE &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">SPACE </span>BL EMIT <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">\ NEGATE &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077; &#1086;&#1073;&#1088;&#1072;&#1090;&#1085;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1090;&#1086;&#1084;, &#1095;&#1090;&#1086; &#1073;&#1099;&#1083;&#1086; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077;
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">NEGATE </span>0 SWAP - <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">\ &#1057;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1099;&#1077; &#1089;&#1083;&#1086;&#1074;&#1072; &#1076;&#1083;&#1103; &#1073;&#1091;&#1083;&#1077;&#1074;&#1099;&#1093; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1081;.
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">TRUE </span> 1 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">FALSE </span>0 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">NOT </span>  0= <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">\ LITERAL &#1073;&#1077;&#1088;&#1077;&#1090; &#1090;&#1086;, &#1095;&#1090;&#1086; &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1090;&#1089;&#1103; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; (&lt;foo&gt;) &#1080; &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1090; &#1082;&#1072;&#1082; LIT &lt;foo&gt;
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">LITERAL </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>LIT ,      <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1090; LIT
</span>    ,            <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1090; &#1089;&#1072;&#1084; &#1083;&#1080;&#1090;&#1077;&#1088;&#1072;&#1083; (&#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072;)
</span><span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Теперь мы можем использовать <code>[</code> и <code>]</code> для вставки литералов, которые вычисляются во
время компиляции. (Вспомните, что <code>[</code> и <code>]</code> являются словами FORTH, которые
переключаются в и из <code>непосредственного режима</code>.)
</p>

<p>
В пределах определений используйте <code>[</code> &#x2026; <code>]</code> LITERAL, где "&#x2026;" - это константное
выражение, которое вы, скорее всего, вычислите один раз (во время компиляции, чтобы не
вычислять его каждый раз, когда выполняется ваше слово).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_literal_colon"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">':'
</span>    <span style="color: #af00ff;">[ </span>        <span style="color: #af0000;">\ &#1074;&#1093;&#1086;&#1076;&#1080;&#1084; &#1074; immediate mode (&#1074;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;)
</span>    <span style="color: #af00ff;">CHAR </span><span style="color: #87005f;">: </span>   <span style="color: #af0000;">\ push 58 (ASCII code of ":") &#1074; &#1089;&#1090;&#1077;&#1082; &#1087;&#1072;&#1088;&#1072;&#1084;&#1077;&#1090;&#1088;&#1086;&#1074;
</span>    <span style="color: #af00ff;">] </span>        <span style="color: #af0000;">\ &#1087;&#1077;&#1088;&#1077;&#1093;&#1086;&#1076;&#1080;&#1084; &#1085;&#1072;&#1079;&#1072;&#1076; &#1074; compile mode
</span>    LITERAL   <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; LIT 58 &#1082;&#1072;&#1082; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1077;&#1085;&#1080;&#1103; ':' &#1089;&#1083;&#1086;&#1074;&#1072;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Еще несколько символьных констант определены так же, как указано выше.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_literals">: ';' [ CHAR ; ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'(' </span>[ CHAR ( ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">')' </span>[ CHAR ) ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'"' </span>[ CHAR " ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'A' </span>[ CHAR A ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'0' </span>[ CHAR 0 ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'-' </span>[ CHAR - ] LITERAL <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">'.' </span>[ CHAR . ] LITERAL <span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-29" class="outline-3">
<h3 id="unnumbered-29">COMPILE</h3>
<div class="outline-text-3" id="text-unnumbered-29">
<p>
При компиляции <code>[ COMPILE ] word</code> компилирует <code>word</code>, в противном случае (при
интерпретации) исполняет его "НЕМЕДЛЕННО".
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_compile">: [COMPILE] <span style="color: #af00ff;">IMMEDIATE</span>
    WORD        <span style="color: #af0000;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086;
</span>    FIND        <span style="color: #af0000;">\ &#1085;&#1072;&#1081;&#1090;&#1080; &#1077;&#1075;&#1086; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077;
</span>    &gt;CFA        <span style="color: #af0000;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; codeword
</span>    ,           <span style="color: #af0000;">\ &#1080; &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1077;&#1075;&#1086;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-30" class="outline-3">
<h3 id="unnumbered-30">RECURSE</h3>
<div class="outline-text-3" id="text-unnumbered-30">
<p>
RECURSE делает рекурсивный вызов текущему слову, которое компилируется.
</p>

<p>
Обычно, когда слово компилируется, оно помечено как HIDDEN, так что ссылки на одно и то
же слово внутри являются вызовами предыдущего определения слова (если таковое
есть). Однако у нас все еще есть доступ к слову, которое мы сейчас компилируем с
помощью LATEST-указателя, поэтому мы можем использовать его для компиляции рекурсивного
вызова.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_recurse">: RECURSE <span style="color: #af00ff;">IMMEDIATE</span>
    LATEST @  <span style="color: #af0000;">\ LATEST &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1090; &#1085;&#1072; &#1089;&#1083;&#1086;&#1074;&#1086;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084;&#1086;&#1077; &#1074; &#1076;&#1072;&#1085;&#1085;&#1099;&#1081; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090;
</span>    &gt;CFA      <span style="color: #af0000;">\ &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; codeword
</span>    ,         <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1091;&#1077;&#1084; &#1077;&#1075;&#1086;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-31" class="outline-3">
<h3 id="unnumbered-31">Управляющие выражения</h3>
<div class="outline-text-3" id="text-unnumbered-31">
<p>
Пока мы определили только очень простые определения. Прежде чем мы сможем идти дальше,
нам нужно сделать некоторые управляющие структуры, например <code>IF ... THEN</code> и <code>LOOP</code>. К
счастью, мы можем определить произвольные элементы управления структуры
непосредственно в FORTH.
</p>

<p>
Обратите внимание, что структуры управления, так, как я их определил, будут работать
только внутри компилируемых слов. Если вы попытаетесь ввести выражения с использованием
IF и.т.д. в непосредственном режиме, то они не будут работать. Выполнение этих операций
в непосредственном режиме остается в качестве упражнения для читателя.
</p>

<p>
Условное выражение вида:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition IF true-part <span style="color: #ff0000; font-weight: bold;">THEN </span>rest
</pre>
</div>

<p>
компилируется в:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition 0BRANCH OFFSET true-part rest
</pre>
</div>

<p>
где OFFSET - это смещение <code>rest</code>
</p>

<p>
А условное выражение вида:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition IF true-part ELSE false-part <span style="color: #ff0000; font-weight: bold;">THEN</span>
</pre>
</div>

<p>
компилируется в:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition 0BRANCH OFFSET true-part BRANCH OFFSET2 false-part rest
</pre>
</div>

<p>
где <code>OFFSET</code> - это смещение <code>false-part</code> и <code>OFFSET2</code> - это смещение <code>rest</code>.
</p>

<p>
IF - это НЕМЕДЛЕННОЕ слово, которое компилирует 0BRANCH, за которым следует фиктивное
смещение, и помещает адрес 0BRANCH в стек. Позже, когда мы увидим THEN, мы вытолкнем
этот адрес из стека, вычислим смещение и заполним смещение.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_if">: IF <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>0BRANCH ,    <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @         <span style="color: #af0000;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1103; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    <span style="color: #008787;">0 </span>,            <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">THEN </span><span style="color: #af00ff;">IMMEDIATE</span>
    DUP
    HERE @ SWAP -  <span style="color: #af0000;">\ &#1088;&#1072;&#1089;&#1089;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1086;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;
</span>    SWAP !         <span style="color: #af0000;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1074; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1077;&#1085;&#1086;&#1084; &#1084;&#1077;&#1089;&#1090;&#1077;
</span><span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ELSE </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>BRANCH ,     <span style="color: #af0000;">\ &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1080;&#1090;&#1100; &#1074;&#1077;&#1090;&#1074;&#1100; &#1076;&#1086; false-part
</span>    HERE @         <span style="color: #af0000;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1084;&#1077;&#1089;&#1090;&#1086;&#1087;&#1086;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1103; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>        <span style="color: #008787;">0 </span>,        <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span>        SWAP       <span style="color: #af0000;">\ &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1100; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; (IF) &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span>        DUP        <span style="color: #af0000;">\ &#1090;&#1086; &#1078;&#1077; &#1095;&#1090;&#1086; &#1080; &#1076;&#1083;&#1103; THEN &#1074;&#1099;&#1096;&#1077;
</span>    HERE @ SWAP -
    SWAP !
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-32" class="outline-3">
<h3 id="unnumbered-32">Циклы</h3>
<div class="outline-text-3" id="text-unnumbered-32">
<p>
Переходим к циклам:
</p>
</div>

<div id="outline-container-unnumbered-33" class="outline-4">
<h4 id="unnumbered-33">BEGIN - UNTIL</h4>
<div class="outline-text-4" id="text-unnumbered-33">
<div class="org-src-container">

<pre class="src src-forth">BEGIN loop-part condition <span style="color: #ff0000; font-weight: bold;">UNTIL</span>
</pre>
</div>

<p>
компилируется в:
</p>

<div class="org-src-container">

<pre class="src src-forth">loop-part condition 0BRANCH OFFSET
</pre>
</div>

<p>
где <code>OFFSET</code> указатель обратно на <code>loop-part</code>. Это похоже на следующий пример из Си:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #af00ff;">do</span> {
    loop-part
} <span style="color: #af00ff;">while</span> (condition)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="forth_begin_until">: BEGIN <span style="color: #af00ff;">IMMEDIATE</span>
    HERE @       <span style="color: #af0000;">\ &#1057;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; location &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span><span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">UNTIL </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>0BRANCH ,  <span style="color: #af0000;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @ -     <span style="color: #af0000;">\ &#1088;&#1072;&#1089;&#1089;&#1095;&#1080;&#1090;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1086;&#1090; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1072; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    ,            <span style="color: #af0000;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-34" class="outline-4">
<h4 id="unnumbered-34">BEGIN - AGAIN</h4>
<div class="outline-text-4" id="text-unnumbered-34">
<div class="org-src-container">

<pre class="src src-forth">BEGIN loop-part <span style="color: #ff0000; font-weight: bold;">AGAIN</span>
</pre>
</div>

<p>
компилируется в:
</p>

<div class="org-src-container">

<pre class="src src-forth">loop-part BRANCH OFFSET
</pre>
</div>

<p>
где <code>OFFSET</code> указатель обратно на <code>loop-part</code>. Другими словами, есконечный цикл, которй
может быть прерван только вызвом EXIT
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_again">: AGAIN <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>BRANCH , <span style="color: #af0000;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; BRANCH
</span>    HERE @ -   <span style="color: #af0000;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072;&#1079;&#1072;&#1076;
</span>    ,          <span style="color: #af0000;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-35" class="outline-4">
<h4 id="unnumbered-35">BEGIN - WHILE - REPEAT</h4>
<div class="outline-text-4" id="text-unnumbered-35">
<div class="org-src-container">

<pre class="src src-forth">BEGIN condition WHILE loop-part <span style="color: #ff0000; font-weight: bold;">REPEAT</span>
</pre>
</div>

<p>
компилируется в:
</p>

<div class="org-src-container">

<pre class="src src-forth">condition 0BRANCH OFFSET2 loop-part BRANCH OFFSET
</pre>
</div>

<p>
где OFFSET указывает назад на условие (в начало) и OFFSET2 указывает в конец, на
позицию после всего фрагмента кода. Это похоже на следующий пример из Си:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #af00ff;">while</span> (condition) {
    loop-part
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-forth" id="forth_while_repeat">: WHILE <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>0BRANCH ,   <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; 0BRANCH
</span>    HERE @        <span style="color: #af0000;">\ &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; offset2 &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</span>    <span style="color: #008787;">0 </span>,           <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1092;&#1080;&#1082;&#1090;&#1080;&#1074;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; offset2
</span><span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">REPEAT </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>BRANCH ,    <span style="color: #af0000;">\ &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; BRANCH
</span>    SWAP          <span style="color: #af0000;">\ &#1074;&#1079;&#1103;&#1090;&#1100; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1089;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077; (from BEGIN)
</span>    HERE @ - ,    <span style="color: #af0000;">\ &#1080; &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1077;&#1075;&#1086; &#1087;&#1086;&#1089;&#1083;&#1077; BRANCH
</span>    DUP
    HERE @ SWAP - <span style="color: #af0000;">\ &#1074;&#1099;&#1095;&#1080;&#1089;&#1083;&#1080;&#1090;&#1100; offset2
</span>    SWAP !        <span style="color: #af0000;">\ &#1080; &#1079;&#1072;&#1087;&#1086;&#1083;&#1085;&#1080;&#1090;&#1100; &#1080;&#1084; &#1086;&#1088;&#1080;&#1075;&#1080;&#1085;&#1072;&#1083;&#1100;&#1085;&#1091;&#1102; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-36" class="outline-3">
<h3 id="unnumbered-36">Unless</h3>
<div class="outline-text-3" id="text-unnumbered-36">
<p>
UNLESS будет таким же как IF, но тест будет наоборот.
</p>

<p>
Обратите внимание на использование [COMPILE]: Поскольку IF является IMMEDIATE, мы не
хотим, чтобы он выполнялся, пока UNLESS компилируется, но пока UNLESS работает (что
случается, когда любое слово, использующее UNLESS, компилируется). Поэтому мы
используем [COMPILE] для обращения эффекта, который оказывает маркировка IF как
IMMEDIATE.  Этот трюк обычно используется, когда мы хотим написать собственные
контрольные слова, без необходимости реализовывать их, опираясь на примитивы 0BRANCH и
BRANCH, а вместо этого используем более простые управляющие слова, такие как (в данном
случае) IF.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_unless">: UNLESS <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>NOT ,        <span style="color: #af0000;">\ &#1089;&#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; NOT (&#1095;&#1090;&#1086;&#1073;&#1099; &#1086;&#1073;&#1088;&#1072;&#1090;&#1080;&#1090;&#1100; test)
</span>    <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">IF </span>  <span style="color: #af0000;">\ &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1080;&#1090;&#1100;, &#1074;&#1099;&#1079;&#1099;&#1074;&#1072;&#1074; &#1086;&#1073;&#1099;&#1095;&#1085;&#1099;&#1081; IF
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-37" class="outline-3">
<h3 id="unnumbered-37">Комментарии</h3>
<div class="outline-text-3" id="text-unnumbered-37">
<p>
FORTH допускает комментарии вида <code>(...)</code> в определениях функций. Это работает путем
вызова <code>IMMEDIATE word (</code>, который просто отбрасывает входные символы до тех пор, пока
не попадет на соответствующий <code>)</code>.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_parens">: ( <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #008787;">1 </span>                 <span style="color: #af0000;">\ &#1088;&#1072;&#1079;&#1088;&#1077;&#1096;&#1077;&#1085;&#1099; &#1074;&#1083;&#1086;&#1078;&#1077;&#1085;&#1085;&#1099;&#1077; &#1082;&#1086;&#1084;&#1084;&#1077;&#1085;&#1090;&#1072;&#1088;&#1080;&#1080; &#1087;&#1091;&#1090;&#1077;&#1084; &#1086;&#1090;&#1089;&#1083;&#1077;&#1078;&#1080;&#1074;&#1072;&#1085;&#1080;&#1103; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1099;
</span>    <span style="color: #af00ff;">BEGIN</span>
        KEY            <span style="color: #af0000;">\ &#1087;&#1088;&#1086;&#1095;&#1077;&#1089;&#1090;&#1100; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;
</span>        DUP '(' = <span style="color: #af00ff;">IF </span>  <span style="color: #af0000;">\ &#1086;&#1090;&#1082;&#1088;&#1099;&#1074;&#1072;&#1102;&#1097;&#1072;&#1103; &#1089;&#1082;&#1086;&#1073;&#1082;&#1072;?
</span>            DROP       <span style="color: #af0000;">\ drop &#1077;&#1077;
</span>            1+         <span style="color: #af0000;">\ &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1090;&#1100; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1091;
</span>        <span style="color: #af00ff;">ELSE</span>
            ')' = <span style="color: #af00ff;">IF </span>  <span style="color: #af0000;">\ &#1079;&#1072;&#1082;&#1088;&#1099;&#1074;&#1072;&#1102;&#1097;&#1072;&#1103; &#1089;&#1082;&#1086;&#1073;&#1082;&#1072;?
</span>                1-     <span style="color: #af0000;">\ &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1080;&#1090;&#1100; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1091;
</span>            <span style="color: #af00ff;">THEN</span>
        <span style="color: #af00ff;">THEN</span>
    DUP 0= <span style="color: #af00ff;">UNTIL </span>      <span style="color: #af0000;">\ &#1087;&#1088;&#1086;&#1076;&#1086;&#1083;&#1078;&#1072;&#1090;&#1100; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; &#1076;&#1086;&#1089;&#1090;&#1080;&#1075;&#1085;&#1077;&#1084; &#1085;&#1091;&#1083;&#1077;&#1074;&#1086;&#1081; &#1075;&#1083;&#1091;&#1073;&#1080;&#1085;&#1099;
</span>    DROP               <span style="color: #af0000;">\ drop &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082;
</span><span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-38" class="outline-3">
<h3 id="unnumbered-38">Стековая нотация</h3>
<div class="outline-text-3" id="text-unnumbered-38">
<p>
В стиле FORTH мы также можем использовать <code>(... - ...)</code>, чтобы показать эффекты,
которые имеет слово в стеке параметров. Например:
</p>
<ul class="org-ul">
<li><code>( n -- )</code> означает, что слово потребляет какое-то целое число (n) параметров из стека.
</li>
<li><code>( b a -- c )</code> означает, что слово использует два целых числа (a и b, где a находится
на вершине стека) и возвращает одно целое число (c).
</li>
<li>(&#x2013;) означает, что слово не влияет на стек
</li>
</ul>

<p>
Некоторые более сложные примеры стека, показывающие нотацию стека:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_nip_tuck_pick_spaces_decimal_hex">: NIP ( x y -- y ) SWAP DROP <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">TUCK </span>( x y -- y x y ) SWAP OVER <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">PICK </span><span style="color: #af0000;">( x_u ... x_1 x_0 u -- x_u ... x_1 x_0 x_u )</span>
    1+                  <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091; &#1080;&#1079;-&#1079;&#1072; "u" &#1074; &#1089;&#1090;&#1077;&#1082; )</span>
    <span style="color: #008787;">4 </span>*                 <span style="color: #af0000;">( &#1091;&#1084;&#1085;&#1086;&#1078;&#1080;&#1090;&#1100; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
    DSP@ +              <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1082; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1102; &#1089;&#1090;&#1077;&#1082;&#1072; )</span>
    @                   <span style="color: #af0000;">( &#1080; &#1074;&#1079;&#1103;&#1090;&#1100; )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af0000;">( C &#1087;&#1086;&#1084;&#1086;&#1097;&#1100;&#1102; &#1094;&#1080;&#1082;&#1083;&#1086;&#1074; &#1084;&#1099; &#1084;&#1086;&#1078;&#1077;&#1084; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1085;&#1072;&#1087;&#1080;&#1089;&#1072;&#1090;&#1100; SPACES, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; N &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1074; stdout )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">SPACES </span>               <span style="color: #af0000;">( n -- )</span>
    <span style="color: #af00ff;">BEGIN</span>
        DUP 0&gt;          <span style="color: #af0000;">( &#1087;&#1086;&#1082;&#1072; n &gt; 0 )</span>
    <span style="color: #af00ff;">WHILE</span>
            SPACE       <span style="color: #af0000;">( &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083; )</span>
            1-          <span style="color: #af0000;">( &#1087;&#1086;&#1074;&#1090;&#1086;&#1088;&#1103;&#1090;&#1100; &#1089; &#1091;&#1084;&#1077;&#1085;&#1100;&#1096;&#1077;&#1085;&#1080;&#1077;&#1084; &#1087;&#1086;&#1082;&#1072; &#1085;&#1077; 0 )</span>
    <span style="color: #af00ff;">REPEAT</span>
    DROP                <span style="color: #af0000;">( &#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1089;&#1095;&#1077;&#1090;&#1095;&#1080;&#1082; &#1089;&#1086; &#1089;&#1090;&#1077;&#1082;&#1072; )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af0000;">( &#1057;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1099;&#1077; &#1089;&#1083;&#1086;&#1074;&#1072; &#1076;&#1083;&#1103; &#1084;&#1072;&#1085;&#1080;&#1087;&#1091;&#1083;&#1103;&#1094;&#1080;&#1080; BASE )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">DECIMAL </span>( -- ) 10 BASE ! <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">HEX </span>    ( -- ) 16 BASE ! <span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-39" class="outline-3">
<h3 id="unnumbered-39">Печать чисел</h3>
<div class="outline-text-3" id="text-unnumbered-39">
<p>
Стандартное слово FORTH <code>.</code> (DOT) очень важно. Он снимает число с вершины стека и
печатает его. Однако сначала я собираюсь реализовать некоторые слова FORTH более
низкого уровня:
</p>
<ul class="org-ul">
<li><code>U.R</code> ( u width &#x2013; )  печатает беззнаковое число, дополненное определенной шириной
</li>
<li><code>U.</code>  ( u &#x2013; )  печатает беззнаковое число
</li>
<li><code>.R</code>  ( n width &#x2013; )  печатает подписанное число, дополненное определенной шириной.
</li>
</ul>

<p>
Например:
</p>

<div class="org-src-container">

<pre class="src src-forth">-123 <span style="color: #008787;">6 </span>.R
</pre>
</div>

<p>
напечатет такие символы:
</p>

<div class="org-src-container">

<pre class="src src-forth">&lt;space&gt; &lt;space&gt; - 1 2 <span style="color: #008787;">3</span>
</pre>
</div>

<p>
Другими словами. число дополнено до определенного количества символов.
</p>

<p>
Полное число печатается, даже если оно шире ширины, и это позволяет нам определить
обычные функции <code>U.</code> и <code>.</code> (мы просто устанавливаем ширину в ноль, зная, что в любом
случае будет напечатано полное число).
</p>

<p>
Еще одна заминка в функции <code>.</code> и ее друзьях - это то, что они подчиняются текущей базе
в переменной BASE. BASE может быть любым в диапазоне от 2 до 36.
</p>

<p>
Пока мы определяем <code>.</code> <code>&amp;c</code> мы также можем определить <code>.S</code> который является полезным
инструментом отладки. Это слово печатает текущий стек (не разрушая его) сверху вниз.
</p>

<p>
Это основное рекурсивное определение <code>U.</code>:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_u_print">: U. <span style="color: #af0000;">( u -- )</span>
    BASE @ /MOD <span style="color: #af0000;">( width rem quot )</span>
    ?DUP <span style="color: #af00ff;">IF </span>    <span style="color: #af0000;">( if quotient &lt;&gt; 0 then )</span>
        RECURSE <span style="color: #af0000;">( print the quotient )</span>
    <span style="color: #af00ff;">THEN</span>

    <span style="color: #af0000;">( &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1086;&#1089;&#1090;&#1072;&#1090;&#1086;&#1082; )</span>
    DUP <span style="color: #008787;">10 </span>&lt; <span style="color: #af00ff;">IF</span>
        '0' <span style="color: #af0000;">( &#1076;&#1077;&#1089;&#1103;&#1090;&#1080;&#1095;&#1085;&#1099;&#1077; &#1094;&#1080;&#1092;&#1088;&#1099; 0..9 )</span>
    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #008787;">10 </span>- <span style="color: #af0000;">( &#1096;&#1077;&#1089;&#1090;&#1085;&#1072;&#1076;&#1094;&#1072;&#1090;&#1080;&#1088;&#1080;&#1095;&#1085;&#1099;&#1077; &#1080; &#1076;&#1088;&#1091;&#1075;&#1080;&#1077; &#1094;&#1080;&#1092;&#1088;&#1099; A..Z )</span>
        'A'
    <span style="color: #af00ff;">THEN</span>
    +
    EMIT
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Слово <code>.S</code> печатает содержимое стека. Оно не меняет стек. Очень полезно для отладки.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_stack_print">: .S <span style="color: #af0000;">( -- )</span>
    DSP@ <span style="color: #af0000;">( &#1074;&#1079;&#1103;&#1090;&#1100; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1081; &#1089;&#1090;&#1077;&#1082;&#1086;&#1074;&#1099;&#1081; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; )</span>
    <span style="color: #af00ff;">BEGIN</span>
        DUP S0 @ &lt;
    <span style="color: #af00ff;">WHILE</span>
            DUP @ U. <span style="color: #af0000;">( &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1080;&#1079; &#1089;&#1090;&#1077;&#1082;&#1072; )</span>
            SPACE
            4+       <span style="color: #af0000;">( &#1076;&#1074;&#1080;&#1075;&#1072;&#1090;&#1100;&#1089;&#1103; &#1076;&#1072;&#1083;&#1100;&#1096;&#1077; )</span>
    <span style="color: #af00ff;">REPEAT</span>
    DROP <span style="color: #af0000;">(&#1089;&#1073;&#1088;&#1086;&#1089;&#1080;&#1090;&#1100; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Это слово возвращает ширину (в символах) числа без знака в текущей базе
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_uwidth_udotr">: UWIDTH <span style="color: #af0000;">( u -- width )</span>
    BASE @ / <span style="color: #af0000;">( rem quot )</span>
    ?DUP <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( if quotient &lt;&gt; 0 then )</span>
        RECURSE 1+ <span style="color: #af0000;">( return 1+recursive call )</span>
    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #008787;">1 </span><span style="color: #af0000;">( return 1 )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">U.R </span><span style="color: #af0000;">( u width -- )</span>
    SWAP <span style="color: #af0000;">( width u )</span>
    DUP <span style="color: #af0000;">( width u u )</span>
    UWIDTH <span style="color: #af0000;">( width u uwidth )</span>
    ROT <span style="color: #af0000;">( u uwidth width )</span>
    SWAP - <span style="color: #af0000;">( u width-uwidth )</span>
    <span style="color: #af0000;">( &#1042; &#1101;&#1090;&#1086;&#1090; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090;, &#1077;&#1089;&#1083;&#1080; &#1079;&#1072;&#1087;&#1088;&#1086;&#1096;&#1077;&#1085;&#1085;&#1072;&#1103; &#1096;&#1080;&#1088;&#1080;&#1085;&#1072; &#1091;&#1078;&#1077;, &#1091; &#1085;&#1072;&#1089; &#1073;&#1091;&#1076;&#1077;&#1090; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;.
    &#1042; &#1087;&#1088;&#1086;&#1090;&#1080;&#1074;&#1085;&#1086;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074; &#1089;&#1090;&#1077;&#1082;&#1077; - &#1101;&#1090;&#1086; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1076;&#1083;&#1103; &#1087;&#1077;&#1095;&#1072;&#1090;&#1080;.
    &#1053;&#1086; SPACES &#1085;&#1077; &#1073;&#1091;&#1076;&#1077;&#1090; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1090;&#1100; &#1086;&#1090;&#1088;&#1080;&#1094;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;&#1077; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1073;&#1077;&#1083;&#1086;&#1074; &#1074; &#1083;&#1102;&#1073;&#1086;&#1084; &#1089;&#1083;&#1091;&#1095;&#1072;&#1077;,
    &#1087;&#1086;&#1101;&#1090;&#1086;&#1084;&#1091; &#1090;&#1077;&#1087;&#1077;&#1088;&#1100; &#1084;&#1086;&#1078;&#1085;&#1086; &#1073;&#1077;&#1079;&#1086;&#1087;&#1072;&#1089;&#1085;&#1086; &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; SPACES ... )</span>
    SPACES
    <span style="color: #af0000;">( ... &#1072; &#1079;&#1072;&#1090;&#1077;&#1084; &#1074;&#1099;&#1079;&#1074;&#1072;&#1090;&#1100; &#1073;&#1072;&#1079;&#1086;&#1074;&#1091;&#1102; &#1088;&#1077;&#1072;&#1083;&#1080;&#1079;&#1072;&#1094;&#1080;&#1102; U. )</span>
    U.
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>.R</code> печатает беззнаковое число, дополненное определенной шириной. Мы не можем просто
распечатать знак и вызвать U.R, потому что мы хотим, чтобы знак был рядом с номером
('-123' а не '- 123').
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dotr">: .R <span style="color: #af0000;">( n width -- )</span>
    SWAP <span style="color: #af0000;">( width n )</span>
    DUP 0&lt; <span style="color: #af00ff;">IF</span>
        NEGATE <span style="color: #af0000;">( width u )</span>
        <span style="color: #008787;">1 </span><span style="color: #af0000;">( save a flag to remember that it was negative | width n 1 )</span>
        SWAP <span style="color: #af0000;">( width 1 u )</span>
        ROT <span style="color: #af0000;">( 1 u width )</span>
        1- <span style="color: #af0000;">( 1 u width-1 )</span>
    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #008787;">0 </span><span style="color: #af0000;">( width u 0 )</span>
        SWAP <span style="color: #af0000;">( width 0 u )</span>
        ROT <span style="color: #af0000;">( 0 u width )</span>
    <span style="color: #af00ff;">THEN</span>
    SWAP <span style="color: #af0000;">( flag width u )</span>
    DUP <span style="color: #af0000;">( flag width u u )</span>
    UWIDTH <span style="color: #af0000;">( flag width u uwidth )</span>
    ROT <span style="color: #af0000;">( flag u uwidth width )</span>
    SWAP - <span style="color: #af0000;">( flag u width-uwidth )</span>

    SPACES <span style="color: #af0000;">( flag u )</span>
    SWAP <span style="color: #af0000;">( u flag )</span>

    <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( was it negative? print the - character )</span>
        '-' EMIT
    <span style="color: #af00ff;">THEN</span>

    U.
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Наконец, мы можем определить слово <code>.</code> через <code>.R</code>, с оконечными пробелами.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dotr_with_trailing">: . 0 .R SPACE <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Реальный <code>U.</code>, с оконечными пробелами.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_udot_with_trailing">: U. U. SPACE <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Это слово выбирает целое число по адресу и печатает его.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_enigma">: ? ( addr -- ) @ . <span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-40" class="outline-3">
<h3 id="unnumbered-40">Еще полезные слова</h3>
<div class="outline-text-3" id="text-unnumbered-40">
<p>
<code>c a b WITHIN</code> возвращает true если a &lt;= c and c &lt; b
</p>

<p>
или можно определить его без IF : <code>OVER - &gt;R - R&gt;  U&lt;</code>
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_within"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">WITHIN
</span>    -ROT <span style="color: #af0000;">( b c a )</span>
    OVER <span style="color: #af0000;">( b c a c )</span>
    &lt;= <span style="color: #af00ff;">IF</span>
        &gt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( b c -- )</span>
            <span style="color: #008787;">TRUE</span>
        <span style="color: #af00ff;">ELSE</span>
            <span style="color: #008787;">FALSE</span>
        <span style="color: #af00ff;">THEN</span>
    <span style="color: #af00ff;">ELSE</span>
        2DROP <span style="color: #af0000;">( b c -- )</span>
        <span style="color: #008787;">FALSE</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
DEPTH возвращает глубину стека
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_depth">: DEPTH        <span style="color: #af0000;">( -- n )</span>
    S0 @ DSP@ -
    4-         <span style="color: #af0000;">( adjust because S0 was on the stack when we pushed DSP )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
ALIGNED берет адрес и округляет его (выравнивает) к следующей границе 4 байта
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_aligned">: ALIGNED <span style="color: #af0000;">( addr -- addr )</span>
    <span style="color: #008787;">3 </span>+ 3 INVERT AND ( (addr+3) &amp; ~3 <span style="color: #af00ff;">)</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
ALIGN выравнивает указатель HERE, поэтому следующее добавленное слово будет правильно
выровнено.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_depth">: ALIGN HERE @ ALIGNED HERE ! <span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-41" class="outline-3">
<h3 id="unnumbered-41">Строки</h3>
<div class="outline-text-3" id="text-unnumbered-41">
<p>
~S" string"~ используется в FORTH для определения строк. Это слово оставляет адрес
строки и ее длину на вершине стека). Пробел, следующей за ~S"~, является нормальным
пробелом между словами FORTH и не является частью строки.
</p>

<p>
Это сложно определить, потому что он должен делать разные вещи в зависимости от того,
компилируем мы или в находимся немедленном режиме. (Таким образом, слово помечено как
IMMEDIATE, чтобы оно могло обнаружить это и делать разные вещи).
</p>

<p>
В режиме компиляции мы добавляем:
</p>

<div class="org-src-container">

<pre class="src src-forth">LITSTRING &lt;string length&gt; &lt;string rounded up <span style="color: #008787;">4 </span>bytes&gt;
</pre>
</div>

<p>
к текущему слову. Примитив LITSTRING делает все правильно, когда выполняется текущее
слово.
</p>

<p>
В непосредственном режиме нет особого места для размещения строки, но в этом случае мы
помещаем строку по адресу HERE (но мы не изменяем HERE). Это подразумевается как
временное местоположение, которое вскоре будет перезаписано.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_strings"><span style="color: #af0000;">( C, appends a byte to the current compiled word. )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">C,
</span>    HERE @ C! <span style="color: #af0000;">( store the character in the compiled image )</span>
    <span style="color: #008787;">1 </span>HERE +! <span style="color: #af0000;">( increment HERE pointer by 1 byte )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">S" </span>IMMEDIATE <span style="color: #af0000;">( -- addr len )</span>
    STATE @ <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( compiling? )</span>
        <span style="color: #af00ff;">' </span>LITSTRING , <span style="color: #af0000;">( compile LITSTRING )</span>
        HERE @ <span style="color: #af0000;">( save the address of the length word on the stack )</span>
        <span style="color: #008787;">0 </span>, <span style="color: #af0000;">( dummy length - we don't know what it is yet )</span>
        <span style="color: #af00ff;">BEGIN</span>
            KEY  <span style="color: #af0000;">( get next character of the string )</span>
            DUP '"' &lt;&gt;
        <span style="color: #af00ff;">WHILE</span>
                C, <span style="color: #af0000;">( copy character )</span>
        <span style="color: #af00ff;">REPEAT</span>
        DROP <span style="color: #af0000;">( drop the double quote character at the end )</span>
        DUP <span style="color: #af0000;">( get the saved address of the length word )</span>
        HERE @ SWAP - <span style="color: #af0000;">( calculate the length )</span>
        4- <span style="color: #af0000;">( subtract 4  (because we measured from the start of the length word)</span> <span style="color: #af00ff;">)</span>
        SWAP ! <span style="color: #af0000;">( and back-fill the length location )</span>
        ALIGN <span style="color: #af0000;">( round up to next multiple of 4 bytes for the remaining code )</span>
    <span style="color: #af00ff;">ELSE </span><span style="color: #af0000;">( immediate mode )</span>
        HERE @ <span style="color: #af0000;">( get the start address of the temporary space )</span>
        <span style="color: #af00ff;">BEGIN</span>
            KEY
            DUP '"' &lt;&gt;
        <span style="color: #af00ff;">WHILE</span>
                OVER C! <span style="color: #af0000;">( save next character )</span>
                1+ <span style="color: #af0000;">( increment address )</span>
        <span style="color: #af00ff;">REPEAT</span>
        DROP <span style="color: #af0000;">( drop the final " character )</span>
        HERE @ - <span style="color: #af0000;">( calculate the length )</span>
        HERE @ <span style="color: #af0000;">( push the start address )</span>
        SWAP  <span style="color: #af0000;">( addr len )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
~."~ является оператором печати строки в FORTH. Пример: ~." Something to print"~ Пробел
после оператора - обычный пробел, требуемый между словами, и не является частью того,
что напечатано.
</p>

<p>
В непосредственном режиме мы просто продолжаем читать символы и печатать их, пока не
перейдем к следующей двойной кавычки.
</p>

<p>
В режиме компиляции мы используем ~S"~ для хранения строки, а затем добавляем TELL
впоследствии:
</p>

<div class="org-src-container">

<pre class="src src-forth">LITSTRING &lt;string length&gt; &lt;string rounded up <span style="color: #af00ff;">to </span><span style="color: #af5f00;">4 </span>bytes&gt; TELL
</pre>
</div>

<p>
Может быть интересно отметить использование <code>[COMPILE]</code>, чтобы превратить вызов в
непосредственное слово ~S"~ в компиляцию этого слова. Он компилирует его в определение ~."~,
а не в определение скомпилированного слова, когда оно выполняется (достаточно сложно для вас?)
</p>

<div class="org-src-container">

<pre class="src src-forth">: ." IMMEDIATE <span style="color: #af0000;">( -- )</span>
    STATE @ <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( compiling? )</span>
        <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">S" </span><span style="color: #af0000;">( read the string, and compile LITSTRING, etc. )</span>
        <span style="color: #af00ff;">' </span>TELL , <span style="color: #af0000;">( compile the final TELL )</span>
    <span style="color: #af00ff;">ELSE</span>
        <span style="color: #af0000;">( In immediate mode, just read characters and print them until we get
        to the ending double quote. )</span>
        <span style="color: #af00ff;">BEGIN</span>
            KEY
            DUP '"' = <span style="color: #af00ff;">IF</span>
                DROP <span style="color: #af0000;">( drop the double quote character )</span>
                EXIT <span style="color: #af0000;">( return from this function )</span>
            <span style="color: #af00ff;">THEN</span>
            EMIT
        <span style="color: #af00ff;">AGAIN</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-42" class="outline-3">
<h3 id="unnumbered-42">Константы и переменные</h3>
<div class="outline-text-3" id="text-unnumbered-42">
<p>
В FORTH глобальные константы и переменные определяются следующим образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">10 CONSTANT TEN  # &#1082;&#1086;&#1075;&#1076;&#1072; TEN &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1090;&#1089;&#1103;, &#1086;&#1085; &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1094;&#1077;&#1083;&#1086;&#1077; &#1095;&#1080;&#1089;&#1083;&#1086; <span style="color: #008787;">10 </span>&#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
<span style="color: #008700;">VARIABLE </span><span style="color: #af5f00;">VAR </span>    # &#1082;&#1086;&#1075;&#1076;&#1072; VAR &#1074;&#1099;&#1087;&#1086;&#1083;&#1085;&#1103;&#1077;&#1090;&#1089;&#1103;, &#1086;&#1085; &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1072;&#1076;&#1088;&#1077;&#1089; VAR &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
</pre>
</div>

<p>
Константы можно читать, но не писать, например:
</p>

<div class="org-src-container">

<pre class="src src-forth">TEN . CR # &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; <span style="color: #008787;">10</span>
</pre>
</div>

<p>
Вы можете прочитать переменную (в этом примере, называемую VAR), выполнив:
</p>

<div class="org-src-container">

<pre class="src src-forth">VAR @       # &#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1103;&#1077;&#1090; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; VAR &#1074; &#1089;&#1090;&#1077;&#1082;&#1077;
VAR @ . CR  # &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; VAR
VAR ? CR    # &#1082;&#1072;&#1082; &#1080; &#1074;&#1099;&#1096;&#1077;, &#1087;&#1086;&#1089;&#1082;&#1086;&#1083;&#1100;&#1082;&#1091; ? &#1090;&#1072;&#1082;&#1086;&#1081; &#1078;&#1077; &#1082;&#1072;&#1082; @ .
</pre>
</div>

<p>
и обновить переменную, выполнив:
</p>

<div class="org-src-container">

<pre class="src src-forth">20 VAR ! # &#1079;&#1072;&#1087;&#1080;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; &#1074; VAR &#1095;&#1080;&#1089;&#1083;&#1086; <span style="color: #008787;">20</span>
</pre>
</div>

<p>
Обратите внимание, что переменные неинициализированы (но см. VALUE позже, в котором
инициализированные переменные содержат несколько более простой синтаксис).
</p>
</div>

<div id="outline-container-unnumbered-43" class="outline-4">
<h4 id="unnumbered-43">CONSTANT</h4>
<div class="outline-text-4" id="text-unnumbered-43">
<p>
Как мы можем определить слова CONSTANT и VARIABLE?
</p>

<p>
Трюк заключается в том, чтобы определить новое слово для самой переменной (например,
если переменная называлась "VAR", тогда мы бы определили новое слово под названием
VAR). Это легко сделать, потому что мы открыли создание словарных записей через слово
CREATE (часть определения <code>:</code> выше). Вызов WORD [TEN] CREATE (где [TEN] означает, что
"TEN" является следующим введенным словом) создает запись словаря:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-29.png" alt="forth-interpret-29.png">
</p>
</div>

<p>
Для CONSTANT мы можем продолжить это, просто добавив DOCOL (как <code>codeword</code>), затем LIT,
за которым следует сама константа, а затем EXIT, образуя небольшое определение слова,
которое возвращает константу:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-29.png" alt="forth-interpret-29.png">
</p>
</div>

<p>
Обратите внимание, что это определение слова точно такое же, как и у вас, если бы вы
написали
</p>

<div class="org-src-container">

<pre class="src src-forth">: TEN 10 <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Примечание для людей, читающих код ниже: DOCOL - это постоянное слово, которое мы
определили в ассемблерной части , которая возвращает значение символа ассемблера с тем
же именем.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_constant"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">CONSTANT
</span>    WORD     <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1080;&#1084;&#1103;  &#1080;&#1084;&#1103; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; CONSTANT )</span>
    <span style="color: #008700;">CREATE </span>  <span style="color: #af0000;">( &#1089;&#1086;&#1079;&#1076;&#1072;&#1090;&#1100; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103; )</span>
    DOCOL ,  <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; DOCOL &#1082;&#1072;&#1082; codeword &#1087;&#1086;&#1083;&#1103; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
    <span style="color: #af00ff;">' </span>LIT ,  <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword LIT )</span>
    ,        <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1083;&#1077;&#1078;&#1080;&#1090; &#1085;&#1072; &#1074;&#1077;&#1088;&#1096;&#1080;&#1085;&#1077; &#1089;&#1090;&#1077;&#1082;&#1072; )</span>
    <span style="color: #af00ff;">' </span>EXIT , <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword EXIT )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-44" class="outline-4">
<h4 id="unnumbered-44">VARIABLE</h4>
<div class="outline-text-4" id="text-unnumbered-44">
<p>
VARIABLE немного сложнее, потому что нам нужно где-то вставить переменную. Нет ничего
особенного в пользовательской памяти (область памяти, на которую указывает HERE, где мы
ранее только хранили новые определения слов). Мы можем вырезать кусочки этой области
памяти, чтобы сохранить что угодно, поэтому одно возможное определение VARIABLE может
создать это:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-30.png" alt="forth-interpret-30.png">
</p>
</div>

<p>
Чтобы сделать это более общим, давайте определим пару слов, которые мы можем
использовать для выделения произвольной памяти из пользовательской памяти.
</p>

<p>
Первое из них - ALLOT, где <code>n ALLOT</code> выделяет <code>n</code> байтов памяти. (Обратите внимание,
что при вызове ALLOT очень хорошая идея, убедиться, что <code>n</code> кратно 4, или, по крайней
мере, в следующий раз, когда слово скомпилировано, что HERE осталось кратным 4).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_allot">: ALLOT <span style="color: #af0000;">( n -- addr )</span>
    HERE @ SWAP <span style="color: #af0000;">( here n )</span>
    HERE +!     <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; n &#1082; HERE, &#1087;&#1086;&#1089;&#1083;&#1077; &#1101;&#1090;&#1086;&#1075;&#1086; &#1089;&#1090;&#1072;&#1088;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1086;&#1089;&#1090;&#1072;&#1077;&#1090;&#1089;&#1103; &#1085;&#1072; &#1089;&#1090;&#1077;&#1082;&#1077; )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Второе важное слово - Во-вторых, CELLS. В FORTH выражение <code>n CELLS ALLOT</code> означает
выделение n integer-ов любого размера - это натуральный размер для integer в этой
машинной архитектуре. На этой 32-битной машине CELLS просто умножает вершину стека
на 4.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_allot">: CELLS ( n -- n ) 4 * <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Итак, теперь мы можем легко определить переменную во многом так же, как и CONSTANT
выше. См. схему выше, чтобы увидеть, как будет выглядеть слово, которое создает
VARIABLE.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_variable"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">VARIABLE
</span>    <span style="color: #008787;">1 </span>CELLS ALLOT <span style="color: #af0000;">( &#1074;&#1099;&#1076;&#1077;&#1083;&#1080;&#1090;&#1100; 4 &#1073;&#1072;&#1081;&#1090;&#1086;&#1074;&#1091;&#1102; &#1103;&#1095;&#1077;&#1081;&#1082;&#1091; &#1076;&#1083;&#1103; integer &#1087;&#1072;&#1084;&#1103;&#1090;&#1080;, push &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1085;&#1077;&#1077; )</span>
    WORD <span style="color: #008700;">CREATE </span>  <span style="color: #af0000;">( &#1089;&#1086;&#1079;&#1076;&#1072;&#1090;&#1100; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103;, &#1080;&#1084;&#1103; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1075;&#1086; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; VARIABLE )</span>
    DOCOL ,       <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; DOCOL  &#1082;&#1072;&#1082; &#1087;&#1086;&#1083;&#1077; codeword &#1101;&#1090;&#1086;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
    <span style="color: #af00ff;">' </span>LIT ,       <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword LIT )</span>
    ,             <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1085;&#1086;&#1074;&#1086;&#1077; &#1080;&#1084;&#1103; )</span>
    <span style="color: #af00ff;">' </span>EXIT ,      <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1080;&#1090;&#1100; codeword EXIT )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-45" class="outline-3">
<h3 id="unnumbered-45">VALUE</h3>
<div class="outline-text-3" id="text-unnumbered-45">
<p>
VALUE похожи на VARIABLE, но с более простым синтаксисом. Вы обычно используете их,
когда вам нужна переменная, которая часто читается, а записывается нечасто.
</p>

<div class="org-src-container">

<pre class="src src-forth">20 VALUE VAL <span style="color: #af0000;">\ &#1089;&#1086;&#1079;&#1076;&#1072;&#1077;&#1084; VAL &#1080; &#1080;&#1085;&#1080;&#1094;&#1080;&#1072;&#1083;&#1080;&#1079;&#1080;&#1088;&#1091;&#1077;&#1084; &#1077;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; 20
</span>VAL          <span style="color: #af0000;">\ push-&#1080;&#1084; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; VAL (20) &#1074; &#1089;&#1090;&#1077;&#1082;
</span><span style="color: #008787;">30 </span>TO VAL    <span style="color: #af0000;">\ &#1080;&#1079;&#1084;&#1077;&#1085;&#1103;&#1077;&#1084; VAL, &#1091;&#1089;&#1090;&#1072;&#1085;&#1072;&#1074;&#1083;&#1080;&#1074;&#1072;&#1077; &#1077;&#1077; &#1074; 30
</span>VAL          <span style="color: #af0000;">\ push-&#1080;&#1084; &#1085;&#1086;&#1074;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; VAL (30) &#1074; &#1089;&#1090;&#1077;&#1082;
</span>
</pre>
</div>

<p>
Обратите внимание, что «VAL» сам по себе не возвращает адрес значения, а само значение,
делая значения более понятными и понятными для использования, чем переменные (без
косвенности через «@»). Цена представляет собой более сложную реализацию, хотя,
несмотря на сложность, во время исполнения нет штрафа за производительность.
</p>

<p>
Наивная реализация "TO" была бы довольно медленной, каждый раз ей приходилось бы искать
в словаре. Но поскольку это FORTH, мы имеем полный контроль над компилятором, чтобы мы
могли более эффективно компилировать TO, превращая:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #af00ff;">TO </span><span style="color: #af5f00;">VAL
</span>
</pre>
</div>

<p>
в
</p>

<div class="org-src-container">

<pre class="src src-forth">LIT &lt;addr&gt; !
</pre>
</div>

<p>
и вычислить &lt;addr&gt; (адрес значения) во время компиляциии
</p>

<p>
Теперь это довольно умно. Мы скомпилируем наше значение следующим образом:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-31.png" alt="forth-interpret-31.png">
</p>
</div>

<p>
где &lt;value&gt; - это фактическое значение. Обратите внимание, что когда VAL выполняется,
он будет выталкивать значение в стек, чего мы и хотим.
</p>

<p>
Но что будет использовать для адреса &lt;addr&gt;?  Разумеется, указатель на этот &lt;value&gt;:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-32.png" alt="forth-interpret-32.png">
</p>
</div>

<p>
Другими словами, это своего рода самомодифицирующийся код.
</p>

<p>
(Замечение для людей, которые хотят изменить этот FORTH, чтобы добавить инлайнинг:
значения, определенные таким образом, не могут быть заинлайнены).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_to">: VALUE <span style="color: #af0000;">( n -- )</span>
    WORD <span style="color: #008700;">CREATE </span><span style="color: #af0000;">( &#1089;&#1086;&#1079;&#1076;&#1072;&#1077;&#1084; &#1079;&#1072;&#1075;&#1086;&#1083;&#1086;&#1074;&#1086;&#1082; &#1101;&#1083;&#1077;&#1084;&#1077;&#1085;&#1090;&#1072; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1103; - &#1080;&#1084;&#1103; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1079;&#1072; VALUE)</span>
    DOCOL ,     <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; DOCOL )</span>
    <span style="color: #af00ff;">' </span>LIT ,     <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; codeword LIT )</span>
    ,           <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1077; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; )</span>
    <span style="color: #af00ff;">' </span>EXIT ,    <span style="color: #af0000;">( &#1076;&#1086;&#1073;&#1072;&#1074;&#1083;&#1103;&#1077;&#1084; codeword EXIT )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">TO </span>IMMEDIATE <span style="color: #af0000;">( n -- )</span>
    WORD <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1080;&#1084;&#1103; VALUE )</span>
    FIND <span style="color: #af0000;">( &#1080;&#1097;&#1077;&#1084; &#1077;&#1075;&#1086; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077; )</span>
    &gt;DFA <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1077;&#1088;&#1074;&#1086;&#1077; &#1087;&#1086;&#1083;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; -'LIT' )</span>
    4+   <span style="color: #af0000;">( &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; )</span>
    STATE @ <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1103;? )</span>
        <span style="color: #af00ff;">' </span>LIT , <span style="color: #af0000;">( &#1076;&#1072;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LIT )</span>
        ,       <span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; )</span>
        <span style="color: #af00ff;">' </span>! ,   <span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; ! )</span>
    <span style="color: #af00ff;">ELSE </span><span style="color: #af0000;">( &#1085;&#1077;&#1090;, immediate mode )</span>
        ! <span style="color: #af0000;">( &#1086;&#1073;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; &#1089;&#1088;&#1072;&#1079;&#1091; )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>x +TO VAL</code> добавляет x к VAL
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_to">: +TO <span style="color: #af00ff;">IMMEDIATE</span>
    WORD <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1080;&#1084;&#1103; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; )</span>
    FIND <span style="color: #af0000;">( &#1080;&#1097;&#1077;&#1084; &#1074; &#1089;&#1083;&#1086;&#1074;&#1072;&#1088;&#1077; )</span>
    &gt;DFA <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1072; &#1087;&#1077;&#1088;&#1074;&#1086;&#1077; &#1087;&#1086;&#1083;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; -'LIT' )</span>
    4+   <span style="color: #af0000;">( &#1091;&#1074;&#1077;&#1083;&#1080;&#1095;&#1080;&#1074;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077; &#1085;&#1072; &#1088;&#1072;&#1079;&#1084;&#1077;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; )</span>
    STATE @ <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1103;&#1094;&#1080;&#1103;? )</span>
        <span style="color: #af00ff;">' </span>LIT , <span style="color: #af0000;">( &#1076;&#1072;, &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; LIT )</span>
        ,       <span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1072;&#1076;&#1088;&#1077;&#1089; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1103; )</span>
        <span style="color: #af00ff;">' </span>+! ,  <span style="color: #af0000;">( &#1082;&#1086;&#1084;&#1087;&#1080;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; +! )</span>
    <span style="color: #af00ff;">ELSE </span><span style="color: #af0000;">( &#1085;&#1077;&#1090;, immediate mode )</span>
        +! <span style="color: #af0000;">( &#1086;&#1073;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; &#1089;&#1088;&#1072;&#1079;&#1091; )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-46" class="outline-3">
<h3 id="unnumbered-46">Печать словаря</h3>
<div class="outline-text-3" id="text-unnumbered-46">
<p>
<code>ID.</code> берет адрес словаря и печатает имя слова.
</p>

<p>
Например: <code>LATEST @ ID.</code> распечатает имя последнего определенного слова
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_id_dot"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">ID.
</span>    4+            <span style="color: #af0000;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    DUP C@        <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_LENMASK AND <span style="color: #af0000;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084; flags - &#1084;&#1099; &#1093;&#1086;&#1090;&#1080;&#1084; &#1087;&#1088;&#1086;&#1089;&#1090;&#1086; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1076;&#1083;&#1080;&#1085;&#1091; )</span>

    <span style="color: #af00ff;">BEGIN</span>
        DUP 0&gt;    <span style="color: #af0000;">( &#1076;&#1083;&#1080;&#1085;&#1072; &gt; 0? )</span>
    <span style="color: #af00ff;">WHILE</span>
            SWAP 1+ <span style="color: #af0000;">( addr len -- len addr+1 )</span>
            DUP C@  <span style="color: #af0000;">( len addr -- len addr char | &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; )</span>
            EMIT    <span style="color: #af0000;">( len addr char -- len addr | &#1080; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
            SWAP 1- <span style="color: #af0000;">( len addr -- addr len-1    | &#1074;&#1099;&#1095;&#1080;&#1090;&#1072;&#1077;&#1084; &#1077;&#1076;&#1080;&#1085;&#1080;&#1094;&#1091; &#1080;&#1079; &#1076;&#1083;&#1080;&#1085;&#1099; )</span>
    <span style="color: #af00ff;">REPEAT</span>
    2DROP         <span style="color: #af0000;">( len addr -- )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>WORD word FIND ?HIDDEN</code> возвращает true, если слово <code>word</code> помечено как скрытое.
<code>WORD word FIND ?IMMEDIATE</code> возвращает true, если слово <code>word</code> помечен как
"немедленное".
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_hidden_immediate_question"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">?HIDDEN
</span>    4+ <span style="color: #af0000;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    C@ <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_HIDDEN AND <span style="color: #af0000;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084; F_HIDDEN &#1092;&#1083;&#1072;&#1075; &#1080; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">?IMMEDIATE
</span>    4+ <span style="color: #af0000;">( &#1087;&#1077;&#1088;&#1077;&#1087;&#1088;&#1099;&#1075;&#1080;&#1074;&#1072;&#1077;&#1084; &#1095;&#1077;&#1088;&#1077;&#1079; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; link )</span>
    C@ <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090; flags/length )</span>
    F_IMMED AND <span style="color: #af0000;">( &#1084;&#1072;&#1089;&#1082;&#1080;&#1088;&#1091;&#1077;&#1084;  F_IMMED &#1092;&#1083;&#1072;&#1075; &#1080; &#1074;&#1086;&#1079;&#1074;&#1088;&#1072;&#1097;&#1072;&#1077;&#1084; &#1077;&#1075;&#1086; )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>WORDS</code> печатает все слова, определенные в словаре, начиная с самого последнего слова.
Однако оно не печатает скрытые слова. Реализация просто двигается назад от LATEST с
помощью ссылок-указателей.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_words"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">WORDS
</span>    LATEST @ <span style="color: #af0000;">( &#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1077;&#1084; &#1089; LATEST &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1103; )</span>
    <span style="color: #af00ff;">BEGIN</span>
        ?DUP <span style="color: #af0000;">( &#1087;&#1086;&#1083;&#1082;&#1072; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1085;&#1077; null )</span>
    <span style="color: #af00ff;">WHILE</span>
            DUP ?HIDDEN NOT <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( &#1080;&#1075;&#1085;&#1086;&#1088;&#1080;&#1088;&#1091;&#1077;&#1084; &#1089;&#1082;&#1088;&#1099;&#1090;&#1099;&#1077; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
                DUP ID.        <span style="color: #af0000;">( &#1077;&#1089;&#1083;&#1080; &#1085;&#1077; &#1089;&#1082;&#1088;&#1099;&#1090;&#1086;&#1077;, &#1090;&#1086; &#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1084; &#1089;&#1083;&#1086;&#1074;&#1086; )</span>
                SPACE
            <span style="color: #af00ff;">THEN</span>
            @ <span style="color: #af0000;">( dereference link - &#1080;&#1076;&#1077;&#1084; &#1082; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1084;&#1091; &#1089;&#1083;&#1086;&#1074;&#1091; )</span>
    <span style="color: #af00ff;">REPEAT</span>
    CR
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-47" class="outline-3">
<h3 id="unnumbered-47">Забывание</h3>
<div class="outline-text-3" id="text-unnumbered-47">
<p>
До сих пор мы только выделяли память для слов. FORTH обеспечивает довольно примитивный
метод освобождения.
</p>

<p>
<code>FORGET word</code> удаляет определение «слова» из словаря и всего, что определено после
него, включая любые переменные и другую память, выделенную после.
</p>

<p>
Реализация очень проста - мы просматриваем слово (которое возвращает адрес записи
словаря). Затем мы устанавливаем HERE, чтобы указывать на этот адрес, так что все
будущие распределения и определения будут перезаписывать память, начиная с него. Нам
также необходимо установить LATEST, чтобы указать на предыдущее слово.
</p>

<p>
Обратите внимание: вы не можете FORGET встроенные слова (ну, вы можете попробовать,
но это, вероятно, вызовет segfault).
</p>

<p>
XXX: Поскольку мы написали VARIABLE, чтобы сохранить переменную в памяти, выделенную до
слова, в текущей реализации VARIABLE FOO FORGET FOO приведет к утечке одной ячейки
памяти.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_forget"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">FORGET
</span>    WORD FIND      <span style="color: #af0000;">( &#1085;&#1072;&#1081;&#1090;&#1080; &#1089;&#1083;&#1086;&#1074; &#1080; &#1087;&#1086;&#1083;&#1091;&#1095;&#1080;&#1090;&#1100; &#1077;&#1075;&#1086; dictionary entry address )</span>
    DUP @ LATEST ! <span style="color: #af0000;">( &#1091;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1080;&#1090;&#1100; LATEST &#1085;&#1072; &#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1100; &#1087;&#1088;&#1077;&#1076;&#1099;&#1076;&#1091;&#1097;&#1077;&#1075;&#1086; &#1089;&#1083;&#1086;&#1074;&#1072; )</span>
    HERE !         <span style="color: #af0000;">( &#1080; &#1089;&#1086;&#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; HERE &#1082;&#1072;&#1082; dictionary address )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-48" class="outline-3">
<h3 id="unnumbered-48">Дамп</h3>
<div class="outline-text-3" id="text-unnumbered-48">
<p>
<code>DUMP</code> используется для выгрузки содержимого памяти в "традиционном" формате <code>hexdump</code>.
</p>

<p>
Обратите внимание, что параметры DUMP (адрес, длина) совместимы со строковыми словами,
такими как <code>WORD</code> и <code>S".</code>
</p>

<p>
Вы можете выгрузить исходный код для последнего слова, которое вы определили, выполнив
что-то вроде:
</p>

<div class="org-src-container">

<pre class="src src-forth">LATEST @ <span style="color: #008787;">128 </span>DUMP
</pre>
</div>

<p>
Вот реализация:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_dump">: DUMP <span style="color: #af0000;">( addr len -- )</span>
    BASE @ -ROT <span style="color: #af0000;">( save the current BASE at the bottom of the stack )</span>
    HEX <span style="color: #af0000;">( and switch to hexadecimal mode )</span>

    <span style="color: #af00ff;">BEGIN</span>
        ?DUP <span style="color: #af0000;">( while len &gt; 0 )</span>
    <span style="color: #af00ff;">WHILE</span>
            OVER <span style="color: #008787;">8 </span>U.R <span style="color: #af0000;">( print the address )</span>
            SPACE

            <span style="color: #af0000;">( print up to 16 words on this line )</span>
            2DUP <span style="color: #af0000;">( addr len addr len )</span>
            1- <span style="color: #008787;">15 </span>AND 1+ <span style="color: #af0000;">( addr len addr linelen )</span>
            <span style="color: #af00ff;">BEGIN</span>
                ?DUP <span style="color: #af0000;">( while linelen &gt; 0 )</span>
            <span style="color: #af00ff;">WHILE</span>
                    SWAP <span style="color: #af0000;">( addr len linelen addr )</span>
                    DUP C@ <span style="color: #af0000;">( addr len linelen addr byte )</span>
                    <span style="color: #008787;">2 </span>.R SPACE <span style="color: #af0000;">( print the byte )</span>
                    1+ SWAP 1- <span style="color: #af0000;">( addr len linelen addr -- addr len addr+1 linelen-1 )</span>
            <span style="color: #af00ff;">REPEAT</span>
            DROP <span style="color: #af0000;">( addr len )</span>

            <span style="color: #af0000;">( print the ASCII equivalents )</span>
            2DUP 1- <span style="color: #008787;">15 </span>AND 1+  <span style="color: #af0000;">( addr len addr linelen )</span>
            <span style="color: #af00ff;">BEGIN</span>
                ?DUP <span style="color: #af0000;">( while linelen &gt; 0)</span>
            <span style="color: #af00ff;">WHILE</span>
                    SWAP <span style="color: #af0000;">( addr len linelen addr )</span>
                    DUP C@ <span style="color: #af0000;">( addr len linelen addr byte )</span>
                    DUP <span style="color: #008787;">32 </span>128 WITHIN IF <span style="color: #af0000;">( 32 &lt;= c &lt; 128? )</span>
                        EMIT
                    <span style="color: #af00ff;">ELSE</span>
                        DROP '.' EMIT
                    <span style="color: #af00ff;">THEN</span>
                    1+ SWAP 1- <span style="color: #af0000;">( addr len linelen addr -- addr len addr+1 linelen-1 )</span>
            <span style="color: #af00ff;">REPEAT</span>
            DROP <span style="color: #af0000;">( addr len )</span>
            CR

            DUP 1- <span style="color: #008787;">15 </span>AND 1+  <span style="color: #af0000;">( addr len linelen )</span>
            TUCK <span style="color: #af0000;">( addr linelen len linelen )</span>
            - <span style="color: #af0000;">( addr linelen len-linelen )</span>
            &gt;R + R&gt; <span style="color: #af0000;">( addr+linelen len-linelen )</span>
    <span style="color: #af00ff;">REPEAT</span>

    DROP <span style="color: #af0000;">( restore stack )</span>
    BASE ! <span style="color: #af0000;">( restore saved BASE )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-49" class="outline-3">
<h3 id="unnumbered-49">Case</h3>
<div class="outline-text-3" id="text-unnumbered-49">
<p>
<code>CASE ... ENDCASE</code> - это то, как мы делаем <code>switch</code> в FORTH. Для этого нет общего
согласованного синтаксиса, поэтому я реализовал синтаксис, предусмотренный стандартом
ISO FORTH (ANS-FORTH).
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #af0000;">( some value on the stack )</span>
<span style="color: #ff0000; font-weight: bold;">CASE</span>
    test1 <span style="color: #ff0000; font-weight: bold;">OF </span>... <span style="color: #ff0000; font-weight: bold;">ENDOF</span>
    test2 <span style="color: #ff0000; font-weight: bold;">OF </span>... <span style="color: #ff0000; font-weight: bold;">ENDOF</span>
    testn <span style="color: #ff0000; font-weight: bold;">OF </span>... <span style="color: #ff0000; font-weight: bold;">ENDOF</span>
    ... <span style="color: #af0000;">( default case )</span>
<span style="color: #ff0000; font-weight: bold;">ENDCASE</span>
</pre>
</div>

<p>
Оператор CASE проверяет значение в стеке, проверяя его на равенство с test1, test2,
&#x2026;, testn и выполняет соответствующий фрагмент кода внутри OF &#x2026; ENDOF. Если ни одно
из тестовых значений не совпадает, выполняется случай по умолчанию. Внутри &#x2026; случая
по умолчанию значение все еще находится в верхней части стека (оно неявно DROP-нется с
помощью ENDCASE). Когда ENDOF выполняется, он перескакивает после ENDCASE
(т. e. Отсутствует 2провал" и нет необходимости в операторе break, как в C).
</p>

<p>
default case может быть опущен. Фактически tests также могут быть опущены, так
что у вас будет только default case, хотя это, вероятно, не очень полезно.
</p>

<p>
Пример (предполагая, что «q» и т. Д. - это слова, которые push-ат значение ASCII-кода
буквы в стек):
</p>

<div class="org-src-container">

<pre class="src src-forth">0 <span style="color: #008700;">VALUE </span><span style="color: #af5f00;">QUIT
</span><span style="color: #008787;">0 </span><span style="color: #008700;">VALUE </span><span style="color: #af5f00;">SLEEP
</span>KEY <span style="color: #ff0000; font-weight: bold;">CASE</span>
    'q' <span style="color: #ff0000; font-weight: bold;">OF </span>1 TO QUIT <span style="color: #ff0000; font-weight: bold;">ENDOF</span>
    's' <span style="color: #ff0000; font-weight: bold;">OF </span>1 TO SLEEP <span style="color: #ff0000; font-weight: bold;">ENDOF</span>
    <span style="color: #af0000;">( default case: )</span>
    <span style="color: #ff0000; font-weight: bold;">." </span><span style="color: #87005f;">Sorry, I didn't understand key &lt;"</span> DUP EMIT <span style="color: #ff0000; font-weight: bold;">." </span><span style="color: #87005f;">&gt;, try again."</span> CR
<span style="color: #ff0000; font-weight: bold;">ENDCASE</span>
</pre>
</div>

<p>
В некоторых версиях FORTH поддерживаются более продвинутые tests, такие как диапазоны
и.т.д. В других версиях FORTH вам нужно написать OTHERWISE, чтобы указать default
case. Как я сказал выше, этот FORTH пытается следовать стандарту ANS FORTH.
</p>

<p>
Реализация CASE &#x2026; ENDCASE несколько нетривиальна. Я следовал этой реализации:
<a href="http://www.uni-giessen.de/faq/archiv/forthfaq.case_endcase/msg00000.html">http://www.uni-giessen.de/faq/archiv/forthfaq.case_endcase/msg00000.html</a> (в данный
момент недоступна)
</p>

<p>
Общий план состоит в том, чтобы скомпилировать код как ряд операторов IF:
</p>

<div class="org-src-container">

<pre class="src src-forth">CASE                          <span style="color: #af0000;">\ (push 0 on the immediate-mode parameter stack)
</span>    test1 <span style="color: #ff0000; font-weight: bold;">OF </span>... ENDOF        <span style="color: #af0000;">\ test1 OVER = IF DROP ... ELSE
</span>    test2 <span style="color: #ff0000; font-weight: bold;">OF </span>... ENDOF        <span style="color: #af0000;">\ test2 OVER = IF DROP ... ELSE
</span>    testn <span style="color: #ff0000; font-weight: bold;">OF </span>... ENDOF        <span style="color: #af0000;">\ testn OVER = IF DROP ... ELSE
</span>    ...  <span style="color: #af0000;">( default case )</span>...
<span style="color: #ff0000; font-weight: bold;">ENDCASE </span>                      <span style="color: #af0000;">\ DROP THEN [THEN [THEN ...]]
</span>
</pre>
</div>

<p>
Оператор CASE push-ит 0 на стек параметров в "немедленном" режиме, и это число
используется для подсчета количества инструкций THEN, которые нам нужны, когда мы
получаем ENDCASE, чтобы каждый IF имел соответствующий THEN. Подсчет делается
неявно. Если вы помните из реализации выше IF, каждый IF push-ит адрес кода в стеке в
немедленном режиме, и эти адреса не равны нулю, поэтому к тому времени, когда мы дойдем
до ENDCASE, стек содержит некоторое количество ненулевых элементов, а затем нуль. Число
ненулевых чисел - это сколько раз IF был вызван, поэтому сколько же раз мы должны
сделать соответствующий THEN.
</p>

<p>
Этот код использует [COMPILE], чтобы мы скомпилировали вызовы IF, ELSE, THEN, а не
вызывали их во время компиляции слов ниже.
</p>

<p>
Как и во всех наших структурах управления, они работают только в определениях слов, а
не в непосредственном режиме.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_case">: CASE <span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #008787;">0 </span><span style="color: #af0000;">( push 0 to mark the bottom of the stack )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">OF </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>OVER , <span style="color: #af0000;">( compile OVER )</span>
    <span style="color: #af00ff;">' </span>= , <span style="color: #af0000;">( compile = )</span>
    <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">IF </span><span style="color: #af0000;">( compile IF )</span>
    <span style="color: #af00ff;">' </span>DROP ,   <span style="color: #af0000;">( compile DROP )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ENDOF </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">ELSE </span><span style="color: #af0000;">( ENDOF is the same as ELSE )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ENDCASE </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>DROP , <span style="color: #af0000;">( compile DROP )</span>

    <span style="color: #af0000;">( keep compiling THEN until we get to our zero marker )</span>
    <span style="color: #af00ff;">BEGIN</span>
        ?DUP
    <span style="color: #af00ff;">WHILE</span>
            <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">THEN
</span>    <span style="color: #af00ff;">REPEAT</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-50" class="outline-3">
<h3 id="unnumbered-50">Декомпилятор</h3>
<div class="outline-text-3" id="text-unnumbered-50">
<p>
<code>CFA&gt;</code> является противоположностью <code>&gt;CFA</code>.  Он принимает <code>codeword</code> и пытается найти
подходящее определение словаря. (По правде говоря, он работает с любым указателем на
слово, а не только c указателем на <code>codeword</code>, и это необходимо для выполнения
трассировки стека).
</p>

<p>
В этом FORTH это не так просто. Фактически нам приходится искать через словарь, потому
что у нас нет удобного обратного указателя (как это часто бывает в других версиях
FORTH).  Из-за этого поиска <code>CFA&gt;</code> не следует использовать, когда производительность
критична, поэтому она используется только для инструментов отладки, таких как
декомпилятор и печать стек-трейсов.
</p>

<p>
Это слово возвращает 0, если ничего не находит
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_cfa"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">CFA&gt;
</span>    LATEST @ <span style="color: #af0000;">( start at LATEST dictionary entry )</span>
    <span style="color: #af00ff;">BEGIN</span>
        ?DUP <span style="color: #af0000;">( while link pointer is not null )</span>
    <span style="color: #af00ff;">WHILE</span>
            2DUP SWAP <span style="color: #af0000;">( cfa curr curr cfa )</span>
            &lt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( current dictionary entry &lt; cfa? )</span>
                NIP <span style="color: #af0000;">( leave curr dictionary entry on the stack )</span>
                EXIT
            <span style="color: #af00ff;">THEN</span>
            @ <span style="color: #af0000;">( follow link pointer back )</span>
    <span style="color: #af00ff;">REPEAT</span>
    DROP <span style="color: #af0000;">( restore stack )</span>
    <span style="color: #008787;">0 </span><span style="color: #af0000;">( sorry, nothing found )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>SEE</code> декомпилирует слово FORTH.
</p>

<p>
Мы ищем <code>dictionary entry</code> слова, затем снова ищем опять для следующего слова (фактически, конец
скомпилированного слова). Это приводит к двум указателям:
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-33.png" alt="forth-interpret-33.png">
</p>
</div>

<p>
С этой информацией мы можем декомпилировать слово. Нам нужно узнавать "мета-слова",
такие как LIT, LITSTRING, BRANCH и.т.д. И обрабатывать их особенным образом.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_case"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">SEE
</span>    WORD FIND <span style="color: #af0000;">( find the dictionary entry to decompile )</span>

    <span style="color: #af0000;">( Now we search again, looking for the next word in the dictionary.  This gives us
    the length of the word that we will be decompiling.   (Well, mostly it does)</span>. <span style="color: #af00ff;">)</span>
    HERE @ <span style="color: #af0000;">( address of the end of the last compiled word )</span>
    LATEST @ <span style="color: #af0000;">( word last curr )</span>
    <span style="color: #af00ff;">BEGIN</span>
        <span style="color: #008787;">2 </span>PICK <span style="color: #af0000;">( word last curr word )</span>
        OVER <span style="color: #af0000;">( word last curr word curr )</span>
        &lt;&gt; <span style="color: #af0000;">( word last curr word&lt;&gt;curr? )</span>
    <span style="color: #af00ff;">WHILE </span><span style="color: #af0000;">( word last curr )</span>
            NIP <span style="color: #af0000;">( word curr )</span>
            DUP @ <span style="color: #af0000;">( word curr prev  (which becomes: word last curr)</span> <span style="color: #af00ff;">)</span>
    <span style="color: #af00ff;">REPEAT</span>

    DROP <span style="color: #af0000;">( at this point, the stack is: start-of-word end-of-word )</span>
    SWAP <span style="color: #af0000;">( end-of-word start-of-word )</span>

    <span style="color: #af0000;">( begin the definition with : NAME [IMMEDIATE] )</span>
    ':' EMIT SPACE DUP ID. SPACE
    DUP ?IMMEDIATE <span style="color: #af00ff;">IF </span>." IMMEDIATE " <span style="color: #af00ff;">THEN</span>

    &gt;DFA <span style="color: #af0000;">( get the data address, ie. points after DOCOL | end-of-word start-of-data )</span>

    <span style="color: #af0000;">( now we start decompiling until we hit the end of the word )</span>
    <span style="color: #af00ff;">BEGIN </span><span style="color: #af0000;">( end start )</span>
        2DUP &gt;
    <span style="color: #af00ff;">WHILE</span>
            DUP @ <span style="color: #af0000;">( end start codeword )</span>

            <span style="color: #af00ff;">CASE</span>
                <span style="color: #af00ff;">' </span>LIT OF <span style="color: #af0000;">( is it LIT ? )</span>
                    <span style="color: #008787;">4 </span>+ DUP @ <span style="color: #af0000;">( get next word which is the integer constant )</span>
                    . <span style="color: #af0000;">( and print it )</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af00ff;">' </span>LITSTRING OF <span style="color: #af0000;">( is it LITSTRING ? )</span>
                    <span style="color: #af00ff;">[ </span>CHAR S ] LITERAL EMIT '"' EMIT SPACE  <span style="color: #af0000;">( print S"&lt;space&gt; )</span>
                    <span style="color: #008787;">4 </span>+ DUP @ <span style="color: #af0000;">( get the length word )</span>
                    SWAP <span style="color: #008787;">4 </span>+ SWAP <span style="color: #af0000;">( end start+4 length )</span>
                    2DUP TELL <span style="color: #af0000;">( print the string )</span>
                    '"' EMIT SPACE <span style="color: #af0000;">( finish the string with a final quote )</span>
                    + ALIGNED <span style="color: #af0000;">( end start+4+len, aligned )</span>
                    <span style="color: #008787;">4 </span>- <span style="color: #af0000;">( because we're about to add 4 below )</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af00ff;">' </span>0BRANCH OF <span style="color: #af0000;">( is it 0BRANCH ? )</span>
                    <span style="color: #87005f;">." 0BRANCH  ( "</span>
                    <span style="color: #008787;">4 </span>+ DUP @ <span style="color: #af0000;">( print the offset )</span>
                    .
                    <span style="color: #87005f;">." ) "</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af00ff;">' </span>BRANCH OF <span style="color: #af0000;">( is it BRANCH ? )</span>
                    <span style="color: #87005f;">." BRANCH  ( "</span>
                    <span style="color: #008787;">4 </span>+ DUP @ <span style="color: #af0000;">( print the offset )</span>
                    .
                    <span style="color: #87005f;">." ) "</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af00ff;">' </span>' OF ( is it '  (TICK) ? <span style="color: #af00ff;">)</span>
                    <span style="color: #af00ff;">[ </span>CHAR ' <span style="color: #af00ff;">] </span>LITERAL EMIT SPACE
                    <span style="color: #008787;">4 </span>+ DUP @ <span style="color: #af0000;">( get the next codeword )</span>
                    CFA&gt; <span style="color: #af0000;">( and force it to be printed as a dictionary entry )</span>
                    ID. SPACE
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af00ff;">' </span>EXIT OF <span style="color: #af0000;">( is it EXIT? )</span>
                    <span style="color: #af0000;">( We expect the last word to be EXIT, and if it is then we don't print it
                    because EXIT is normally implied by ;.  EXIT can also appear in the middle
                    of words, and then it needs to be printed. )</span>
                    2DUP <span style="color: #af0000;">( end start end start )</span>
                    <span style="color: #008787;">4 </span>+ <span style="color: #af0000;">( end start end start+4 )</span>
                    &lt;&gt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( end start | we're not at the end )</span>
                        <span style="color: #87005f;">." EXIT "</span>
                    <span style="color: #af00ff;">THEN</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af0000;">( default case: )</span>
                DUP <span style="color: #af0000;">( in the default case we always need to DUP before using )</span>
                CFA&gt; <span style="color: #af0000;">( look up the codeword to get the dictionary entry )</span>
                ID. SPACE <span style="color: #af0000;">( and print it )</span>
            <span style="color: #af00ff;">ENDCASE</span>

            <span style="color: #008787;">4 </span>+ <span style="color: #af0000;">( end start+4 )</span>
    <span style="color: #af00ff;">REPEAT</span>

    ';' EMIT CR

    2DROP <span style="color: #af0000;">( restore stack )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-51" class="outline-3">
<h3 id="unnumbered-51">Токены выполнения</h3>
<div class="outline-text-3" id="text-unnumbered-51">
<p>
Стандарт FORTH определяет концепцию, называемую "токеном выполнения" (или "xt"),
которая очень похожа на указатель функции в Си. Мы сопоставляем токен выполнения с
адресом кодового слова.
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-34.png" alt="forth-interpret-34.png">
</p>
</div>

<p>
Существует один ассемблерный примитив для выполнения токенов, <code>EXECUTE</code> (xt -), который
их запускает.
</p>

<p>
Вы можете сделать токен выполнения для существующего слова длинным путем, используя
<code>&gt;CFA</code>, то есть: <code>WORD [foo] FIND &gt;CFA</code> будет push-ить <code>xt</code> для <code>foo</code> в стек, где
<code>foo</code> - следующее введенное слово. Таким образом, очень медленный способ запуска DOUBLE
может быть:
</p>

<div class="org-src-container">

<pre class="src src-forth">: DOUBLE DUP + <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">SLOW </span>WORD FIND &gt;CFA EXECUTE <span style="color: #af00ff;">;</span>

<span style="color: #008787;">5 </span>SLOW DOUBLE . CR <span style="color: #af0000;">\ prints 10
</span>
</pre>
</div>

<p>
Мы также предлагаем более простой и быстрый способ получить токен выполнения любого
слова FOO:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #ff0000; font-weight: bold;">['] </span><span style="color: #0000ff;">FOO
</span>
</pre>
</div>

<p>
Домашнее задание:
</p>
<ul class="org-ul">
<li>(1) Какая разница между <code>[']</code> FOO и ~' FOO~?
</li>
<li>(2) Как соотносятся ~'~, <code>[']</code> и <code>LIT</code>?
</li>
</ul>

<p>
Более полезным является определение анонимных слов и/или присваивание переменным
токенов выполнения (xt).
</p>

<p>
Чтобы определить анонимное слово (и запушить его xt в стеке), используйте: <code>NONAME
...;</code> как в этом примере:
</p>

<div class="org-src-container">

<pre class="src src-forth">:NONAME ." anon word was called" CR ; <span style="color: #af0000;">\ push-&#1080;&#1090; xt &#1074; &#1089;&#1090;&#1077;&#1082;
</span>
DUP EXECUTE EXECUTE  <span style="color: #af0000;">\ &#1074;&#1099;&#1087;&#1086;&#1083;&#1103;&#1085;&#1077;&#1090; &#1072;&#1085;&#1086;&#1085;&#1080;&#1084;&#1085;&#1086;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#1076;&#1074;&#1072;&#1078;&#1076;&#1099;
</span>
</pre>
</div>

<p>
Параметры в стеке тоже работают должным образом:
</p>

<div class="org-src-container">

<pre class="src src-forth">:NONAME ." called with parameter " . CR <span style="color: #af00ff;">;</span>
DUP
<span style="color: #008787;">10 </span>SWAP EXECUTE <span style="color: #af0000;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; 'called with parameter 10'
</span><span style="color: #008787;">20 </span>SWAP EXECUTE <span style="color: #af0000;">\ &#1085;&#1072;&#1087;&#1077;&#1095;&#1072;&#1090;&#1072;&#1077;&#1090; 'called with parameter 20'
</span>
</pre>
</div>

<p>
Обратите внимание, что вышеупомянутый код создает утечку памяти: анонимное слово все еще
компилируется в сегмент данных, поэтому, даже если вы потеряете отслеживание xt, слово
продолжает занимать память. Хороший способ отслеживания xt и, таким образом, избежать
утечки памяти - назначить его CONSTANT, VARIABLE или VALUE:
</p>

<div class="org-src-container">

<pre class="src src-forth">0 <span style="color: #008700;">VALUE </span><span style="color: #af5f00;">ANON
</span><span style="color: #af00ff;">:NONAME </span>." anon word was called" CR ; <span style="color: #af00ff;">TO </span><span style="color: #af5f00;">ANON
</span>ANON EXECUTE
ANON EXECUTE
</pre>
</div>

<p>
Еще одно использование <code>:NONAME</code> - создание массива функций, которые можно быстро
вызвать (подумайте о быстром <code>switch</code> например). Этот пример адаптирован из стандарта
ANS FORTH:
</p>

<div class="org-src-container">

<pre class="src src-forth">10 CELLS ALLOT <span style="color: #008700;">CONSTANT </span><span style="color: #af5f00;">CMD-TABLE
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">SET-CMD </span>CELLS CMD-TABLE + ! <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">CALL-CMD </span>CELLS CMD-TABLE + @ EXECUTE <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">:NONAME </span>." alternate 0 was called" CR ; <span style="color: #008787;">0 </span>SET-CMD
<span style="color: #af00ff;">:NONAME </span>." alternate 1 was called" CR ; <span style="color: #008787;">1 </span>SET-CMD
<span style="color: #af0000;">\ etc...
</span><span style="color: #af00ff;">:NONAME </span>." alternate 9 was called" CR ; <span style="color: #008787;">9 </span>SET-CMD

<span style="color: #008787;">0 </span>CALL-CMD
<span style="color: #008787;">1 </span>CALL-CMD
</pre>
</div>

<p>
Итак, реализуем <code>:NONAME</code> и [']:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_noname"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">:NONAME
</span>    <span style="color: #008787;">0 </span>0 CREATE <span style="color: #af0000;">( create a word with no name - we need a dictionary header because ; expects it )</span>
    HERE @     <span style="color: #af0000;">( current HERE value is the address of the codeword, ie. the xt )</span>
    DOCOL ,    <span style="color: #af0000;">( compile DOCOL  (the codeword)</span> <span style="color: #af00ff;">)</span>
    <span style="color: #af00ff;">] </span>         <span style="color: #af0000;">( go into compile mode )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">['] </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">' </span>LIT ,    <span style="color: #af0000;">( compile LIT )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-52" class="outline-3">
<h3 id="unnumbered-52">Исключения</h3>
<div class="outline-text-3" id="text-unnumbered-52">
<p>
Удивительно, но исключения могут быть реализованы непосредственно в FORTH, на самом
деле довольно легко.
</p>

<p>
Общее использование:
</p>

<div class="org-src-container">

<pre class="src src-forth">: FOO ( n -- ) THROW <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">TEST-EXCEPTIONS
</span>    <span style="color: #008787;">25 </span>['] FOO CATCH <span style="color: #af0000;">\ execute 25 FOO, catching any exception
</span>    ?DUP <span style="color: #af00ff;">IF</span>
        <span style="color: #87005f;">." called FOO and it threw exception number: "</span>
        . CR
        DROP <span style="color: #af0000;">\ we have to drop the argument of FOO (25)
</span>    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
<span style="color: #af0000;">\ prints: called FOO and it threw exception number: 25
</span>
</pre>
</div>

<p>
CATCH запускает токен выполнения и определяет, выбрасывает ли оно какое-либо исключение
или нет. Стековая сигнатура CATCH довольно сложна:
</p>

<div class="org-src-container">

<pre class="src src-forth">( a_n-1 ... a_1 a_0 xt -- r_m-1 ... r_1 r_0 0 ) <span style="color: #af0000;">\ &#1077;&#1089;&#1083;&#1080; xt &#1085;&#1077; &#1074;&#1099;&#1073;&#1088;&#1072;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; exception
( a_n-1 ... a_1 a_0 xt -- ?_n-1 ... ?_1 ?_0 e )</span> <span style="color: #af0000;">\ &#1077;&#1089;&#1083;&#1080; xt &#1074;&#1099;&#1073;&#1088;&#1072;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090; exception 'e'
</span>
</pre>
</div>

<p>
где a<sub>i</sub> и r<sub>i</sub> - это (произвольное число) аргументов и содержимое стека возврата до и
после того, как <code>xt</code> выполнен с помощью EXECUTE. Обратите внимание, в частности, на
такой случай: когда генерируется исключение, указатель стека восстанавливается так, что
в стеке есть <code>n</code> из <code>something</code> в позициях, где раньше были аргументы <code>a_i</code>. Мы
действительно не гарантируем, что находится в стеке - возможно, исходные аргументы а,
возможно, какая-то другая ерунда - это во многом зависит от реализации слова, которое
выполнялось.
</p>

<p>
THROW, ABORT и еще несколько других исключений.
</p>

<p>
Номера исключений - это целые числа, отличные от нуля. По условным обозначениям
положительные числа могут использоваться для особых приложений, а отрицательные числа
имеют определенные значения, определенные в стандарте ANS FORTH. (Например, -1 - это
исключение, вызванное ABORT).
</p>

<p>
<code>0 THROW</code> ничего не делает. Вот стековая сигнатура THROW:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #af0000;">( 0 -- )</span>
<span style="color: #af0000;">( * e -- ?_n-1 ... ?_1 ?_0 e )</span> <span style="color: #af0000;">\ the stack is restored to the state
</span>                               <span style="color: #af0000;">\ from the corresponding CATCH
</span>
</pre>
</div>

<p>
Реализация зависит от определений CATCH и THROW и состояния, разделяемого между ними.
</p>

<p>
До этого момента стек возврата состоял только из списка адресов возврата, причем
вершина возвращаемого стека была обратным адресом, где мы возобновляем выполнение,
когда текущее слово делает EXIT. Однако CATCH будет push-ить более сложный <code>фрейм стека
исключений</code> в стек возврата. Фрейм стека исключений записывает некоторые вещи о
состоянии выполнения в момент вызова CATCH.
</p>

<p>
Когда THROW вызывается, он идет вверх по стеку возврата (этот процесс называется
"раскруткой"), пока не найдет фрейм стека исключений. Затем он использует данные в
кадре стека исключений, чтобы восстановить состояние, позволяющее продолжить выполнение
после соответствующего CATCH. (Если он разматывает стек и не находит фрейм стека
исключений, он печатает сообщение и возвращается к приглашению, что также является
нормальным поведением для так называемых "непойманных исключений").
</p>

<p>
Это то, как выглядит <code>фрейм стека исключений</code>. (Как обычно, стек возвратов показан
вниз, от более младших до более старших адресов памяти, а растет он вверх).
</p>


<div class="figure">
<p><img src="../../img/forth-interpret-35.png" alt="forth-interpret-35.png">
</p>
</div>

<p>
EXCEPTION-MARKER отмечает эту запись как фрейм стека исключений, а не обычный обратный
адрес, и именно это THROW "замечает", поскольку оно разматывает стек. (Если вы хотите
внедрить более сложные исключения, такие как TRY &#x2026; WITH, тогда вам нужно будет
использовать другое значение маркера, если вы хотите, чтобы старые маркеры фреймов стека
и новые исключения сосуществовали).
</p>

<p>
Что произойдет, если исполняемое слово не выбрасывает исключение? Он, в конце концов,
вернется и вызовет EXCEPTION-MARKER, поэтому EXCEPTION-MARKER лучше сделать что-то
разумное без необходимости изменения EXIT. Это красиво дает нам подходящее определение
EXCEPTION-MARKER, а именно функцию, которая просто отбрасывает кадр стека и сама
возвращается (таким образом, "возвращается" из исходного CATCH).
</p>

<p>
Из этого следует, что исключения - относительно легкий механизм в FORTH.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_exceptions"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">EXCEPTION-MARKER
</span>    RDROP <span style="color: #af0000;">( drop the original parameter stack pointer )</span>
    <span style="color: #008787;">0 </span><span style="color: #af0000;">( there was no exception, this is the normal return path )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">CATCH </span><span style="color: #af0000;">( xt -- exn? )</span>
    DSP@ 4+ &gt;R <span style="color: #af0000;">( save parameter stack pointer  (+4 because of xt)</span> on the return stack <span style="color: #af00ff;">)</span>
    <span style="color: #af00ff;">' </span>EXCEPTION-MARKER 4+ <span style="color: #af0000;">( push the address of the RDROP inside EXCEPTION-MARKER ... )</span>
    &gt;R <span style="color: #af0000;">( ... on to the return stack so it acts like a return address )</span>
    EXECUTE <span style="color: #af0000;">( execute the nested function )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">THROW </span><span style="color: #af0000;">( n -- )</span>
    ?DUP <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( only act if the exception code &lt;&gt; 0 )</span>
        RSP@  <span style="color: #af0000;">( get return stack pointer )</span>
        <span style="color: #af00ff;">BEGIN</span>
            DUP R0 4- &lt; <span style="color: #af0000;">( RSP &lt; R0 )</span>
        <span style="color: #af00ff;">WHILE</span>
                DUP @ <span style="color: #af0000;">( get the return stack entry )</span>
                <span style="color: #af00ff;">' </span>EXCEPTION-MARKER 4+ = IF <span style="color: #af0000;">( found the EXCEPTION-MARKER on the return stack )</span>
                    4+ <span style="color: #af0000;">( skip the EXCEPTION-MARKER on the return stack )</span>
                    RSP! <span style="color: #af0000;">( restore the return stack pointer )</span>

                    <span style="color: #af0000;">( Restore the parameter stack. )</span>
                    DUP DUP DUP <span style="color: #af0000;">( reserve some working space so the stack for this word
                    doesn't coincide with the part of the stack being restored )</span>
                    R&gt; <span style="color: #af0000;">( get the saved parameter stack pointer | n dsp )</span>
                    4- <span style="color: #af0000;">( reserve space on the stack to store n )</span>
                    SWAP OVER <span style="color: #af0000;">( dsp n dsp )</span>
                    ! <span style="color: #af0000;">( write n on the stack )</span>
                    DSP! EXIT <span style="color: #af0000;">( restore the parameter stack pointer, immediately exit )</span>
                <span style="color: #af00ff;">THEN</span>
                4+
        <span style="color: #af00ff;">REPEAT</span>

        <span style="color: #af0000;">( No matching catch - print a message and restart the INTERPRETer. )</span>
        DROP

        <span style="color: #af00ff;">CASE</span>
            <span style="color: #008787;">0 </span>1- OF <span style="color: #af0000;">( ABORT )</span>
                <span style="color: #87005f;">." ABORTED"</span> CR
            <span style="color: #af00ff;">ENDOF</span>
            <span style="color: #af0000;">( default case )</span>
            <span style="color: #87005f;">." UNCAUGHT THROW "</span>
            DUP . CR
        <span style="color: #af00ff;">ENDCASE</span>
        QUIT
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ABORT </span><span style="color: #af0000;">( -- )</span>
    <span style="color: #008787;">0 </span>1- THROW
<span style="color: #af00ff;">;</span>


<span style="color: #af0000;">( Print a stack trace by walking up the return stack. )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">PRINT-STACK-TRACE
</span>    RSP@ <span style="color: #af0000;">( start at caller of this function )</span>
    <span style="color: #af00ff;">BEGIN</span>
        DUP R0 4- &lt; <span style="color: #af0000;">( RSP &lt; R0 )</span>
    <span style="color: #af00ff;">WHILE</span>
            DUP @ <span style="color: #af0000;">( get the return stack entry )</span>
            <span style="color: #af00ff;">CASE</span>
                <span style="color: #af00ff;">' </span>EXCEPTION-MARKER 4+ OF <span style="color: #af0000;">( is it the exception stack frame? )</span>
                    <span style="color: #87005f;">." CATCH  ( DSP="</span>
                    4+ DUP @ U. <span style="color: #af0000;">( print saved stack pointer )</span>
                    <span style="color: #87005f;">." ) "</span>
                <span style="color: #af00ff;">ENDOF</span>
                <span style="color: #af0000;">( default case )</span>
                DUP
                CFA&gt; <span style="color: #af0000;">( look up the codeword to get the dictionary entry )</span>
                ?DUP <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( and print it )</span>
                    2DUP <span style="color: #af0000;">( dea addr dea )</span>
                    ID. <span style="color: #af0000;">( print word from dictionary entry )</span>
                    <span style="color: #af00ff;">[ </span>CHAR + <span style="color: #af00ff;">] </span>LITERAL EMIT
                    SWAP &gt;DFA 4+ - . <span style="color: #af0000;">( print offset )</span>
                <span style="color: #af00ff;">THEN</span>
            <span style="color: #af00ff;">ENDCASE</span>
            4+ <span style="color: #af0000;">( move up the stack )</span>
    <span style="color: #af00ff;">REPEAT</span>
    DROP
    CR
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-53" class="outline-3">
<h3 id="unnumbered-53">Строки языка Си</h3>
<div class="outline-text-3" id="text-unnumbered-53">
<p>
Строки FORTH представлены начальным адресом и длиной, хранящейся в стеке или в памяти.
</p>

<p>
Большинство FORTH-ов не обрабатывают строки Си, но мы нуждаемся в них, чтобы получить
доступ к аргументам процесса и окружающей среде, оставленным в стеке ядром Linux, и
сделать некоторые системные вызовы.
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Операция</th>
<th scope="col" class="left">Input</th>
<th scope="col" class="left">Output</th>
<th scope="col" class="left">FORTH word</th>
<th scope="col" class="left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Создание FORTH-строк</td>
<td class="left">addr len</td>
<td class="left">S" &#x2026;"</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Создание C-строк</td>
<td class="left">c-addr</td>
<td class="left">Z" &#x2026;"</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">C -&gt; FORTH</td>
<td class="left">c-addr</td>
<td class="left">addr len</td>
<td class="left">DUP STRLEN</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">FORTH -&gt; C</td>
<td class="left">addr len</td>
<td class="left">c-addr</td>
<td class="left">CSTRING</td>
<td class="left">Аллоцируются во</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">временном буфере</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">и должны быть</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">использованы или</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">скопированы сразу.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">И не должны</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">содержать NULs</td>
</tr>
</tbody>
</table>

<p>
Например, <code>DUP STRLEN TELL</code> печатает строку C.
</p>

<p>
Z" &#x2026;" очень похожа на S" &#x2026;" за исключением того, что строка заканчивается символом
ASCII NUL.
</p>

<p>
Чтобы сделать его более похожим на строку C, во время выполнения Z" просто оставляет
адрес строки в стеке (а не адрес и длину, как ~S"~) Чтобы реализовать это, нам нужно
добавить дополнительный NUL в строку, а затем инструкцию DROP. Кроме этого, эта
реализация является лишь модифицированной S".
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_zerostrings">: Z" <span style="color: #af00ff;">IMMEDIATE</span>
    STATE @ <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( compiling? )</span>
        <span style="color: #af00ff;">' </span>LITSTRING , <span style="color: #af0000;">( compile LITSTRING )</span>
        HERE @ <span style="color: #af0000;">( save the address of the length word on the stack )</span>
        <span style="color: #008787;">0 </span>, <span style="color: #af0000;">( dummy length - we don't know what it is yet )</span>
        <span style="color: #af00ff;">BEGIN</span>
            KEY  <span style="color: #af0000;">( get next character of the string )</span>
            DUP '"' &lt;&gt;
        <span style="color: #af00ff;">WHILE</span>
                HERE @ C! <span style="color: #af0000;">( store the character in the compiled image )</span>
                <span style="color: #008787;">1 </span>HERE +! <span style="color: #af0000;">( increment HERE pointer by 1 byte )</span>
        <span style="color: #af00ff;">REPEAT</span>
        <span style="color: #008787;">0 </span>HERE @ C! <span style="color: #af0000;">( add the ASCII NUL byte )</span>
        <span style="color: #008787;">1 </span>HERE +!
        DROP <span style="color: #af0000;">( drop the double quote character at the end )</span>
        DUP <span style="color: #af0000;">( get the saved address of the length word )</span>
        HERE @ SWAP - <span style="color: #af0000;">( calculate the length )</span>
        4- <span style="color: #af0000;">( subtract 4  (because we measured from the start of the length word)</span> <span style="color: #af00ff;">)</span>
        SWAP ! <span style="color: #af0000;">( and back-fill the length location )</span>
        ALIGN <span style="color: #af0000;">( round up to next multiple of 4 bytes for the remaining code )</span>
        <span style="color: #af00ff;">' </span>DROP , ( compile DROP  (to drop the length) <span style="color: #af00ff;">)</span>
    <span style="color: #af00ff;">ELSE </span><span style="color: #af0000;">( immediate mode )</span>
        HERE @ <span style="color: #af0000;">( get the start address of the temporary space )</span>
        <span style="color: #af00ff;">BEGIN</span>
            KEY
            DUP '"' &lt;&gt;
        <span style="color: #af00ff;">WHILE</span>
                OVER C! <span style="color: #af0000;">( save next character )</span>
                1+ <span style="color: #af0000;">( increment address )</span>
        <span style="color: #af00ff;">REPEAT</span>
        DROP <span style="color: #af0000;">( drop the final " character )</span>
        <span style="color: #008787;">0 </span>SWAP C! <span style="color: #af0000;">( store final ASCII NUL )</span>
        HERE @ <span style="color: #af0000;">( push the start address )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">STRLEN </span> <span style="color: #af0000;">( str -- len )</span>
    DUP <span style="color: #af0000;">( save start address )</span>
    <span style="color: #af00ff;">BEGIN</span>
        DUP C@ 0&lt;&gt; <span style="color: #af0000;">( zero byte found? )</span>
    <span style="color: #af00ff;">WHILE</span>
            1+
    <span style="color: #af00ff;">REPEAT</span>

    SWAP - <span style="color: #af0000;">( calculate the length )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">CSTRING </span><span style="color: #af0000;">( addr len -- c-addr )</span>
    SWAP OVER <span style="color: #af0000;">( len saddr len )</span>
    HERE @ SWAP <span style="color: #af0000;">( len saddr daddr len )</span>
    CMOVE <span style="color: #af0000;">( len )</span>

    HERE @ + <span style="color: #af0000;">( daddr+len )</span>
    <span style="color: #008787;">0 </span>SWAP C! <span style="color: #af0000;">( store terminating NUL char )</span>

    HERE @  <span style="color: #af0000;">( push start address )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-54" class="outline-3">
<h3 id="unnumbered-54">Окружение</h3>
<div class="outline-text-3" id="text-unnumbered-54">
<p>
Linux делает аргументы процесса и переменные окружения доступными нам в стеке.
</p>

<p>
Указатель вершины стека сохраняется ранним ассемблерным кодом при запуске FORTH в
переменной S0, и начиная с этого указателя мы можем прочитать аргументы командной
строки и переменные окружения.
</p>

<p>
Начав с <code>S0</code>, сам <code>S0</code> указывает на <code>argc</code> (количество аргументов командной строки).
</p>

<p>
<code>S0+4</code> указывает на <code>argv[ 0 ]</code>, S0+8 указывает на <code>argv[ 1 ]</code> etc до <code>argv[ argc-1 ]</code>.
</p>

<p>
<code>argv[ argc ]</code> это NULL указатель
</p>

<p>
После этого стек содержит переменные окружения - набор указателей на строки формы
NAME=VALUE до тех пор, пока мы не перейдем к другому указателю NULL.
</p>

<p>
Первое слово, которое мы определяем, ARGC, push-ит количество аргументов командной
строки (обратите внимание, что как и в случае с Сишным <code>argc</code>, это включает в себя имя
программы).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_argc"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">ARGC
</span>    S0 @ @
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
<code>n ARGV</code> получаетет "энный" аргумент командной строки
</p>

<p>
Например, чтобы напечатать имя программы, вы сделали бы:
</p>

<div class="org-src-container">

<pre class="src src-forth"><span style="color: #008787;">0 </span>ARGV TELL CR
</pre>
</div>

<p>
Вот реализация
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_argv">: ARGV  <span style="color: #af0000;">( n -- str u )</span>
    1+ CELLS S0 @ + <span style="color: #af0000;">( get the address of argv[n] entry )</span>
    @ <span style="color: #af0000;">( get the address of the string )</span>
    DUP STRLEN <span style="color: #af0000;">( and get its length / turn it into a FORTH string )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
ENVIRON возвращает адрес первой строки переменных окружения. Список строк заканчивается
указателем NULL.
</p>

<p>
Например, чтобы напечатать первую строку переменных окружения, вы могли бы сделать:
</p>

<div class="org-src-container">

<pre class="src src-forth">ENVIRON @ DUP STRLEN TELL
</pre>
</div>

<p>
Реализация:
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_environ">: ENVIRON   <span style="color: #af0000;">( -- addr )</span>
    ARGC    <span style="color: #af0000;">( number of command line parameters on the stack to skip )</span>
    <span style="color: #008787;">2 </span>+     <span style="color: #af0000;">( skip command line count and NULL pointer after the command line args )</span>
    CELLS   <span style="color: #af0000;">( convert to an offset )</span>
    S0 @ +  <span style="color: #af0000;">( add to base stack address )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-55" class="outline-3">
<h3 id="unnumbered-55">Системные вызовы и файлы</h3>
<div class="outline-text-3" id="text-unnumbered-55">
<p>
Различные слова, связанные с системными вызовами, и стандартный доступ к файлам.
</p>

<p>
BYE вызывается, вызывая системный вызов выхода Linux (2).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_bye">: BYE <span style="color: #af0000;">( -- )</span>
    <span style="color: #008787;">0 </span>( return code  (0) <span style="color: #af00ff;">)</span>
    SYS_EXIT <span style="color: #af0000;">( system call number )</span>
    SYSCALL1
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
UNUSED возвращает количество ячеек, оставшихся в пользовательской памяти (в сегменте
данных).
</p>

<p>
Для нашей реализации мы будем использовать системный вызов Linux brk (2), чтобы узнать
конец сегмента данных и вычесть HERE из него.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_unused">: GET-BRK <span style="color: #af0000;">( -- brkpoint )</span>
    <span style="color: #008787;">0 </span>SYS_BRK SYSCALL1 ( call brk (0) <span style="color: #af00ff;">)</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">UNUSED </span><span style="color: #af0000;">( -- n )</span>
    GET-BRK <span style="color: #af0000;">( get end of data segment according to the kernel )</span>
    HERE @ <span style="color: #af0000;">( get current position in data segment )</span>
    -
    <span style="color: #008787;">4 </span>/ <span style="color: #af0000;">( returns number of cells )</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
MORECORE увеличивает сегмент данных на указанное количество (4-х байтовых) ячеек.
</p>

<p>
NB. Количество запрошенных ячеек должно быть, как правило, кратным 1024. Причина в том,
что Linux не может расширить сегмент данных менее чем на одну страницу (4096 байт или
1024 ячейки).
</p>

<p>
Этот FORTH автоматически не увеличивает размер сегмента данных "по запросу" (т.е. Когда
используются (COMMA), ALLOT, CREATE и.т.д.). Вместо этого программист должен знать,
сколько места займет большое выделение, провеить UNUSED и вызвать MORECORE, если это
необходимо. Простым упражнением для читаетеля является изменение реализации сегмента
данных, так что MORECORE вызывается автоматически, если программе требуется больше
памяти.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_morecore">: BRK( brkpoint -- <span style="color: #af00ff;">)</span>
    SYS_BRK SYSCALL1
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">MORECORE( </span>cells -- <span style="color: #af00ff;">)</span>
    CELLS GET-BRK + BRK
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Стандарт FORTH предоставляет некоторые простые примитивы доступа к файлам, которые мы
моделируем поверх системных вызовов Linux.
</p>

<p>
Главным осложнением является преобразование строк FORTH (адрес и длина) в строки Си для
ядра Linux.
</p>

<p>
Обратите внимание, что в этой реализации нет буферизации.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_files">: R/O  ( -- fam ) O_RDONLY <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">R/W </span> ( -- fam ) O_RDWR <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">OPEN-FILE </span>( addr u fam -- fd 0  (if successful) | c-addr u fam -- fd errno  (if there was an error) <span style="color: #af00ff;">)</span>
    -ROT <span style="color: #af0000;">( fam addr u )</span>
    CSTRING <span style="color: #af0000;">( fam cstring )</span>
    SYS_OPEN SYSCALL2  <span style="color: #af0000;">( open  (filename, flags)</span> <span style="color: #af00ff;">)</span>
    DUP <span style="color: #af0000;">( fd fd )</span>
    DUP 0&lt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( errno? )</span>
        NEGATE <span style="color: #af0000;">( fd errno )</span>
    <span style="color: #af00ff;">ELSE</span>
        DROP <span style="color: #008787;">0 </span><span style="color: #af0000;">( fd 0 )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">CREATE-FILE </span>( addr u fam -- fd 0  (if successful) | c-addr u fam -- fd errno  (if there was an error) <span style="color: #af00ff;">)</span>
    O_CREAT OR
    O_TRUNC OR
    -ROT <span style="color: #af0000;">( fam addr u )</span>
    CSTRING <span style="color: #af0000;">( fam cstring )</span>
    <span style="color: #008787;">420 </span>-ROT <span style="color: #af0000;">( 0644 fam cstring )</span>
    SYS_OPEN SYSCALL3  <span style="color: #af0000;">( open  (filename, flags|O_TRUNC|O_CREAT, 0644)</span> <span style="color: #af00ff;">)</span>
    DUP <span style="color: #af0000;">( fd fd )</span>
    DUP 0&lt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( errno? )</span>
        NEGATE <span style="color: #af0000;">( fd errno )</span>
    <span style="color: #af00ff;">ELSE</span>
        DROP <span style="color: #008787;">0 </span><span style="color: #af0000;">( fd 0 )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">CLOSE-FILE </span>( fd -- 0  (if successful) | fd -- errno  (if there was an error) <span style="color: #af00ff;">)</span>
    SYS_CLOSE SYSCALL1
    NEGATE
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">READ-FILE </span>( addr u fd -- u2 0  (if successful) | addr u fd -- 0 0  (if EOF) | addr u fd -- u2 errno  (if error) <span style="color: #af00ff;">)</span>
    &gt;R SWAP R&gt; <span style="color: #af0000;">( u addr fd )</span>
    SYS_READ SYSCALL3

    DUP <span style="color: #af0000;">( u2 u2 )</span>
    DUP 0&lt; <span style="color: #af00ff;">IF </span><span style="color: #af0000;">( errno? )</span>
        NEGATE <span style="color: #af0000;">( u2 errno )</span>
    <span style="color: #af00ff;">ELSE</span>
        DROP <span style="color: #008787;">0 </span><span style="color: #af0000;">( u2 0 )</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af0000;">\ PERROR prints a message for an errno, similar to C's perror (3) but we don't have the extensive
\ list of strerror strings available, so all we can do is print the errno.
</span><span style="color: #af00ff;">: </span><span style="color: #0000ff;">PERROR </span><span style="color: #af0000;">( errno addr u -- )</span>
    TELL
    ':' EMIT SPACE
    <span style="color: #87005f;">." ERRNO="</span>
    . CR
<span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
Это всего лишь схема простого ассемблера, позволяющая писать примитивы FORTH на языке
ассемблера прямо изнутри Fort-а
</p>

<p>
Ассемблерные примитивы начинаются с <code>: NAME</code> обычным способом, но заканчиваются
~":CODE.~
</p>

<p>
<code>;CODE</code> обновляет заголовок так, что кодовое слово не является DOCOL, а указывает
вместо этого на собранный код (в части DFA слова).
</p>

<p>
Мы предоставляем удобный макрос NEXT (вы догадались, что он делает). Однако вам не
нужно использовать его, потому что CODE поместит NEXT в конец вашего слова.
</p>

<p>
Остальное состоит из некоторых непосредственных слов, которые расширяются в машинный
код, прилагаемый к определению слова. Только крошечная часть сборки сборки i386
покрыта, достаточно, чтобы написать несколько ассемблерных примитивов ниже.
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_asm">HEX

<span style="color: #af0000;">( Equivalent to the NEXT macro )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">NEXT </span>IMMEDIATE AD C, FF C, 20 C, <span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">;CODE </span><span style="color: #af00ff;">IMMEDIATE</span>
    <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">NEXT </span>       <span style="color: #af0000;">( end the word with NEXT macro )</span>
    ALIGN                 <span style="color: #af0000;">( machine code is assembled in bytes so isn't necessarily aligned at the end )</span>
    LATEST @ DUP
    HIDDEN                <span style="color: #af0000;">( unhide the word )</span>
    DUP &gt;DFA SWAP &gt;CFA !  <span style="color: #af0000;">( change the codeword to point to the data area )</span>
    <span style="color: #af00ff;">[COMPILE] </span><span style="color: #0000ff;">[ </span>          <span style="color: #af0000;">( go back to immediate mode )</span>
<span style="color: #af00ff;">;</span>

<span style="color: #af0000;">( The i386 registers )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">EAX </span>IMMEDIATE 0 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ECX </span>IMMEDIATE 1 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">EDX </span>IMMEDIATE 2 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">EBX </span>IMMEDIATE 3 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ESP </span>IMMEDIATE 4 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">EBP </span>IMMEDIATE 5 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">ESI </span>IMMEDIATE 6 <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">EDI </span>IMMEDIATE 7 <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">( i386 stack instructions )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">PUSH </span>IMMEDIATE 50 + C, <span style="color: #af00ff;">;</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">POP </span>IMMEDIATE 58 + C, <span style="color: #af00ff;">;</span>

<span style="color: #af0000;">( RDTSC instruction )</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">RDTSC </span>IMMEDIATE 0F C, 31 C, <span style="color: #af00ff;">;</span>

DECIMAL

<span style="color: #af0000;">\ RDTSC is an assembler primitive which reads the Pentium timestamp counter  (a very fine-
\ grained counter which counts processor clock cycles).  Because the TSC is 64 bits wide
\ we have to push it onto the stack in two slots.
</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">RDTSC </span><span style="color: #af0000;">( -- lsb msb )</span>
    RDTSC <span style="color: #af0000;">( writes the result in %edx:%eax )</span>
    EAX PUSH <span style="color: #af0000;">( push lsb )</span>
    EDX PUSH <span style="color: #af0000;">( push msb )</span>
<span style="color: #af00ff;">;CODE</span>
</pre>
</div>

<p>
INLINE может использоваться для встраивания примитива ассемблера в текущее
(ассемблерное) слово.
</p>

<p>
Например:
</p>

<div class="org-src-container">

<pre class="src src-forth">: 2DROP INLINE DROP INLINE DROP <span style="color: #af00ff;">;CODE</span>
</pre>
</div>

<p>
построит эффективное ассемблерное слово 2DROP, которое содержит встроенный код
ассемблерной команды для DROP, за которым следует DROP (например, два 'pop %eax'
инструкции в этом случае).
</p>

<p>
Другой пример. Рассмотрим это обычное определение FORTH:
</p>

<div class="org-src-container">

<pre class="src src-forth">: C@++ ( addr -- addr+1 byte ) DUP 1+ SWAP C@ <span style="color: #af00ff;">;</span>
</pre>
</div>

<p>
(это эквивалентно операции Си '*p++' где p - указатель на char).  Если вы заметили, что
все слова, используемые для определения C@++, на самом деле являются ассемблерными
примитивами, то мы можем писать быстрейшее (но эквивалентное) определение:
</p>

<div class="org-src-container">

<pre class="src src-forth">: C@++ INLINE DUP INLINE 1+ INLINE SWAP INLINE C@ <span style="color: #af00ff;">;CODE</span>
</pre>
</div>

<p>
Интересно отметить, что этот "конкатенативный" стиль программирования позволяет писать
на ассемблере переносимым образом. Вышеприведенное определение будет работать для любой
архитектуры процессора.
</p>

<p>
Для успешного использования INLINE необходимо выполнить несколько условий:
</p>
<ul class="org-ul">
<li>(1) В настоящее время вы должны определить слово ассемблера (т.е. <code>: ... ;CODE</code>).
</li>
<li>(2) Слово, в котором вы находитесь, должно быть известно как ассемблерное слово. Если
вы попытаетесь вставить слово FORTH, вы получите сообщение об ошибке.
</li>
<li>(3) Ассемблерный примитив должен быть позиционно-независимым и должен заканчиваться
одним NEXT макросом.
</li>
</ul>

<p>
Упражнения для читателя:
</p>
<ul class="org-ul">
<li>(a) Обобщите INLINE, чтобы он мог вставлять слова FORTH при построении слов FORTH.
</li>
<li>(b) Дальнейшее обобщение INLINE, чтобы оно делало что-то разумное, когда вы пытаетесь
встроить FORTH в ассемблер и наоборот.
</li>
</ul>

<p>
Реализация INLINE довольно проста. Мы находим слово в словаре, проверяем его как
ассемблерное слово, а затем копируем его в текущее определение байтом за байтом, пока
не достигнем макроса NEXT (который не копируем).
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_inlining_asm">HEX
<span style="color: #af00ff;">: </span><span style="color: #0000ff;">=NEXT </span><span style="color: #af0000;">( addr -- next? )</span>
    DUP C@ AD &lt;&gt; <span style="color: #af00ff;">IF </span>DROP FALSE EXIT <span style="color: #af00ff;">THEN</span>
    1+ DUP C@ FF &lt;&gt; <span style="color: #af00ff;">IF </span>DROP FALSE EXIT <span style="color: #af00ff;">THEN</span>
    1+     C@ <span style="color: #008787;">20 </span>&lt;&gt; IF      FALSE EXIT <span style="color: #af00ff;">THEN</span>
    <span style="color: #008787;">TRUE</span>
<span style="color: #af00ff;">;</span>
DECIMAL

<span style="color: #af0000;">(  (INLINE)</span> is the lowlevel inline function. <span style="color: #ff0000; font-weight: bold;">)</span>
<span style="color: #af00ff;">: </span><span style="color: #0000ff;"> (INLINE) </span><span style="color: #af0000;">( cfa -- )</span>
    @ <span style="color: #af0000;">( remember codeword points to the code )</span>
    <span style="color: #af00ff;">BEGIN </span><span style="color: #af0000;">( copy bytes until we hit NEXT macro )</span>
        DUP =NEXT NOT
    <span style="color: #af00ff;">WHILE</span>
            DUP C@ C,
            1+
    <span style="color: #af00ff;">REPEAT</span>
    DROP
<span style="color: #af00ff;">;</span>

<span style="color: #af00ff;">: </span><span style="color: #0000ff;">INLINE </span><span style="color: #af00ff;">IMMEDIATE</span>
    WORD FIND <span style="color: #af0000;">( find the word in the dictionary )</span>
    &gt;CFA <span style="color: #af0000;">( codeword )</span>

    DUP @ DOCOL = <span style="color: #af00ff;">IF </span>( check codeword &lt;&gt; DOCOL  (ie. not a FORTH word) <span style="color: #af00ff;">)</span>
        <span style="color: #87005f;">." Cannot INLINE FORTH words"</span> CR ABORT
    <span style="color: #af00ff;">THEN</span>

    (INLINE)
<span style="color: #af00ff;">;</span>

HIDE =NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-56" class="outline-3">
<h3 id="unnumbered-56">Заметка</h3>
<div class="outline-text-3" id="text-unnumbered-56">
<p>
DOES&gt; невозможно реализовать с помощью этого FORTH, потому что у нас нет отдельного
указателя данных.
</p>
</div>
</div>

<div id="outline-container-unnumbered-57" class="outline-3">
<h3 id="unnumbered-57">Приветствие</h3>
<div class="outline-text-3" id="text-unnumbered-57">
<p>
Это слово печатает версию и "ok":
</p>

<div class="org-src-container">

<pre class="src src-forth" id="forth_welcome"><span style="color: #af00ff;">: </span><span style="color: #0000ff;">WELCOME
</span>    <span style="color: #87005f;">S" TEST-MODE"</span> FIND NOT <span style="color: #af00ff;">IF</span>
        <span style="color: #87005f;">." JONESFORTH VERSION "</span> VERSION . CR
        UNUSED . <span style="color: #87005f;">." CELLS REMAINING"</span> CR
        <span style="color: #87005f;">." OK "</span>
    <span style="color: #af00ff;">THEN</span>
<span style="color: #af00ff;">;</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-unnumbered-58" class="outline-2">
<h2 id="unnumbered-58">Резюме</h2>
<div class="outline-text-2" id="text-unnumbered-58">
<div class="org-src-container">

<pre class="src src-forth" id="forth_all">WELCOME
HIDE WELCOME
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
