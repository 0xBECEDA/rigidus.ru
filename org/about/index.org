#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Обо мне

* Краткая биография

Меня зовут Глухов Михаил, мой ник ~rigidus~ - его проще нагуглить. Я занимаюсь
программированием и исследованиями в смежных областях. В свободное время конструирую
роботов и программирую их.

Мне можно в любой момент позвонить по телефону ~8(911)286-92-90~ или написать на
~i.am.rigidus at gmail dot com~

Еще я постоянный участник (и иногда - докладчик) семинаров по функциональному
программированию в Санкт-Петербурге [[https://plus.google.com/communities/106931692847918217517][fprog-community]] и [[http://piter-united.ru][IT-Global-Meetup]]

Дальше будет моя би(бли)ография. Она почти целиком состоит из тех книг, которые меня
сформировали как программиста.

* Первые шаги
** Basic

Я стал программмировать в классе, если я не ошибаюсь, седьмом, мне было 12-13 лет. С
тех пор я занимаюсь этим практически без перерывов - даже в отпуске и путешествиях со
мной всегда ноутбук и если иногда и случаются дни без кода - это довольно редкое
явление.

Моим первым языком программирования был бейсик для компьютера ~Sinclair48k~. Вот он:

[[img:ZXSpectrum48k.jpg]]

Этот компьютер обладал оперативной памятью в 48 килобайт, а жесткого диска у него
вообще не было. Программы грузились с кассетного магнитофона, который давал сбои из-за
скачков напряжения в сети. Поэтому я просто набирал программы заново. Это было
божественно прекрасно, ведь недавно у меня вообще не было компьютера и я ходил
программировать в школьный компьютерный кружок, а там было слишком много других
желающих.

** JavaScript

Вторым моим языком программирования был ~JScript~ - вариант языка ~JavaScript~ для
броузера ~Internet Explorer~ версии 3.2. С тех пор, люди, проклинающие ~Internet
Explorer~ 8-ой версии вызывают у меня только улыбку.

На нем я попытался написать, конечно же, вебстраничку. Сложно сказать, зачем я это
делал, ведь интернет, даже диалапный появился у меня гораздо позже - наверное, просто
хотелось программировать, а ~JScript~ был доступен без установки компилятора, который я
тогда не знал где брать и как ставить - мне было 14 лет и у меня появился компьютер с
~Windows95~ и ~Internet Explorer~, который выглядел так:

[[img:ie3.png]]

Википедии кстати тогда тоже еще не было (чего не скажешь по скриншоту). Среда
программирования была очень бедной - единственный способ для программы сохранить
какое-то данные - это записать их в cookies.

** Delphi

Возможность работать с файловой системой из программы (читать и сохранять файлы)
появилась, когда я начал использовать ~Delphi~.

Ребенок из неполной семьи, живущий в пригороде, не может купить толстое руководство по
~Delphi~ "в подлиннике", поэтому после учебы я ехал в "Дом Книги". Дорога занимала
полтора часа, в торговом зале стульев не было, но можно было почитать час-полтора, стоя
у стеллажа. А потом ехать домой - пробовать полученные знания. Продавщицы стали меня
узнавать - так я смог прочитать почти две тысячи страниц.

[[img:delphi4.jpg]]

На ~Delphi~ я написал записную книжку - органайзер, который умел предупреждать меня о
днях рождения знакомых и показывала их на календаре. Еще она хранила их телефоны и
делала еще много разных вещей. Я определенно мог гордиться собой..

** Ассемблер x86

..пока не повстречался с одним более старшим коллегой-программистом. Он работал в
конторе, которая делала устройства для рекламы под управлением микроконтроллев. Он
сообщил мне, что ~Delphi~ - это для детей, а настоящие программисты программируют на
Ассемблере. Книжный магазин уже ждал меня...

[[img:assembler3books.jpg]]

Ассемблер был куда сложнее, но отступать было некуда. Много позже я понял, что коллега,
скорее всего, имел ввиду куда более простой ассемблер для микроконтроллеров PIC, но
тогда я этого не знал, и к счастью: мне пришлось изучить регистры процессора и режимы
адресации, способы написания резидентных программ под MS-DOS, научиться писать в порты
и читать из них, чтобы управлять устройствами без драйверов, и даже переводить
процессор в защищенный режим.

На одном из дисков с пиратским софтом мне попались электронные журналы демомейкеров
(интернета пока еще не было). Я смог немного прикоснусться к демо-сцене, реверсингу и
анализу всяческих кряков.

[[img:ezine.png]]

Это было совершенно волшебно. Я писал на ассемблере, и делфи, изучал защиты программ,
антиотладочные приемы, и даже не думал, что все это может быть интересно кому-то еще,
кроме меня и загадочных авторов книг и электронных журналов.

Пожалуй самым высоким достижением на этом пути было написание собественной операционной
системы защищенного режима. Она имела загрузчик, размещенный в Master Boot Record
дискеты, который прямым обращением к контроллеру дисковода умел загружать собственно
операционную систему.

После загрузки с дискеты она переходила в защищенный режим, инициализировала GDI и LDI
(глобальную и локальную дескрипторные таблицы, содержащие дескрипторы сегментов) и
таблицу векторов прерываний. С помощью прерываний обрабатывалась мышь, которую можно
было использовать для операций внутри простой оконной подсистемы и запускать
приложения. Приложений было три, все они работали в SVGA-режиме и представляли собой
простые игры: "змейка", "арканоид" и несколько упрощенный "диггер".

Все это занимало меня в 16-17 лет, и это было весьма интересно.

** C/C++

[[img:cman.jpg]]

После практики программирования на ассемблере, язык Си, который я изучал по
классическому руководству Кернигана и Ритчи, был понятен и привычен. Работа с
указателями, построение сложных структур данных и алгоритмов стали гораздо проще
записываться и быстрее читаться. Было довольно приятно посвятить некоторое время работе
с этим языком.

[[img:cppman.jpg]]

Начав, через некоторое время изучать С++ я обнаружил, что это совсем другой язык, с
другой идеологией и практикой применения. Я уже был знаком с ООП на примере ~Delphi~
(как я тогда думал), и даже ухитрялся реализовывать его в ассемблерных программах, в
качестве развлечения.

Было очень интересно, как именно все реализовано в C++: таблицы виртуальных функций,
порядок вызова деструкторов и тому подобные вещи занимали все мои мысли. С++ казался
очень мощным и довольно непростым - сколько бы не уходило времени на его изучение, я не
мог сказать с уверенностью, что я "знаю" этот язык - всегда были вещи, которые могли
поставить в тупик. Так что я продолжал тратить все больше времени на изучение С++. Я
легко мог себе это позволить - я был школьником, посвящавшим все свободное время
программированию.

* Веб-программирование
** Первый коммерческий проект

..я сделал для фирмы, которая торговала авточехлами и автоинструментом. Увидев, как я
обрабатываю ему фотку в фотошопе, директор конторы спросил, не мог бы я ему сделать
сайт? Почему бы не попробовать? Программирование на PHP и JavaScript) было гораздо
проще С++ и Ассемблера.

Бум доткомов докатился до нас - внезапно всем стали нужны сайты. Много людей были
готовы дать денег за то, что я бы с удовольствием делал бы и бесплатно. Мне просто
повезло - на пустом рынке я оказался одним из немногих опытных специалистов.

Сделав сайт паре фирм, я устроился на работу веб-программистом в веб-студию. Весь код
был в таком ужасном состоянии, что я просто взял и переписал их CMS-движок и быстро
стал тимлидом. Тогда было модно так делать - у каждой конторы была своя CMS, которая
разрабатывалась под "Денвером" - сборкой Apache и MySQL для Windows, а потом заливалась
через FTP на сервера.

Можно было бы гордиться собой, но тут я узнал о существовании Лиспа.

* Лисп
** Побеждая посредственность

Я прочитал [[http:www.nestor.minsk.by/sr/2003/07/30710.html][эссе Пола Грэма "Побеждая посредственность"]] и оно произвело на меня
неизгладимое впечатление. Захотелось срочно попробовать Лисп. Я уже считал себя опытным
разработчиком, поэтому, чтобы процесс проходил веселее, решил поменять не только язык
программирования, но и среду разработки и даже операционную систему. Так у меня в
компьютере оказался Линукс, в нем Емакс, а в Емаксе - Лисп.

Добро пожаловать обратно в школу - весь предыдущий опыт больше не работал - я снова не
мог написать ни одной программы.

Впрочем, проведя два месяца, я все-таки начал что-то понимать. Я даже попытался
написать свой собственный Лисп для использования в веб-студии, но этот проект не был
оценен по достоинству - у них уже была написанная мной CMS, которая приносила неплохой
доход, и никто не хотел менять ее на нечто совершенно новое, сырое, и незнакомое.

Вся работа свелась к поддержке моей CMS, найму программистов и написанию модулей время
от времени. Я стал искать карьерные перспективы. С собеседованиями было сложно - я
выглядел слишком молодо для программиста со знанием ассемблера, С++, PHP и
JavaScript. Пришлось отрастить бороду, и стереть из резюме упоминания о ассемблере, С++
и возрасте - и тогда дело пошло.

** Лисп в индустрии

Я стал искать компанию, в которой мог бы применить свежеполученные mad skillz). И
нашел. Это был интернет-магазин, написанный на PHP и довольно плохо справлявшийся с
нагрузкой. Код был плохим. Впереди были новогодние праздники, главная страница
временами открывалась 28 секунд и настроение у боссов было скверным. Предыдущий
кандидат на мое место после первого дня работы тихо исчез, не оставив контактов.

Я предложил переписать все на Лиспе, а в качестве демонстрации способностей закешировал
самые тяжелые вещи и главная страница стала открываться за 4 секунды. Быстрее было уже
никак, все равно пришлось бы переписывать все, так почему бы и не на Лиспе?

Руководство магазина идею поддержало с оговоркой - деньги за работу будут заплачены
только в том случае, если 90% текущего функционала будут работать и не тормозить. Но
меня уже было не остановить..

** Столкновение с трудностями

Оказалось, что я на самом деле не знал Лисп и что он гораздо сложнее и интереснее чем
мне представлялось на первый взгляд. В процессе разработки мне пришлось узнать довольно
многое - я читал [[file:resources/sicp.pdf][SICP]] и [[file:resources/pcl.pdf][PCL]], а [[file:resources/emacs-man.pdf][руководство пользователя Emacs]], вообще стало настольной
книгой. Это было сложно, но очень интересно.

Через 2 месяца система в общих чертах была готова, и я получил свои деньги, а
руководство фирмы - результат. Все страницы открывалсись моментально, и даже быстрее
чем у конкурентов. Это было неудивительно, если вспомнить, что моя реализация Лиспа
компилировалась прямо в машинный код, а у PHP четвертой версии не было ничего
подобного. Впрочем, там вообще ничего не было: PHP был [[https:habrahabr.ru/post/179399/][создан умирать]] и хранил все
данные в БД.

В новой системе, написанной на Лиспе, почти все необходимые данные постоянно были
загружены в памяти процесса и отдавались с молниеносной скоростью, независимо от
нагрузки.

Благодаря REPL я видел и исправлял ошибки пользователей прямо в момент их
возникновения. Иногда даже до того, как компоненты страницы окончательно были загружены
в броузер пользователя.

Я обучил еще одного программиста и мы стали работать над проектом вдвоем. Кажется, я
даже ушел в отпуск - очень необычные ощущения.

Я стал самым могущественным веб-программистом, ведь в моих руках было секретное оружие,
о котором никто не знал - Лисп!

** Другие приложения

Я начал думать на Лиспе. Разумеется, мне приходилось делать проекты и на других языках,
но первый прототип делался (а часто и показывался) на Лиспе. Благодаря его гибкости, я
успевал вносить правки в проект прямо во время совещаний - к их концу часто уже все
бывало готово.

Однако я обнаружил, что люди странно реагируют, если им показывать изменения сразу -
один коллега программист однажды даже возмущенно сказал, что "это не должно быть
настолько легко!"

Окей, подумал я, и стал брать "недельку на доработки", ведя одновременно несколько
проектов. Это было несложно - корпоративные порталы, интернет-магазины,
баннерно-рекламные сети шли бесконечной чередой. Это было доходно, но хотелось чего-то
большего - я скучал по настоящей работе и самоотверженному изучению чего-то нового,
более мощного..

* Эрланг и Plan9
** Телекоммуникации

Возможность поработать на незнакомом языке представилась довольно скоро и я окунулся в
Эрланг. С функциональным программированием я был знаком и раньше, но впервые у меня
появилась необходимость делать по-настоящему распределенные системы.  Не все шло
гладко - мне опять не хватало знаний и снова мне помог "Дом Книги" (кажется, ему надо
продать спонсорство этой статьи), где я купил "Распределенные системы"
Таненбаума. Теперь я больше мог не стоять в магазине, а взять книгу домой.

[[img:distr-sys.png]]

Несмотря на то, что она совсем не про Эрланг, думаю это одна из важнейших книг для
каждого разработчика. Эрланг будил смешанные чувства: в нем были хорошо сделаны сложные
для Лиспа вещи (многопоточность), и ужасно плохо другие (горячая замена кода), которые
в Лиспе как раз хороши. Для того чтобы понять, чем вдохновлялись авторы языка я начал
читать "Взаимодействующие последовательные процессов" Хоара.

[[img:hoar.jpg]]

Рядом на полке стояла вся серия "Классика Computer Science" и меня заинтересовала еще
одна книжка Таненбаума - "Операционные системы - разработка и реализация". Ее я тоже
купил, просто невозможно было пройти мимо. Наверно именно тогда зародилась идея о
распределенной операционной системе. Вот было бы здорово написать такое... Но,
оказалось, что я - не первый кто об этом задумался.

И действительно, ребята из ~Bell Labs~, сделавшие в свое время ~UNIX~, решили начать с
"чистого листа" и разработали [[https://ru.wikibooks.org/wiki/Plan9][Plan9]]. О котором, кстати, никто не знает, несмотря на то,
что идеи, заложенные в него остаются революционными и сейчас, спустя почти 40 лет.

Создатели ~Plan9~ планировали сделать из своего продукта коммерческую операционную
систему, и исходные тексты долгое время были закрыты. В то время, как ~Linux~ был
полностью открыт и вокруг него формировалось сообщество разработчиков. Вполне
естественно, что бизнес при выборе операционной системы ориентировался на стоимость
поддержки, прямо зависящую от количества компетентных специалистов на рынке. Таким
образом, когда исходные тексты ~Plan9~ были, наконец, открыты - оказалось уже
поздно. Тем не менее, эта операционная система осталась колодцем, из которого еще очень
долго можно черпать идеи. Некторые из этих идей очень хорошо подходят к моим задачам,
но я понимаю, что эти идеи никогда не будут так стройно увязаны в одну систему как в
~Plan9~.

Начав изучать ее устройство, я понял, что мы просто живем в каменном веке операционных
систем. Я потратил довольно много времени на исследование и анализ механизмов, которые
так гениально спроектированы в ~Plan9~.

** Трейдинговые системы

Следующий мой проект был связан с торговлей на бирже. Там были очень жесткие требования
по производительности и времени выполнения операций. Я довольно быстро написал прототип
на лиспе и он, после некоторого количества расширений, вполне устраивал начальника. Но,
когда я попробовал испытать его на серьезной нагрузке, скорость оказалась
недостаточной. Причиной являлась модель многопототочности в той реализации Лиспа,
которую я использовал. В ней (в отличии от Эрланга) создание потоков - достаточно
дорогая операция. В фирме уже работало несколько эрланг-программистов, да и я
первоначально нанимался на эту позицию, поэтому вариантов выбора было
немного. "Переходим на Эрланг" - сказал босс, и я понял что переписывание всего кода
(его было уже немало) на Эрланг займет слишком много времени.

Я решил написать кодогенератор, который сделает это за меня. Задача была сложной и
рискованной, но очень интересной. В процессе разработки прототипа у нас
выкристализовался своего рода "язык предметной области", связанной с биржей, поэтому на
самом деле мне пришлось сделать кодогенерацию этого ограниченного подмножества. Я также
старался, чтобы сгенерированный код был не лапшой, в которой тяжело разобраться, а был
достаточно поддерживаемым и идиоматичным, чтобы любой эрланг-программист не отличил бы
его от написанного человеком.

Разработка кодогенератора заняла почти два месяца - это была новая и незнакомая
задача. Затем мы переехали на Эрланг, наняли еще несколько программистов и далее в
проекте остался только Эрланг и С++.

После успешного опыта с кодогенерацией я заинтересовался тем, как работают
кодогенераторы в известных языках программирования и их компиляторах. Сначала изучал их
исходные тексты, а потом на форуме мне порекомендовали прочесть "[[file:resources/compilers.djvu][Книгу Дракона]]" -
классический учебник по теории построения компиляторов. После предыдущих опытов эта
книга читалась как захватывающий детектив.

[[img:drakon.png]]

* ДРАКОН

Я решил, что кодогенерацию вполне можно поставить на коммерческие рельсы и написал
"язык для разработки сайтов", очень похожий на Лисп, который генерировал код на ~PHP~ и
~JavaScript~ (с использованием ~JQuery~) под основные распространенные фреймворки:
~Symphony~, ~Yii~ и даже ~Wordpress~.

Некоторое время я применял и улучшал этот язык для выполнения множества проектов, но я
обнаружил, что почти никто, кроме меня не хочет им пользоваться, несмотря на простоту и
"заточенность" под типовые задачи. Программистов отпугивал непривычный синтаксис Лиспа,
а пользователи-непрограммисты предпочитали рисовать картинки, отдаленно напоминавшие
блок-схемы, а потом отдавать их мне, чтобы я запрограммировал логику.

Что-то тут было не так. Я стал задумываться об инструменте "визуального
программирования", который можно было бы отдать пользователю, чтобы он сам мог создать
алгоритм. Хотелось дать возможность пользователям создавать блок-схемы для решения
своих задач, а мой генератор по ним мог бы создать код и вставить его в типовой
фреймворк, вроде ~Yii~. И я нашел подходящий инструмент для этой цели - [[https://ru.wikipedia.org/wiki/%D0%94%D0%A0%D0%90%D0%9A%D0%9E%D0%9D][ДРАКОН]]. Он
представляет собой визуальный язык для создания блок-схем, достаточно формализованный,
чтобы была возможность кодогенерации из таких схем. И достаточно понятный, чтобы быстро
научить даже непрограммиста, знакомого только с понятием алгоритма.

Вот так ~ДРАКОН-схема~ выглядит (картинка с одного из сайтов, посвященных языку, сам я
стараюсь использовать ~git~ для управления кодом)

[[img:drakon-svn-ds.png]]

Я с некоторым успехом применил такие схемы для формализации технических заданий, пока
работал в фирме, которая продавала авиа и железнодорожные билеты. В этой отрасли
взаимодействие между системам бронирования и клиентской платформой может быть весьма
нетривиальным.

Для ~ДРАКОН-а~ существует несколько редакторов таких схем. Я выбрал кроссплатформенный,
который называется [[http://drakon-editor.sourceforge.net/][DRAKON Editor]]. И в нем уже есть кодогенерация, для нескольких
языков:
- C и C++ (включая расширения языка из фреймворка Qt)
- Java (а также её подмножество для компьютерной графики — Processing.org)
- C#
- Python (версии 2.х и 3.х)
- Tcl
- JavaScript
- Erlang
- Lua

Я подумал, что будет не очень сложно добавить кодогенерацию и для моего лисп-подобного
языка разработки веб-сайтов. Оказалось, ~Drakon Editor~ написан на ~Tcl~, поэтому чтобы
расширить его - необходимо выучить еще один язык. Еще один язык программирования, да
еще и с поддержкой метапрограммирования? Звучит как отличная идея!

* Tcl

Так что я приступил к изучению ~Tcl~ и ~Tk~. В этом мне помогла замечательная книга:

[[img:tcl-tk.jpg]]

Язык оказался очень интересным и необычным и мне очень понравился возможностью
посмотреть на программирование под другим углом. Кроме того на нем удобно и быстро
прототипировать GUI (кроссплатформенно). Поэтому его используют в пакетах разработки
микросхем.

В общем я увлекся и это закономерным образом привело меня к задачам моделирования
цифровых электрических цепей.

* Электроника
** Моделирование цифровых схем

Первоначальное введение в цифровую схемотехнику я нашел в [[file:resources/sicp.pdf][SICP]], где рассказывалось, как
языковыми средствами построить язык предметной области (DSL), на котором можно написать
программу, ведущую себя в точности как электронная схема.

[[img:sicp.jpg]]

Такой подход позволяет использовать технологии программмирования для построения
электроники. Да и выглядит очень необычно, и захватывающе. Так что я решил перечитать
[[file:resources/sicp.pdf][SICP]], чтобы превратить его из учебного примера в работающую технологию.

[[img:semiadder.png]]

В процессе этой работы оказалось, что электронные схемы - это не просто математическая
абстракция, поэтому пришлось взяться сначала за физику, а потом и за схемотехнику
всерьез:

[[img:horovits_hill.jpg]]

Книжка оказалась очень емкой, поэтому я возвращаюсь к ней по мере возникновения
трудностей.

Для проверки всех этих идей мне пришлось научиться разводить платы и даже делать их с
помощью лазерного принтера и утюга (и для разнообразия - фоторезиста). Удалось
попробовать разные микроконтроллеры - и тут очень удачно пригодился ассемблер и Си. Я
начал с изготовления самодельных устройств для "умного дома", но хотелось чего-то
большего.

** Робототехника и Forth

Я устроился в фирму, где смог найти применение этим навыкам. Однажды нам передали в
разработку устройство, прошивка которого была по-настоящему интересной. При скромных
аппаратных требованиях устройство удивляло своей могучей функциональностью. Требовалось
извлечь из него программу, разобраться в ее работе, и добавить возможность управления
по беспроводному каналу.

После извлечения прошивки, оказалось, что устройство не запрограммировано на Си, как
большинство из встречавшихся ранее. Вместо этого в нем сидит виртуальная машина,
написанная на ассемблере и эта виртуальная машина содержит в себе реализацию
неизвестного мне ранее языка программирования ~Forth~.

Он произвел на меня впечатление своей компактностью и мощностью, поэтому я стал изучать
~Forth~ в свободное время. По нему не очень много руководств, но некоторые из них
весьма хороши.

[[img:thinking-forth.jpg]]

Виртуальная машина ~Forth~ и ее, хм.. "байткод" обладает очень важным свойством - по
байткоду может быть легко восстановлен исходный текст программы. Поэтому после того,
как архитекура ~ForthVM~ стала понятна (и я научился программировать на этом языке) я
смог провести полный реверс-инжиниринг прошивки и даже воссоздать его работу на более
современной элементной базе - пришлось портировать только низкоуровневую ~ForthVM~.

Опираясь на несколько прочитанных руководств, я написал свою реализацию этого языка
(она опубликована на этом сайте). Я также думаю, что эта реализация может служить
своего рода "портабельным слоем" для других языков, которые я захочу реализовать.

Я использую эту реализацию не только в исследовательских целях - на ней сделано
несколько устройств "умный дом" - сигнализация, управление светом, электронные
замки. При этом уровень виртуальной машины полностью портируемый - я могу разрабатывать
программы для устройств, не нуждаясь в стенде до стадии окончательных испытаний.

* Реализация других языков

Чтобы изучить создание языков программирования "на практике", я взялся реализовывать
лисп (как наиболее сложный из известных мне) на форте (для переносимости). В ходе этого
проекта будет реализован диалект, с несколькими отличиями (в лучшую сторону) от
известных мне реализаций.

Я рассчитываю, что подобная практика даст навыки, которые пригодятся при реализации
многих других языков.
