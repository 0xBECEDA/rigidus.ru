#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Обо мне

* Краткая биография

Меня зовут Глухов Михаил, мой ник ~rigidus~ - его проще нагуглить. Я занимаюсь
программированием и исследованиями в смежных областях. В свободное время конструирую
роботов и программирую их.

Мне можно в любой момент позвонить по телефону ~8(911)286-92-90~ или написать на
~i.am.rigidus at gmail dot com~

Еще я постоянный участник (и иногда - докладчик) семинаров по функциональному
программированию в Санкт-Петербурге [[https://plus.google.com/communities/106931692847918217517][fprog-community]] и [[http://piter-united.ru][IT-Global-Meetup]]

Дальше будет моя би(бли)ография. Она почти целиком состоит из тех книг, которые меня
сформировали как программиста.

* Первые шаги
** Basic

Моим первым языком программирования был JavaScript, когда это еще не было
мейнстримом. Впрочем, нет, первым был все-таки бейсик для компьютера ~Sinclair48k~. Вот
он:

#+NAME: Sinclair ZXSpectrum в хорошем состоянии
[[img:ZXSpectrum48k.jpg]]

Этот компьютер обладал оперативной памятью в 48 килобайт, а жесткого диска у него
вообще не было. Программы грузились с кассетного магнитофона, который давал сбои из-за
скачков напряжения в сети. Поэтому я просто набирал программы заново. Это было
божественно прекрасно, ведь недавно у меня вообще не было компьютера и я ходил
программировать в школьный компьютерный кружок, а там было много других желающих.

** JavaScript

Вторым моим языком программирования был ~JScript~ - вариант языка ~JavaScript~ для
броузера ~Internet Explorer~ версии 3.2. На нем я попытался написать, конечно же,
вебстраничку. С тех пор, люди, проклинающие ~Internet Explorer~ 8-ой версии вызывают у
меня только улыбку.

#+CAPTION: IE3
[[img:ie3.png]]

** Delphi

Возможность сохранять файлы из программы появилась, когда я начал использовать
~Delphi~. Ребенок из неполной семьи, живущий в пригороде, не может купить толстое
руководство по ~Delphi~ "в подлиннике", поэтому после учебы я ехал в "Дом
Книги". Дорога занимала полтора часа, в торговом зале стульев не было, но можно было
почитать час-полтора, стоя у стеллажа. А потом ехать домой - пробовать полученные
знания. Продавщицы стали меня узнавали - так я смог прочитать почти две тысячи страниц.

#+CAPTION: То самое руководство
[[img:delphi4.jpg]]

На ~Delphi~ я написал записную книжку - органайзер, который умел предупреждать меня о
днях рождения знакомых и показывала их на календаре. Еще она хранила их телефоны и
делала еще много разных вещей. Я определенно мог гордиться собой..

** Ассемблер x86

..пока не повстречался с одним более старшим коллегой-программистом. Он работал в
конторе, которая делала устройства для рекламы. Он сообщил мне, что ~Delphi~ - это для
детей, а настоящие программисты программируют на Ассемблере. Книжный магазин уже ждал
меня...

[[img:assembler3books.jpg]]

Ассемблер был куда сложнее, но отступать было некуда. Много позже я понял, что коллега,
скорее всего, имел ввиду куда более простой ассемблер для микроконтроллеров PIC, но
тогда я этого не знал, и к счастью: мне пришлось изучить все регистры процессора и
режимы адресации, способы написания резидентных программ под MSDOS, научиться писать в
порты и читать из них чтобы управлять устройствами без драйверов, и даже переводить
процессор в защищенный режим.

На одном из дисков с пиратским софтом мне попались электронные журналы демомейкеров
(интернета пока еще не было). Я смог немного прикоснусться к демо-сцене, реверсингу и
анализу всяческих кряков.

[[img:ezine.png]]

Это было совершенно волшебно. Я писал на ассемблере, си, паскале, делфи, изучал защиты
программ, антиотладочные приемы, и даже не думал, что все это может быть интересно
кому-то еще, кроме меня и загадочных авторов книг и электронных журналов.

Пожалуй самым высоким достижением на этом пути было написание собественной операционной
системы защищенного режима. Она имела загрузчик, размещенный в Master Boot Record
дискеты, который прямым обращением к контроллеру дисковода умел загружать собственно
систему.

После загрузки с дискеты она переходила в защищенный режим, инициализировала GDI и LDI
(глобальную и локальную дескрипторные таблицы, содержащие дескрипторы сегментов) и
таблицу векторов прерываний. С помощью прерываний обрабатывалась мышь, которую можно
было использовать для операций внутри простой оконной подсистемы и запускать
приложения. Приложений было три, все они работали в SVGA-режиме и представляли собой
простые игры: "змейка", "арканоид" и несколько упрощенный "диггер".

* Веб-программирование
** Первый коммерческий проект

..я сделал для фирмы, которая торговала авточехлами и автоинструментом. Увидев, как я
обрабатываю ему фотку в фотошопе, директор конторы спросил, не мог бы я ему сделать
сайт? Почему бы не попробовать? Оказалось, что веб-программирование на динамических
языках было гораздо проще с++ и ассемблера.

Внезапно всем стали нужны сайты. Много людей были готовы дать денег за то, что я бы с
удовольствием делал и бесплатно. Мне просто повезло - на пустом рынке я оказался одним
из немногих опытных специалистов.

Сделав сайт паре фирм, я устроился на работу веб-программистом в веб-студию. Весь код
был в таком ужасном состоянии, что я просто взял и переписал их CMS и быстро стал
тимлидом. Тогда было модно так делать - у каждой конторы была своя CMS. Можно было бы
гордиться собой, но тут я узнал о существовании Лиспа.

* Лисп
** Побеждая посредственность
Я прочитал [[http:www.nestor.minsk.by/sr/2003/07/30710.html][эссе Пола Грэма "Побеждая посредственность"]] и оно произвело на меня
неизгладимое впечатление. Захотелось срочно попробовать Лисп. Я уже считал себя опытным
разработчиком, поэтому, чтобы процесс проходил веселее, решил поменять не только язык
программирования, но и среду разработки и даже операционную систему. Так у меня в
компьютере оказался Линукс, в нем Емакс, а в Емаксе - Лисп. Добро пожаловать обратно в
школу - весь предыдущий опыт больше не работал - я снова не мог написать ни одной
программы.

Впрочем, проведя два месяца и отрастив бороду, я все-таки начал что-то понимать. Я даже
попытался написать свой собственный Лисп для использования в веб-студии, но этот проект
не был оценен по достоинству - у них уже была написанная мной CMS, которая приносила
неплохой доход, и никто не хотел менять ее на нечто совершенно новое, сырое, и
незнакомое. Вся моя работа свелась к поддержке моей CMS, найму программистов и
написанию модулей время от времени. Иногда я приходил в офис 2 раза в месяц - в день
аванса и зарплаты. Естественно долго это продолжаться не могло...

** Лисп в индустрии

Я стал искать компанию, в которой мог бы применить свежеполученные сверхзнания (mad
skillz). И нашел. Это был интернет-магазин, написанный на PHP и довольно плохо
справлявшийся с нагрузкой. Код был плохим. Впереди были новогодние праздники, главная
страница временами открывалась 28 секунд и настроение у боссов было
скверным. Предыдущий кандидат на мое место после первого дня работы тихо исчез, не
оставив контактов.

Я предложил переписать все на Лиспе, а в качестве демонстрации способностей закешировал
самые тяжелые вещи и главная страница стала открываться за 4 секунды. Быстрее было уже
никак, все равно пришлось бы переписывать все, так почему бы и не на Лиспе?

Руководство магазина идею поддержало с оговоркой - деньги за работу будут заплачены
только в том случае, если 90% текущего функционала будут работать и не тормозить. Но
меня уже было не остановить..

** Столкновение с трудностями

Оказалось, что я на самом деле не знал Лисп и что он гораздо сложнее и интереснее чем
мне представлялось на первый взгляд. В процессе разработки мне пришлось узнать довольно
многое - я читал [[file:resources/sicp.pdf][SICP]] и [[file:resources/pcl.pdf][PCL]], а [[file:resources/emacs-man.pdf][руководство пользователя Emacs]], вообще стало настольной
книгой. Это было ужасно сложно, но очень интересно.

Через 2 месяца система в общих чертах была готова, и я получил свои деньги, а
руководство фирмы - результат. Все страницы открывалсись моментально, и даже быстрее
чем у конкурентов. Это было неудивительно, если всмпомнить, что Лисп компилировался
прямо в машинный код, а у PHP четвертой версии не было ничего подобного. Впрочем, там
вообще ничего не было: PHP был [[https:habrahabr.ru/post/179399/][создан умирать]] и хранил все данные в БД.

В новой системе, написанной на Лиспе, почти все данные постоянно были загружены в
памяти процесса и отдавались с молниеносной скоростью, независимо от нагрузки.

Благодаря REPL я видел и исправлял ошибки пользователей прямо в момент их
возникновения. Иногда даже до того, как компоненты страницы окончательно были загружены
в броузер пользователя.

Я обучил еще одного программиста и мы стали работать над проектом вдвоем. Кажется, я
даже ушел в отпуск - очень необычные ощущения.

Я стал самым могущественным веб-программистом, ведь в моих руках было секретное оружие,
о котором никто не знал - Лисп!

** Другие приложения

Я начал думать на Лиспе. Разумеется, мне приходилось делать проекты и на других языках,
но первый прототип делался (а часто и показывался) на Лиспе. Благодаря его гибкости, я
успевал вносить правки в проект прямо во время совещаний - к их концу часто уже все
бывало готово.

Однако я обнаружил, что люди странно реагируют, если им показывать изменения сразу -
один коллега программист однажды даже возмущенно сказал, что "это не должно быть
настолько легко!"

Окей, подумал я, и стал брать "недельку на доработки", ведя одновременно несколько
проектов. Это было несложно - корпоративные порталы, интернет-магазины,
баннерно-рекламные сети шли бесконечной чередой. Это было доходно, но хотелось чего-то
большего - я скучал по настоящей работе.

* Эрланг
** Телекоммуникационные протоколы

Возможность поработать на незнакомом языке представилась довольно скоро и я окунулся в
телефонию и Эрланг. С функциональным программированием я был знаком и раньше, но
впервые у меня появилась возможность делать по-настоящему распределенные системы.

Не все шло гладко - мне опять не хватало знаний и снова мне помог "Дом Книги" (кажется,
ему надо продать спонсорство этой статьи), где я купил "Распределенные системы"
Таненбаума. Наконец-то я больше мог не стоять в магазине, а взять книгу домой.

[[img:distr-sys.png]]

Несмотря на то, что она совсем не про Эрланг, думаю это одна из важнейших книг для
каждого эрланг-разработчика.

Эрланг будил смешанные чувства: в нем были хорошо сделаны сложные для Лиспа вещи
(многопоточность), и ужасно плохо другие (горячая замена кода), которые в Лиспе как раз
хороши.

Эрланг может быть одним из образцов того, как нужно строить инженерию языка - в первую
очередь рантайм. Для того чтобы понять, чем вдохновлялись авторы языка я начал читать
"Взаимодействующие последовательные процессов" Хоара.

[[img:hoar.jpg]]

Кстати, рядом на полке стояла вся серия "Классика Computer Science" и меня
заинтересовала еще одна книжка Таненбаума - "Операционные системы - разработка и
реализация". Ее я тоже купил, просто невозможно было пройти мимо. Наверно именно тогда
зародилась идея о распределенной операционной системе. Вот было бы здорово написать
такое... Но, оказалось, что я - не первый кто об этом задумался.

И действительно, ребята из ~Bell Labs~, выдавшие в свое время ~UNIX~, решили начать с
"чистого листа" и разработали [[https://ru.wikibooks.org/wiki/Plan9][Plan9]]. О котором, кстати, никто не знает, несмотря на то,
что идеи, заложенные в него остаются революционными и сейчас, спустя почти 40 лет.

Создатели ~Plan9~ планировали сделать из своего продукта коммерческую операционную
систему, и исходные тексты долгое время были закрыты. В то время, как ~Linux~ был
полностью открыт и вокруг него формировалось сообщество разработчиков. Вполне
естественно, что бизнес при выборе операционной системы ориентировался на стоимость
поддержки, прямо зависящую от количества компетентных специалистов на рынке. Таким
образом, когда исходные тексты ~Plan9~ были открыты - оказалось уже поздно. Тем не
менее, эта операционная система осталась колодцем, из которого еще очень долго можно
черпать идеи. Некторые из них хорошо подходят к моим задачам, но я понимаю, что эти
идеи никогда не будут так стройно увязаны в одну систему как в ~Plan9~.

Начав изучать ее устройство, я понял, что мы просто живем в каменном веке операционных
систем. Я потратил довольно много времени на исследование и анализ механизмов, которые
так гениально спроектированы в ~Plan9~ и эти знания потом весьма пригодились при
проектировании распределенных систем.

** Трейдинговые системы

Следующий мой проект был связан с торговлей на бирже. Там были очень жесткие требования
по производительности и времени выполнения операций. Я довольно быстро написал прототип
на лиспе и он, после некоторого количества расширений, вполне устраивал начальника. Но,
когда я попробовал испытать его на серьезной нагрузке, скорость оказалась
недостаточной. Причиной являлась модель многопототочности в той реализации Лиспа,
которую я использовал. В ней (в отличии от Эрланга) создание потоков - достаточно
дорогая операция. В фирме уже работало несколько эрланг-программистов, да и я
первоначально нанимался на эту позицию, поэтому вариантов выбора было
немного. "Переходим на Эрланг" - сказал босс, и я понял что переписывание всего кода
(его было уже немало) на Эрланг займет слишком много времени.

Я решил написать кодогенератор, который сделает это за меня. Задача была сложной и
рискованной, но очень интересной. В процессе разработки прототипа у нас
выкристализовался своего рода "язык предметной области", связанной с биржей, поэтому на
самом деле мне пришлось сделать кодогенерацию этого ограниченного подмножества. Я также
старался, чтобы сгенерированный код был не лапшой, в которой тяжело разобраться, а был
достаточно поддерживаемым и идиоматичным, чтобы любой эрланг-программист не отличил бы
его от написанного человеком.

Разработка кодогенератора заняла почти два месяца - главным образом потому, что это для
меня была новая и незнакомая задача. Сегодня я бы справился с этим гораздо
быстрее. Затем мы переехали на Эрланг, наняли еще несколько программистов и далее в
проекте остался только Эрланг и С++.

После успешного опыта с кодогенерацией я заинтересовался тем, как работают
кодогенераторы в известных языках программирования и их компиляторах. Сначала изучал их
исходные тексты, а потом на форуме мне порекомендовали прочесть "[[file:resources/compilers.djvu][Книгу Дракона]]" -
классический учебник по теории построения компиляторов. Это книга, после написания
моего кодогенератора, читалась как захватывающий детектив. Естественно, что я (в
качестве упражнения) тут же переписал мой кодогенератор (несмотря на то, что уже не
работал в этой компании) и он получился гораздо более компактным и выдавал еще более
чистый и понятный код.

[[img:drakon.png]]

* И снова веб-программирование

** Генерация сайтов и ДРАКОН

Я решил, что кодогенерацию вполне можно поставить на коммерческие рельсы и написал
"язык для разработки сайтов", очень похожий на Лисп, который генерировал код на ~PHP~ и
~JavaScript~ (с использованием ~JQuery~) под основные распространенные фреймворки:
~Symphony~, ~Yii~ и даже ~Wordpress~. Хотел освоить еще и ~Bitrix~, но он оказался
настолько ужасен, что лучше даже не портить себе настроение.

Некоторое время я применял и улучшал этот язык для выполнения множества проектов, но я
обнаружил, что почти никто, кроме меня не хочет им пользоваться, несмотря на простоту и
"заточенность" под типовые задачи. Программистов отпугивал непривычный синтаксис Лиспа,
а пользователи-непрограммисты предпочитали рисовать картинки, отдаленно напоминавшие
блок-схемы, а потом отдавать их мне, чтобы я запрограммировал логику.

Что-то тут было не так. Я стал задумываться об инструменте "визуального
программирования", который можно было бы отдать пользователю, чтобы он сам мог создать
алгоритм. Идея была рискованная, множество инструментов в прошлом заявляли такие
возможности, но выжили немногие - из успешных примеров на тот момент можно было назвать
только ~LabVIEW~.

Мне хотелось дать возможность пользователям создавать блок-схемы для решения своих
задач, а мой генератор по ним мог бы создать код и вставить его в типовой фреймворк,
вроде ~Yii~. И я нашел подходящий инструмент для этой цели - [[https://ru.wikipedia.org/wiki/%D0%94%D0%A0%D0%90%D0%9A%D0%9E%D0%9D][ДРАКОН]]. Он представляет
собой визуальный язык для создания блок-схем, достаточно формализованный, чтобы была
возможность кодогенерации из таких схем. И достаточно понятный, чтобы быстро научить
даже непрограммиста, знакомого только с понятием алгоритма.

Вот так ~ДРАКОН-схема~ выглядит (картинка с одного из сайтов, посвященных языку)

[[file:img/drakon-svn-ds.png]]

Для ~ДРАКОН-а~ существует несколько редакторов таких схем. Я выбрал кроссплатформенный,
который называется [[http://drakon-editor.sourceforge.net/][DRAKON Editor]]. И в нем уже есть кодогенерация, для нескольких
языков:
- C и C++ (включая расширения языка из фреймворка Qt)
- Java (а также её подмножество для компьютерной графики — Processing.org)
- C#
- Python (версии 2.х и 3.х)
- Tcl
- JavaScript
- Erlang
- Lua

Я подумал, что будет не очень сложно добавить кодогенерацию и для моего лисп-подобного
языка разработки веб-сайтов. Оказалось, ~Drakon Editor~ написан на ~Tcl~. Еще один
новый язык, и он даже поддерживает метапрограммирование? Это интересно!

** TODO Tcl

Продолжение следует...

[[img:tcl-tk.jpg]]

** TODO SICP и моделирование электроники

[[img:sicp.jpg]]

** TODO Робототехника и Forth
