#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Обо мне

* Краткая биография

Меня зовут Глухов Михаил, мой ник ~rigidus~ - его проще нагуглить. Я занимаюсь
программированием и исследованиями в смежных областях. В свободное время конструирую
роботов и программирую их.

Мне можно в любой момент позвонить по телефону ~8(911)286-92-90~ или написать на
~i.am.rigidus at gmail dot com~

Еще я постоянный участник (и иногда - докладчик) семинаров по функциональному
программированию в Санкт-Петербурге [[https://plus.google.com/communities/106931692847918217517][fprog-community]] и [[http://piter-united.ru][IT-Global-Meetup]]

Дальше будет моя би(бли)ография. Она почти целиком состоит из ссылок на те книги,
которые меня сформировали как программиста.

* Первые шаги
** Basic

Я стал программмировать в классе, если я не ошибаюсь, седьмом, мне было 12-13 лет. С
тех пор я занимаюсь этим практически без перерывов - даже в отпуске и путешествиях со
мной всегда ноутбук и если иногда и случаются дни без кода - это довольно редкое
явление.

Первый язык программирования - бейсик для компьютера ~Sinclair48k~. Вот эта машинка:

[[img:ZXSpectrum48k.jpg]]

Этот компьютер обладал оперативной памятью в 48 килобайт, а жесткого диска у него
вообще не было. Программы грузились с кассетного магнитофона, который давал сбои из-за
скачков напряжения в сети (почти постоянно). Поэтому приходилось набирать программы
заново и держать компьютер выключенным. Это было божественно прекрасно, ведь недавно у
меня вообще не было компьютера - я ходил программировать в школьный компьютерный
кружок, а там было слишком много других желающих.

** JavaScript

Вторым изученным языком программирования был ~JScript~ - вариант языка ~JavaScript~ для
броузера ~Internet Explorer~ версии 3.2. С тех пор, люди, проклинающие ~Internet
Explorer~ 8-ой версии вызывают только улыбку :)

Мне было 14 лет и у меня появился компьютер с ~Windows95~. В нем был ~Internet
Explorer~, который выглядел так:

[[img:ie3.png]]

Википедии, кстати, тогда тоже еще не было (чего не скажешь по скриншоту).

На ~JScript~ были написаны несколько веб-страничек. Сложно сказать, зачем я это делал,
ведь интернет, даже диалапный появился у меня гораздо позже. Наверное, просто хотелось
программировать, а ~JScript~ был доступен без установки компилятора, который было
неизвестно где брать и как ставить. Среда программирования была очень бедной -
единственный способ для программы сохранить какое-то данные - это записать их в
cookies.

** Delphi

Возможность работать с файловой системой из программы (читать и сохранять файлы)
появилась, когда я начал использовать ~Delphi~.

Тогда я не мог себе позволить толстое руководство по ~Delphi~ "в подлиннике", поэтому
после учебы я ехал в "Дом Книги". Дорога занимала полтора часа, в торговом зале стульев
не было, но можно было почитать час-полтора, стоя у стеллажа. А потом ехать домой -
пробовать полученные знания. Продавщицы стали меня узнавать - так я смог прочитать
почти две тысячи страниц.

[[img:delphi4.jpg]]

На ~Delphi~ я написал записную книжку - органайзер, который умел предупреждать меня о
днях рождения знакомых и показывала их на календаре. Еще она хранила их телефоны и
делала еще много разных вещей. Я определенно мог гордиться собой..

** Ассемблер x86

..пока не повстречался с одним другим программистом (на тот момент встретить другого
програмиста было довольно редким событием). Он был старше меня и работал в конторе,
которая делала устройства для световой рекламы на микроконтроллерах. Он сообщил мне,
что ~Delphi~ - это для детей, а настоящие программисты программируют на
Ассемблере. Книжный магазин уже ждал меня...

[[img:assembler3books.jpg]]

Ассемблер был куда сложнее, но отступать было некуда. Много позже я понял, что коллега,
скорее всего, имел ввиду куда более простой ассемблер для микроконтроллеров PIC, но
тогда я этого не знал, и, наверно, к счастью: мне пришлось изучить регистры процессора
и режимы адресации, способы написания резидентных программ под MS-DOS, научиться писать
в порты и читать из них, чтобы управлять устройствами без драйверов, и даже переводить
процессор в защищенный режим.

На одном из дисков с пиратским софтом мне попались электронные журналы демомейкеров
(интернета пока еще не было). Я смог немного прикоснусться к демо-сцене, реверсингу и
анализу всяческих кряков.

[[img:ezine.png]]

Это было совершенно волшебно. Я писал на ассемблере, изучал защиты программ,
антиотладочные приемы, и даже не думал, что все это может быть интересно кому-то еще,
кроме меня и загадочных авторов книг и электронных журналов.

Пожалуй самым высоким достижением на этом пути было написание операционной системы
защищенного режима. Она имела загрузчик, размещенный в Master Boot Record дискеты,
который прямым обращением к контроллеру дисковода умел загружать собственно
операционную систему.

После загрузки с дискеты она переходила в защищенный режим, инициализировала GDI и LDI
(глобальную и локальную дескрипторные таблицы, содержащие дескрипторы сегментов памяти)
и таблицу векторов прерываний. С помощью прерываний обрабатывалась мышь, которую можно
было использовать для операций внутри простой оконной подсистемы и запускать
приложения. Приложений было три, все они работали в SVGA-режиме и представляли собой
простые игры: "змейка", "арканоид" и несколько упрощенный "диггер".

Все это занимало меня в 16-17 лет, и это было весьма интересно.

** C/C++

[[img:cman.jpg]]

После практики программирования на ассемблере, язык Си, который я изучал по
классическому руководству Кернигана и Ритчи, казался простым и понятным. Работа с
указателями, построение сложных структур данных и алгоритмов стали гораздо проще
записываться и быстрее читаться. Было довольно приятно посвятить некоторое время работе
с этим языком.

[[img:cppman.jpg]]

Начав, через некоторое время изучать С++, я обнаружил, что это совсем другой язык, с
другой идеологией и практикой применения. Я уже был "знаком с ООП" на примере ~Delphi~
(как я тогда думал), и даже ухитрялся реализовывать его в ассемблерных программах, в
качестве развлечения.

Было очень интересно, как именно отсутствующие в языке Си вещи, реализованы в C++:
исключения, таблицы виртуальных функций, порядок вызова деструкторов и тому подобные
вещи занимали все мои мысли. С++ казался очень мощным и довольно непростым и требовал
все больше времени на его изучение. Я легко мог себе это позволить - я был школьником,
а после - студентом, посвящавшим все свободное время программированию. Тем не менее,
С++ оказался таким объемным, что никто не мог его "знать" - можно было узнавать все
больше деталей о том как работает тот или иной механизм языка, но никак не получалось
охватить их все.

** Java

Мир Java ошеломил легкостью программирования в отсутствии ручного управления памятью и
большого количества неопределенного поведения. Однако сложность, которая в С++ была
частью использования языка, переместилась в библиотеки и проектирование
архитектуры. Первое время это, конечно, можно было не замечать.

[[img:javaman.jpg]]

В попытке помочь нескольким open source проектам, оказалось, что самая выматывающая
часть - интеграция различных модулей и подсистем. Библиотеки обещали богатство
функционала из коробки, но за этот функционал приходилось платить утомительными
попытками подружить их между собой. Такой "суровый ынтэрпрайз" отбивал желание
программировать и я стал задумываться о том, что что-то делаю неправильно. Хотелось
делать больше, меньше печатая на клавиатуре - и я заинтересовался динамическими
языками. Тем более, что знакомый гендир попросил сделать сайт, предлагая за эту работу
небольшие деньги.

* Веб-программирование
** Первый коммерческий веб-проект

..был сделан для фирмы, которая торговала авточехлами и автоинструментом. Чтобы отойти
от Java и изучить что-то новое, я взялся делать его на PHP и JavaScript. Все получилось
неожиданно быстро и было гораздо проще чем я привык. Сайт быстро превратился в
интернет-магазин, пошли заказы, директор был доволен и я сделал три версии этого
магазина.

Бум доткомов докатился до нас - внезапно всем стали нужны сайты. Много людей были
готовы дать денег за то, что было бы весело делать и бесплатно. Просто везение - на
пустом рынке я оказался одним из немногих более или менее опытных специалистов.

Сделав еще несколько сайтов в качестве фрилансера, я устроился на работу
веб-программистом в веб-студию. Их код был не очень хорош, так что я просто взял и
переписал их CMS-движок, используя свои наработки, и быстро стал тимлидом. Тогда было
модно так делать - у каждой конторы была своя CMS. Наша разрабатывалась под
"Денвером" - сборкой Apache и MySQL для Windows, а потом заливалась через FTP на
сервера под управлением FreeBSD.

Я учился на первом курсе и у меня была неплохая, хорошо оплачиваемая работа. Можно было
бы гордиться собой, но тут я натолкнулся на [[http://www.sql.ru/forum/466654-1/s][топик]], в котором, предположительно,
[[http://lurkmore.to/%D0%9B%D1%83%D0%B3%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9][Луговоский]], в присущей ему, прямо таки технофашисткой манере, сообщал всем, что "C++ -
довольно таки примитивное, но монстровое поделие, полное исторически сложившихся
нелепых нагромождений". Излишне говорить, какую ярость вызвало такое такое заявление,
однако в последующем бурном обсуждении он рационально и аргументированно защитил эту
позицию, предлагая вместо этого испробовать Forth, Haskell, Erlang и вершину языков
программирования (по его мнению) - Lisp.


* Лисп
** Побеждая посредственность

Это задевало. С++, которым я так восхищался, и на который ушло несколько лет изучения,
кажется действительно был таким - я просто не хотел в это верить. И совершал то, что
называется [[http://brights-russia.org/article/the-sunk-cost-fallacy.html][ошибкой невозвратных затрат]]. Луговский рекомендовал прочесть эссе Пола Грэма
[[http:www.nestor.minsk.by/sr/2003/07/30710.html]["Побеждая посредственность"]], которое окончательно убедило меня, что надо изучить Lisp.

Я считал себя "опытным разработчиком" (напрасно), поэтому, чтобы процесс проходил
веселее, решил изучить не только язык программирования, но и новую среду разработки и
даже операционную систему. Так в моем компьютере поселился linux, emacs, и Common Lisp.

Добро пожаловать обратно в школу - весь предыдущий опыт больше не работал - я снова не
мог написать ни одной программы.

Впрочем, через пару месяцев, я все-таки начал что-то понимать. То, о чем говорил
Луговский оказалось правдой и выглядело это как-то так:

[[img:some-smart-books.jpg]]

Было интересно попробовать использовать все что я узнал на работе, но этот проект не
был оценен по достоинству - у них уже была написанная мной CMS, которая приносила
неплохой доход, и никто не хотел менять ее на нечто совершенно новое, сырое, и
незнакомое.

Вся работа свелась к поддержке моей CMS, найму программистов и написанию модулей время
от времени. Я стал искать карьерные перспективы. С собеседованиями было сложно - я
выглядел слишком молодо для программиста с опытом. Пришлось отрастить бороду, и стереть
из резюме упоминания о ассемблере, С++ и возрасте - и тогда дело пошло.

** Лисп в индустрии

Я стал искать компанию, в которой мог бы применить свежеполученные mad skillz. И
нашел. Это был интернет-магазин, написанный на PHP и довольно плохо справлявшийся с
нагрузкой. Код был плохим. Впереди были новогодние праздники, главная страница
временами открывалась 28 секунд и настроение у боссов было скверным. Предыдущий
кандидат на мое место после первого дня работы тихо исчез, не оставив контактов.

Я предложил переписать все на лиспе, а пока, для демонстрации, закешировал самые
тяжелые вещи и главная страница стала открываться за 4 секунды. Быстрее было уже никак,
все равно пришлось бы переписывать все, так почему бы и нет?

Руководство магазина идею поддержало с оговоркой - деньги за работу будут заплачены
только в том случае, если 90% текущего функционала будут работать и не тормозить. Но
меня уже было не остановить..

** Столкновение с трудностями

Оказалось, что я на самом деле не знал Лисп и что он гораздо сложнее чем мне
представлялось на первый взгляд. В процессе разработки я читал [[file:/resources/sicp.pdf][SICP]] и [[file:/resources/pcl.pdf][PCL]] а
[[file:/resources/emacs-man.pdf][руководство пользователя Emacs]], вообще стало настольной книгой.

[[img:pcl.jpg]]

Через два месяца система в общих чертах была готова, я получил свои деньги, а
руководство фирмы - результат. Всё открывалось моментально, и быстрее чем у
конкурентов. Это было неудивительно, если вспомнить, что используемая реализация Лиспа
компилировалась прямо в машинный код, а у PHP четвертой версии не было ничего
подобного. Впрочем, там вообще ничего не было: PHP был [[https:habrahabr.ru/post/179399/][создан умирать]] и хранил все
данные в БД.

В новой системе почти все необходимые данные постоянно были загружены в памяти процесса
и отдавались с молниеносной скоростью, независимо от нагрузки.

Благодаря REPL можно было видеть и исправлять ошибки пользователей прямо в момент их
возникновения.

Я обучил еще одного программиста и мы стали работать над проектом вдвоем. Кажется, я
даже ушел в отпуск - очень необычные ощущения.

** Другие приложения и немного C#

Я начал думать на Лиспе. Разумеется, мне приходилось делать проекты и на других языках
(где-то в это время я впервые познакомился с C#), но первый прототип делался (а часто и
показывался) на Лиспе. Благодаря его гибкости, я успевал вносить правки в проект прямо
во время совещаний - к их концу часто уже все бывало готово.

Однако я обнаружил, что люди странно реагируют, если им показывать изменения сразу -
один коллега однажды даже возмущенно сказал, что "это не должно быть настолько легко!"

Окей, подумал я, и стал брать "недельку на доработки", ведя одновременно несколько
проектов. Это было несложно - корпоративные порталы, интернет-магазины,
баннерно-рекламные сети шли бесконечной чередой. Это было доходно, но хотелось чего-то
большего - я скучал по настоящей работе и самоотверженному изучению чего-то нового,
еще более мощного... О чем там говорил Луговский еще?

* Эрланг
** Телекоммуникации

Возможность поработать на незнакомом языке представилась довольно скоро и я окунулся в
Эрланг. С функциональным программированием я был знаком и раньше, но впервые у меня
появилась необходимость делать по-настоящему распределенные системы.  Не все шло
гладко - мне опять не хватало знаний и снова мне помог "Дом Книги" (кажется, ему надо
продать спонсорство этой статьи), где я купил "Распределенные системы"
Таненбаума. Можно было не стоять в магазине, а взять книгу домой.

[[img:distr-sys.png]]

Несмотря на то, что она совсем не про Эрланг, это одна из важнейших книг для
разработчика. Для того чтобы понять, чем вдохновлялись авторы языка я начал читать
"Взаимодействующие последовательные процессы" Хоара.

[[img:hoar.jpg]]

Все же, надо признать, это была джуниорская работа эрлангистом, но это ничуть не
смущало. Я верил, что полученные знания не станут бесполезными - так оно и оказалось.

** Трейдинговые системы

Следующий проект был связан с торговлей на бирже. Там были жесткие требования по
производительности и времени выполнения операций. Я довольно долго писал прототип на
лиспе и он, после некоторого количества расширений, вполне устраивал начальника. Но, на
серьезной нагрузке, скорость оказалась недостаточной. Потоки в используемой реализации
Лиспа были дорогими. Написать быструю многопоточность я бы (тогда) не смог, возникла
идея написать транслятор кода из лиспа в Эрланг. Это было необычно, интересно и было
успешно проделано. Сгенерированный код был достаточно хорош, чтобы средний
эрланг-программист мог его поддерживать.

После разработки транслятора мы переехали на Эрланг, наняли еще несколько программистов
и далее в проекте остался только Эрланг и немного С++.

Я заинтересовался тем, как работают компиляторы языков программирования, изучал их
исходные тексты, и читал "[[file:/resources/compilers.djvu][Книгу Дракона]]" - классический учебник по теории построения
компиляторов. Эта книга после опыта с кодогенерацией читалась как захватывающий
детектив.

[[img:drakon.png]]

* ДРАКОН

Я решил, что кодогенерацию вполне можно поставить на коммерческие рельсы и написал
"язык для разработки сайтов", очень похожий на Лисп, который генерировал код на ~PHP~ и
~JavaScript~ (с использованием ~JQuery~) под появившиеся к этому времени фреймворки:
~Symphony~, ~Yii~ и даже ~Wordpress~.

Эту разработку я попытался "продать" веб-студии, в которой работал, но обнаружил, что
почти никто, кроме меня, не хочет ей пользоваться. Программисты не хотели учить "еще
один язык", а непрограммисты предпочитали рисовать картинки, отдаленно напоминавшие
блок-схемы, а потом отдавать их программистам, чтобы те запрограммировали логику.

Блок-схемы - это ведь тоже своего рода "язык программирования", решил я и нашел
подходящий инструмент для них - [[https://ru.wikipedia.org/wiki/%D0%94%D0%A0%D0%90%D0%9A%D0%9E%D0%9D][ДРАКОН]]. Он представляет собой визуальный язык для
создания блок-схем, достаточно формализованный, чтобы была возможность кодогенерации
императивных алгоритмов из таких схем. И достаточно понятный, чтобы за час научить даже
непрограммиста, знакомого только с понятием алгоритма.

Вот так ~ДРАКОН-схема~ выглядит (картинка с одного из сайтов, посвященных языку, сам я,
конечно же стараюсь использовать ~git~ для управления кодом)

[[img:drakon-svn-ds.png]]

Я применил такие схемы для формализации технических заданий, пока работал в фирме,
продающей авиа и железнодорожные билеты. Там было сложное взаимодействие между системам
бронирования и клиентской платформой.

Для ~ДРАКОН-а~ существует несколько редакторов таких схем. Я выбрал кроссплатформенный,
который называется [[http://drakon-editor.sourceforge.net/][DRAKON Editor]]. И в нем уже есть кодогенерация, для C и C++, Java,
C#, Python, Tcl, JavaScript, Erlang и Lua.

Я подумал, что будет не очень сложно добавить кодогенерацию и для моего языка
разработки веб-сайтов. Оказалось, ~Drakon Editor~ написан на ~Tcl~, поэтому появляется
возможность выучить еще один язык. Почему бы и нет?

* Tcl

Так что я приступил к изучению ~Tcl~ и ~Tk~. В этом мне помогла замечательная книга:

[[img:tcl-tk.jpg]]

Язык оказался очень интересным и необычным, с поддержкой метапрограммирования, и очень
понравился возможностью еще раз посмотреть на программирование под другим углом. На нем
удобно и быстро прототипировать GUI (кроссплатформенно). Поэтому его широко используют
в пакетах разработки микрочипов. Конечно, было интересно, как именно...

В общем я увлекся и это закономерным образом привело меня к задачам моделирования
цифровых электрических цепей.

* Электроника
** Моделирование цифровых схем

Первоначальное введение в цифровую схемотехнику я нашел в [[file:/resources/sicp.pdf][SICP]], где рассказывалось, как
языковыми средствами построить язык предметной области (DSL), на котором можно написать
программу, ведущую себя в точности как модель электронной схемы.

[[img:sicp.jpg]]

Такой подход позволяет использовать технологии программмирования для построения
электроники. Выглядит очень необычно, и захватывающе. Так что я решил перечитать [[file:/resources/sicp.pdf][SICP]],
чтобы превратить его из учебного примера в что-то рабочее.

[[img:semiadder.png]]

В процессе этой работы оказалось, что электронные схемы - это не всегда абстракция,
поэтому пришлось взяться сначала за физику, а потом и за схемотехнику всерьез:

[[img:horovits_hill.jpg]]

Книжка оказалась очень емкой, поэтому я возвращаюсь к ней по мере возникновения
трудностей. Постепенно электроника становилась интересным хобби: для проверки всех этих
идей пришлось научиться разводить и травить платы, программировать микроконтроллеры - и
тут очень удачно пригодился ассемблер и Си. Я начал с изготовления самодельных
устройств для "умного дома", но хотелось чего-то большего.

** Робототехника и Forth

Я устроился в фирму, где смог найти применение этим навыкам. Однажды нам передали в
разработку устройство, прошивка которого была по-настоящему интересной. При скромных
аппаратных требованиях устройство удивляло своей могучей функциональностью. Требовалось
извлечь из него программу, разобраться в ее работе, и добавить возможность
беспроводного управления.

После извлечения прошивки, оказалось, что устройство не запрограммировано на Си, как
большинство других. Вместо этого в нем сидит виртуальная машина, написанная на
ассемблере и эта виртуальная машина содержит в себе реализацию неизвестного мне ранее
языка программирования Forth. Десять лет назад об этом языке тоже упоминал Луговский,
рекомендуя его для изучения

Forth произвел впечатление своей компактностью и мощностью, поэтому я стал изучать
~Forth~ в свободное время. По нему не очень много руководств, но некоторые из них
весьма хороши.

[[img:thinking-forth.jpg]]

Виртуальная машина ~Forth~ и ее, хм.. "байткод" обладает очень важным свойством - по
байткоду может быть однозначно восстановлен исходный текст программы. Поэтому после
того, как архитекура ~ForthVM~ стала понятна (и я научился программировать на этом
языке) я смог провести полный реверс-инжиниринг прошивки и даже воссоздать его работу
на более современной элементной базе - пришлось портировать только низкоуровневую
~ForthVM~.

Через полгода изучения, опираясь на несколько прочитанных руководств, я написал свою
реализацию этого языка (она опубликована на этом сайте). Эта реализация может служить
своего рода "портабельным слоем" для других языков, которые можно реализовать поверх
нее, так же как например Closure реализована поверх JVM

Я использую эту реализацию не только в исследовательских целях - на ней сделано
несколько устройств "умный дом" - сигнализация, управление светом, электронные
замки. При этом уровень виртуальной машины полностью портируемый - можно разрабатывать
программы для устройств, не нуждаясь в стенде до стадии окончательных испытаний.

* Реализация других языков

Чтобы изучить создание языков программирования "на практике", я взялся реализовывать
лисп (как наиболее сложный из известных мне языков) на форте (для лучшей переносимости
и просто потому что это хороший и мощный язык). В ходе этого проекта будет реализован
диалект, с несколькими отличиями (имхо - в лучшую сторону) от известных мне реализаций,
таких как Common Lisp.

Я занимаюсь этим в свободное время, рассчитывая, что подобная практика даст навыки,
которые пригодятся при реализации многих других языков.

Кроме того, думаю, пора уже браться за Haskell или Ocaml.
