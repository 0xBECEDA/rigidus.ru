#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света в
туалете/ванной комнате, предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State = digitalRead(btn_1);

      if (State) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь мы добавляем задержку.

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn-released= (по-умолчанию - =true=)

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_released) {
          btn_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_released) {
          Serial.println("btn_released");
          delay(100);
          btn_released = true;
          <<on_btn_release>>
      }
      <<btn_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state=. Если мы "включаемся", то должны установить задержку =duration=, а если мы
"выключаемся, то задержку можно просто явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state) {
      Serial.println("switch off, state = LOW");
      state = LOW;
      duration = 0;
  } else {
      Serial.println("switch on, state = HIGH");
      state = HIGH;
      duration = period;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period=:

#+NAME: vars
#+BEGIN_SRC c
  const long period = 4000;
#+END_SRC

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, возможно переполнение! На нашей платформе unsigned long - это четырехбайтовое
значение, которое будет переполняться каждые 49.7102696181 дней, если отсчитывать с
момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (почти 50 дней), потому что дальнейшие действия внутри условия
(last_time>=interval) не будут выполнены.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, переполнив и его. А следующая проверка отработает штатно, т.к. переполнения
уже не будет. Ошибка увеличения задержки на этой операции не будет превышать одного
=interval=-а, что вполне приемлимо для задач задержки выключения света.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration= значение =interval= пока
=duration= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration - interval;
  if ( decremented < 0 ) {
      state = LOW;
      Serial.println("millis() >= duration (is over);\n state = LOW;");
  } else {
      duration = decremented;
      Serial.print("duration = ");
      Serial.println(decremented);
  }
#+END_SRC


Я помещаю логику задержки =check_duration= внутрь блока =btn_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch = LOW;
  boolean latch = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch = state;
  if ( latch != prev_latch ) {
      prev_latch = latch;
      digitalWrite(relay_1, latch);
      Serial.print("=> "); Serial.println(latch);
  }
#+END_SRC

*** Final template

Теперь осталось поместить это в шаблон скетча:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1         = 8;
  const int relay_1       = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC
* Implementation

После успешной отладке на прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
Attiny13 в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (InterSchematic
Programmer) для нашей Attiny13. Для этого нужно загрузить в нее скетч ArduinoISP, он
находится в меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется
сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyUSB0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я заливал
программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами на стадии прототипа код. В нем удален
отладочный вывод и переназначены выводы

#+BEGIN_SRC c
  const int btn_1         = 3;
  const int relay_1       = 4;
  boolean btn_released = true;
  boolean state = LOW;
  long duration = 0;
  const long period = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch = LOW;
  boolean latch = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_released) {
              btn_released = false;
              delay(100);
              if (HIGH == state) {
                  state = LOW;
                  duration = 0;
              } else {
                  state = HIGH;
                  duration = period;
              }
          }

      } else {
          if (!btn_released) {
              delay(100);
              btn_released = true;
          }
          if (state == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration - interval;
                      if ( decremented < 0 ) {
                          state = LOW;
                      } else {
                          duration = decremented;
                      }
                  }
              }
          }
      }
      latch = state;
      if ( latch != prev_latch ) {
          prev_latch = latch;
          digitalWrite(relay_1, latch);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Однако все работает:

[TODO:gmm] - video
