#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света в
туалете/ванной комнате, предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State = digitalRead(btn_1);

      if (State) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь мы добавляем задержку.

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn-released= (по-умолчанию - =true=)

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_released) {
          btn_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_released) {
          Serial.println("btn_released");
          delay(100);
          btn_released = true;
          <<on_btn_release>>
      }
      <<btn_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state=. Если мы "включаемся", то должны установить задержку =duration=, а если мы
"выключаемся, то задержку можно просто явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state) {
      Serial.println("switch off, state = LOW");
      state = LOW;
      duration = 0;
  } else {
      Serial.println("switch on, state = HIGH");
      state = HIGH;
      duration = period;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period=:

#+NAME: vars
#+BEGIN_SRC c
  const long period = 4000;
#+END_SRC

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, возможно переполнение! На нашей платформе unsigned long - это четырехбайтовое
значение, которое будет переполняться каждые 49.7102696181 дней, если отсчитывать с
момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (почти 50 дней), потому что дальнейшие действия внутри условия
(last_time>=interval) не будут выполнены.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, переполнив и его. А следующая проверка отработает штатно, т.к. переполнения
уже не будет. Ошибка увеличения задержки на этой операции не будет превышать одного
=interval=-а, что вполне приемлимо для задач задержки выключения света.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration= значение =interval= пока
=duration= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration - interval;
  if ( decremented < 0 ) {
      state = LOW;
      Serial.println("millis() >= duration (is over);\n state = LOW;");
  } else {
      duration = decremented;
      Serial.print("duration = ");
      Serial.println(decremented);
  }
#+END_SRC


Я помещаю логику задержки =check_duration= внутрь блока =btn_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch = LOW;
  boolean latch = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch = state;
  if ( latch != prev_latch ) {
      prev_latch = latch;
      digitalWrite(relay_1, latch);
      Serial.print("=> "); Serial.println(latch);
  }
#+END_SRC

*** Final template

Теперь осталось поместить это в шаблон скетча:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1         = 8;
  const int relay_1       = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC
* Upload to Attiny13

После успешной отладке на прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
Attiny13 в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (InterSchematic
Programmer) для нашей Attiny13. Для этого нужно загрузить в нее скетч ArduinoISP, он
находится в меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется
сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyUSB0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я заливал
программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами на стадии прототипа код. В нем удален
отладочный вывод и переназначены выводы

#+BEGIN_SRC c
  const int btn_1         = 3;
  const int relay_1       = 4;
  boolean btn_released = true;
  boolean state = LOW;
  long duration = 0;
  const long period = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch = LOW;
  boolean latch = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_released) {
              btn_released = false;
              delay(100);
              if (HIGH == state) {
                  state = LOW;
                  duration = 0;
              } else {
                  state = HIGH;
                  duration = period;
              }
          }

      } else {
          if (!btn_released) {
              delay(100);
              btn_released = true;
          }
          if (state == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration - interval;
                      if ( decremented < 0 ) {
                          state = LOW;
                      } else {
                          duration = decremented;
                      }
                  }
              }
          }
      }
      latch = state;
      if ( latch != prev_latch ) {
          prev_latch = latch;
          digitalWrite(relay_1, latch);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Однако все работает:

[TODO:gmm] - video

** C-level

Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять
тремя выключателями с задержкой, а не одним. Мы можем отказаться от Arduino Core и
спуститься на уровень ниже, запрограммировав микроконтроллер на языке Си, в который в
конечном итоге и превращается скетч.

Чтобы посмотреть, что конкретно делает Arduino IDE, когда компилирует и заливает
программу в микроконтроллер, установим в File -> Preferences галочки "Show verbose
output during compilation & upload"

Теперь мы можем получить довольно много информации о том, что происходит "под
капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через =Makefile=

#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = /home/${USER}/repo/rigidus.ru/org/prj/
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = delay_switch2
  MCU = attiny13
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  $(PROGRAM).elf: $(PROGRAM).o
      $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  $(PROGRAM).hex: $(PROGRAM).elf
      $(Q)$(OBJCOPY) -O ihex $< $@

  %.o: %.c
      $(Q)$(CC) $(CFLAGS) -o $@ -c $<

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

  clean:
      $(Q)rm -f $(OBJS)
      $(Q)rm -f *.elf
      $(Q)rm -f *.hex

  disasm:
      avr-objdump -dS $(PROGRAM).elf > $(PROGRAM).asm

#+END_SRC

Теперь будем менять код

#+BEGIN_SRC c :tangle delay_switch2.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0
  #define btn_1 PB3
  #define relay_1 PB4

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }


  int btn_released = true;
  boolean state = LOW;
  long duration = 0;
  const long period = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch = LOW;
  boolean latch = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif


      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          // Чтение состояния(лог. 1) на порту ввода - вывода (3 вывод порта B):
          if(PINB & (1 << PINB3)) // if (digitalRead(3) == HIGH)
          {
              if (btn_released) {
                  btn_released = false;
                  delay(100);
                  if (HIGH == state) {
                      state = LOW;
                      duration = 0;
                  } else {
                      state = HIGH;
                      duration = period;
                  }
              }
          } else {
              if (!btn_released) {
                  delay(100);
                  btn_released = true;
              }
              if (state == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration - interval;
                          if ( decremented < 0 ) {
                              state = LOW;
                          } else {
                              duration = decremented;
                          }
                      }
                  }
              }
          }
          latch = state;
          if ( latch != prev_latch ) {
              prev_latch = latch;
              if (latch) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }
      }
  }

#+END_SRC



#+NAME: log
#+BEGIN_SRC sh
  /home/rigidus/build/arduino-1.8.9/arduino-builder -dump-prefs -logger=machine -hardware /home/rigidus/build/arduino-1.8.9/hardware -hardware /home/rigidus/Arduino/hardware -tools /home/rigidus/build/arduino-1.8.9/tools-builder -tools /home/rigidus/build/arduino-1.8.9/hardware/tools/avr -built-in-libraries /home/rigidus/build/arduino-1.8.9/libraries -libraries /home/rigidus/Arduino/libraries -fqbn=attiny13:avr:attiny13:freq=f1200000 -vid-pid=0403_6001 -ide-version=10809 -build-path /tmp/arduino_build_255240 -warnings=none -build-cache /tmp/arduino_cache_822171 -prefs=build.warn_data_percentage=75 -verbose /home/rigidus/Arduino/delay_switch/delay_switch.ino

  /home/rigidus/build/arduino-1.8.9/arduino-builder -compile -logger=machine -hardware /home/rigidus/build/arduino-1.8.9/hardware -hardware /home/rigidus/Arduino/hardware -tools /home/rigidus/build/arduino-1.8.9/tools-builder -tools /home/rigidus/build/arduino-1.8.9/hardware/tools/avr -built-in-libraries /home/rigidus/build/arduino-1.8.9/libraries -libraries /home/rigidus/Arduino/libraries -fqbn=attiny13:avr:attiny13:freq=f1200000 -vid-pid=0403_6001 -ide-version=10809 -build-path /tmp/arduino_build_255240 -warnings=none -build-cache /tmp/arduino_cache_822171 -prefs=build.warn_data_percentage=75 -verbose /home/rigidus/Arduino/delay_switch/delay_switch.ino

  Using board 'attiny13' from platform in folder: /home/rigidus/Arduino/hardware/attiny13/avr
  Using core 'core13' from platform in folder: /home/rigidus/Arduino/hardware/attiny13/avr
  Detecting libraries used...

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-g++ -c -g -Os -w -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -w -x c++ -E -CC -mmcu=attiny13 -DF_CPU=1200000L -DARDUINO=10809 -DARDUINO_AVR_ATTINY13 -DARDUINO_ARCH_AVR -I/home/rigidus/Arduino/hardware/attiny13/avr/cores/core13 /tmp/arduino_build_255240/sketch/delay_switch.ino.cpp -o /dev/null

  Generating function prototypes...

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-g++ -c -g -Os -w -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -w -x c++ -E -CC -mmcu=attiny13 -DF_CPU=1200000L -DARDUINO=10809 -DARDUINO_AVR_ATTINY13 -DARDUINO_ARCH_AVR -I/home/rigidus/Arduino/hardware/attiny13/avr/cores/core13 /tmp/arduino_build_255240/sketch/delay_switch.ino.cpp -o /tmp/arduino_build_255240/preproc/ctags_target_for_gcc_minus_e.cpp

  /home/rigidus/build/arduino-1.8.9/tools-builder/ctags/5.8-arduino11/ctags -u --language-force=c++ -f - --c++-kinds=svpf --fields=KSTtzns --line-directives /tmp/arduino_build_255240/preproc/ctags_target_for_gcc_minus_e.cpp

  Compiling sketch...

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-g++ -c -g -Os -w -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -MMD -mmcu=attiny13 -DF_CPU=1200000L -DARDUINO=10809 -DARDUINO_AVR_ATTINY13 -DARDUINO_ARCH_AVR -I/home/rigidus/Arduino/hardware/attiny13/avr/cores/core13 /tmp/arduino_build_255240/sketch/delay_switch.ino.cpp -o /tmp/arduino_build_255240/sketch/delay_switch.ino.cpp.o

  Compiling libraries...

  Compiling core...

  Using precompiled core: /tmp/arduino_cache_822171/core/core_attiny13_avr_attiny13_freq_f1200000_c5d2763094ad9de4fb9ce2df1d92eb6e.a

  Linking everything together...

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-gcc -w -Os -Wl,--gc-sections -mmcu=attiny13 -o /tmp/arduino_build_255240/delay_switch.ino.elf /tmp/arduino_build_255240/sketch/delay_switch.ino.cpp.o /tmp/arduino_build_255240/../arduino_cache_822171/core/core_attiny13_avr_attiny13_freq_f1200000_c5d2763094ad9de4fb9ce2df1d92eb6e.a -L/tmp/arduino_build_255240 -lm

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-objcopy -O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0 /tmp/arduino_build_255240/delay_switch.ino.elf /tmp/arduino_build_255240/delay_switch.ino.eep

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-objcopy -O ihex -R .eeprom /tmp/arduino_build_255240/delay_switch.ino.elf /tmp/arduino_build_255240/delay_switch.ino.hex

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avr-size -A /tmp/arduino_build_255240/delay_switch.ino.elf

  Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
  Global variables use 17 bytes of dynamic memory.

  /home/rigidus/build/arduino-1.8.9/hardware/tools/avr/bin/avrdude -C/home/rigidus/build/arduino-1.8.9/hardware/tools/avr/etc/avrdude.conf -v -pattiny13 -carduino -P/dev/ttyUSB0 -b19200 -Uflash:w:/tmp/arduino_build_255240/delay_switch.ino.hex:i

  avrdude: Version 6.3-20171130
  Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/
  Copyright (c) 2007-2014 Joerg Wunsch

  System wide configuration file is "/home/rigidus/build/arduino-1.8.9/hardware/tools/avr/etc/avrdude.conf"
  User configuration file is "/home/rigidus/.avrduderc"
  User configuration file does not exist or is not a regular file, skipping

  Using Port                    : /dev/ttyUSB0
  Using Programmer              : arduino
  Overriding Baud Rate          : 19200
  AVR Part                      : ATtiny13
  Chip Erase delay              : 4000 us
  PAGEL                         : P00
  BS2                           : P00
  RESET disposition             : dedicated
  RETRY pulse                   : SCK
  serial program mode           : yes
  parallel program mode         : yes
  Timeout                       : 200
  StabDelay                     : 100
  CmdexeDelay                   : 25
  SyncLoops                     : 32
  ByteDelay                     : 0
  PollIndex                     : 3
  PollValue                     : 0x53
  Memory Detail                 :

  Block Poll               Page                       Polled
  Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack
  ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------
  eeprom        65     5     4    0 no         64    4      0  4000  4000 0xff 0xff
  flash         65     6    32    0 yes      1024   32     32  4500  4500 0xff 0xff
  signature      0     0     0    0 no          3    0      0     0     0 0x00 0x00
  lock           0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
  calibration    0     0     0    0 no          2    0      0     0     0 0x00 0x00
  lfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
  hfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00

  Programmer Type : Arduino
  Description     : Arduino
  Hardware Version: 2
  Firmware Version: 1.18
  Topcard         : Unknown
  Vtarget         : 0.0 V
  Varef           : 0.0 V
  Oscillator      : Off
  SCK period      : 0.1 us

  avrdude: AVR device initialized and ready to accept instructions

  Reading | ################################################## | 100% 0.01s

      avrdude: Device signature = 0x1e9007 (probably t13)
  avrdude: NOTE: "flash" memory has been specified, an erase cycle will be performed
  To disable this feature, specify the -D option.
  avrdude: erasing chip
  avrdude: reading input file "/tmp/arduino_build_255240/delay_switch.ino.hex"
  avrdude: writing flash (794 bytes):

  Writing | ################################################## | 100% 2.00s

      avrdude: 794 bytes of flash written
  avrdude: verifying flash memory against /tmp/arduino_build_255240/delay_switch.ino.hex:
  avrdude: load data flash data from input file /tmp/arduino_build_255240/delay_switch.ino.hex:
  avrdude: input file /tmp/arduino_build_255240/delay_switch.ino.hex contains 794 bytes
  avrdude: reading on-chip flash data:

  Reading | ################################################## | 100% 1.20s

      avrdude: verifying ...
  avrdude: 794 bytes of flash verified

  avrdude done.  Thank you.
#+END_SRC
