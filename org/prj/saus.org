#+STARTUP: showall indent hidestars

#+TITLE: Система автоматизации пользовательских сценариев

* Интро

Первоначально идея этого проекта родилась из разговора о том, что программист всегда
сможет обойти ограничения, такие как "система учета рабочего времени", иначе это
неквалифицированный программист и он должен быть уволен за профнепригодность. Этот
аргумент был приведен в поддержку тезиса о том, что подходы "принуждения к работе" не
работают в творческих задачах.

Системы учета рабочего времени представляют собой шпионское ПО, которое некоторые
компании устанавливают на компьютеры работников, чтобы контролировать их
работу. Поводом к дискуссии стало сообщение о предприимчивом работнике, который,
устроившись программистом, отправлял назначенные ему задания аутсорсерам в Индию, и
довольно долго работал программистом, почти ничего не зная о программировании.

В порядке мыслительного эксперимента я предложил концепт программы, которая, будучи
запущена на компьютере разработчика, выполняет все действия, которые обычно выполняет
программист: пишет и рефакторит код, запускает тесты, настраивает конфиги, использует
командную строку, отвечает в рабочих чатах, ставит задачи в таск-трекере, поднимает
упавшие сервера, в то время как программист вообще не присутствует за компьютером, а
потягивает коктейль на пляже. Все для того, чтобы шпионское ПО было в счастливом
неведении.

Обсудив, что программист, способный написать такую систему, никогда не устроится в
бодишоп со шпионской малварью, мы пришли к мысли о том, что такая система была бы
полезна не только любителям позагорать в рабочее время, но и ответственным работникам,
освобождая их от рутины и выполняя работы в дневное время, когда наиболее
квалифицированные программисты, как известно, спят. Кроме того, ее можно было бы
творчески использовать для автоматизации поиска уязвимостей, сбора данных с веб-сайтов,
прокачки персонажей в онлайн-играх, да и вообще любых ручных операций. Такая ценная
идея должна быть реализована!

Для управления "от имени пользователя" используется X Window System, что дает нам
сетевую прозрачность и возможность запускать выполнение сценариев на удаленных машинах.

Сами сценарии не имеют ограничений на выполняемые действия - они могут делать снимки
экрана, распознавать на них объекты, перемещать курсор мыши и кликать на объектах,
выполнять перетаскивания и эмулировать нажатия кнопок на клавиатуре.

* Вывод на экран

Иногда нам полезно что-то напрямую вывести на экран. Есть базовые концепции, которые
необходимо знать для этого:
- Клавиатура, мышь и монитор находятся на машине, которую мы назовем ~server~
- Программа запущена на (вполне вероятно другой) машине, называемой ~client~
- Сервер - многопользовательская машина, каждый клиент которой сидит перед некоторой
  воображаемой штукой, называемой ~display~. Каждый дисплей может иметь несколько (но
  минимум один) мониторов. Нам обычно нужен тот, что по умолчанию (первый)
- Внутри дисплея организовано дерево из ~window~. У каждого из них, кроме корневого,
  есть родительское окно. Мы должны взять корневое окно (~root-window~) и создать свое
  окно, указав, что родительским для него будет ~root-window~. Создавая окно мы можему
  указать ему координаты, также есть параметр ~override-redirect~, который можно
  установить в ~on~ и тогда диспетчер окон не будет вмешиваться в эти координаты и даже
  не будет рисовать рамку и заголовок окна.
- После создания окна мы можем извлечь его идентификатор с помощью ~xlib:drawable-id~ и
  отправить его по электронной почте в другую страну, и машина на той стороне сможет
  подключиться к X-серверу и управлять им.
- Чтобы отобразить окно, мы должны поставить запрос на это в очередь клиента.
  (~xlib:map-window~). X11 всегда выполняет буферизацию и кеширование.
- Потом мы можем что-нибудь нарисовать в окне, и...
- Мы должны сделать ~xlib:display-finish-output~ чтобы явным образом отправить все
  запросы из очереди и очистить ее.
- Повторяя последние два шага, каждый раз когда нам нужно вывести что-то еще.
- Завершая работу мы должны отмапить окно используя ~xlib:unmap-window~
- Отправить все что есть в очереди ~xlib:display-finish-output~
- Удалить окно ~xlib:destroy-window~
- Закрыть дисплей ~xlib:close-display~

На клиент не возлагается обязанность очищать что-то - сервер должен сам заметить когда
соединение закрывается клиентом и очистить все необходимое самостоятельно. Поэтому
удаление окна и закрытие дисплея можно опустить.

Если программа передала свое окно другой программе, она должна сообщить X-серверу до
того, как она будет убита, установив ~close-down-mode~. Существует команда
~kill-temporary-clients~, которую стоит вызвать, когда вы полностью закончите работу с
окном.

Мы можем сделать макрос, который создаcт функцию, где есть описанные выше действия (и
немного сверх этого):
- открыть ~display~
- получить из него screen по умолчанию
- получить корневое окно (~root~) из screen
- создать окно (~window~) на базе корневого окна
- запампить созданное окно
- переместить окно поверх всех остальных функией ~xlib:window-priority~
- отобразить окно на дисплей функцией ~display-finish-output~
- вывести в окно то что мы хотим
- отмапить окно
- отобразить изменения на дисплей функцией display-finish-output

#+NAME: defdemo
#+BEGIN_SRC lisp
  (ql:quickload 'clx)

  (defmacro defdemo ((x y width height) &body body)
    `(let (display screen root black white window)
       ,#+:cmu
       (multiple-value-setq (display screen) (ext:open-clx-display))
       ,#+(or sbcl allegro clisp lispworks)
       (progn
         (setf display (xlib::open-default-display))
         (setf screen  (xlib:display-default-screen display)))
       #-(or cmu sbcl allegro clisp lispworks)
       (progn
         ;; Portable method
         (setf display (xlib:open-display (machine-instance)))
         (setf screen (xlib:display-default-screen *display*)))
       (setf root  (xlib:screen-root screen))
       (setf black (xlib:screen-black-pixel screen))
       (setf white (xlib:screen-white-pixel screen))
       (let ((window (xlib:create-window :parent root
                                         :x ,x :y ,y
                                         :event-mask nil
                                         :width ,width :height ,height
                                         :background white
                                         :border black
                                         :border-width 2
                                         ;; :override-redirect :on
                                         )))
         (xlib:map-window window)
         ;;
         ;; I hate to do this since this is not something any normal
         ;; program should do ...
         (setf (xlib:window-priority window) :above)
         (xlib:display-finish-output display)
         (unwind-protect
              (progn ,@body)
           (xlib:unmap-window window)
           (xlib:display-finish-output display)))))
#+END_SRC

После чего мы можем вывести что-то интересное например так:

#+BEGIN_SRC lisp
  <<defdemo>>

  (defun blow-bubble (x y width height &optional (host ""))
    (let* ((display (xlib:open-display host))
           (screen (first (xlib:display-roots display)))
           (white (xlib:screen-white-pixel screen))
           (black (xlib:screen-black-pixel screen))
           (root-window (xlib:screen-root screen))
           (my-window (xlib:create-window
                       :parent root-window
                       :x x
                       :y y
                       :width width
                       :height height
                       :background white
                       :override-redirect :on
                       :event-mask (xlib:make-event-mask :exposure :enter-window))))
      (xlib:map-window my-window)
      (xlib:event-case (display :force-output-p t :discard-p t)
        (:exposure     () (recurrence display my-window screen white black))
        (:enter-notify () t))
      (xlib:destroy-window my-window)
      (xlib:close-display display)))

  ;; (blow-bubble 10 10 700 700)

  (defun full-window-state (w)
    (xlib:with-state (w)
      (values (xlib:drawable-width w) (xlib:drawable-height w)
              (xlib:drawable-x w) (xlib:drawable-y w)
              (xlib:window-map-state w))))

  (defun recurrence (display window screen white black &optional (point-count 10000))
    (let ((gc (xlib:create-gcontext :drawable window :background white :foreground black)))
      (multiple-value-bind (width height) (full-window-state window)
        (xlib:clear-area window)
        (draw-ppict window gc point-count 0.0 0.0 (* width 0.5) (* height 0.5))
        (xlib:display-force-output display))
      (xlib:free-gcontext gc)))

  ;;; Draw points.  X assumes points are in the range of width x height,
  ;;; with 0,0 being upper left and 0,H being lower left.
  ;;; hw and hh are half-width and half-height of screen

  (defun draw-ppict (win gc count x y hw hh)
    "Recursively draw pretty picture"
    (unless (zerop count)
      (let ((xf (floor (* (+ 1.0 x) hw ))) ;These lines center the picture
            (yf (floor (* (+ 0.7 y) hh ))))
        (xlib:draw-point win gc xf yf)
        (draw-ppict win gc (1- count)
                    (- (* y (1+ (sin (* 0.7 x)))) (* 1.2 (sqrt (abs x))))
                    (- 0.21 x)
                    hw
                    hh))))

  ;; (defdemo (10 10 700 700)
  ;;   (xlib:event-case (display :force-output-p t :discard-p t)
  ;;     (:exposure () (progn
  ;;                     (format t "Exposed~%")
  ;;                     (recurrence display window screen white black)
  ;;                     ))
  ;;     (:enter-notify () t))
  ;;   ;; (recurrence display window screen white black)
  ;;   ;; (sleep 5)
  ;;   (xlib:destroy-window window)
  ;;   (xlib:close-display display)
  ;;   )
#+END_SRC
