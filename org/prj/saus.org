#+STARTUP: showall indent hidestars

#+TITLE: Система автоматизации пользовательских сценариев

* Интро

Первоначально идея этого проекта родилась из разговора о том, что программист всегда
сможет обойти ограничения, такие как "система учета рабочего времени", иначе это
неквалифицированный программист и он должен быть уволен за профнепригодность. Этот
аргумент был приведен в поддержку тезиса о том, что подходы "принуждения к работе" не
работают в творческих задачах.

Системы учета рабочего времени представляют собой шпионское ПО, которое некоторые
компании устанавливают на компьютеры работников, чтобы контролировать их
работу. Поводом к дискуссии стало сообщение о предприимчивом работнике, который,
устроившись программистом, отправлял назначенные ему задания аутсорсерам в Индию, и
довольно долго работал программистом, почти ничего не зная о программировании.

В порядке мыслительного эксперимента я предложил концепт программы, которая, будучи
запущена на компьютере разработчика, выполняет все действия, которые обычно выполняет
программист: пишет и рефакторит код, запускает тесты, настраивает конфиги, использует
командную строку, отвечает в рабочих чатах, ставит задачи в таск-трекере, поднимает
упавшие сервера, в то время как программист вообще не присутствует за компьютером, а
потягивает коктейль на пляже. Все для того, чтобы шпионское ПО было в счастливом
неведении.

Обсудив, что программист, способный написать такую систему, никогда не устроится в
бодишоп со шпионской малварью, мы пришли к мысли о том, что такая система была бы
полезна не только любителям позагорать в рабочее время, но и ответственным работникам,
освобождая их от рутины и выполняя работы в дневное время, когда наиболее
квалифицированные программисты, как известно, спят. Кроме того, ее можно было бы
творчески использовать для автоматизации поиска уязвимостей, сбора данных с веб-сайтов,
прокачки персонажей в онлайн-играх, да и вообще любых ручных операций. Такая ценная
идея должна быть реализована!

Для управления "от имени пользователя" используется X Window System, что дает нам
сетевую прозрачность и возможность запускать выполнение сценариев на удаленных машинах.

Сами сценарии не имеют ограничений на выполняемые действия - они могут делать снимки
экрана, распознавать на них объекты, перемещать курсор мыши и кликать на объектах,
выполнять перетаскивания и эмулировать нажатия кнопок на клавиатуре.

* Вывод на экран

Иногда нам полезно что-то напрямую вывести на экран. Есть базовые концепции, которые
необходимо знать для этого:
- Клавиатура, мышь и монитор находятся на машине, которую мы назовем ~server~
- Программа запущена на (вполне вероятно другой) машине, называемой ~client~
- Сервер - многопользовательская машина, каждый клиент которой сидит перед некоторой
  воображаемой штукой, называемой ~display~. Каждый дисплей может иметь несколько (но
  минимум один) экранов. Нам обычно нужен тот, что по умолчанию (первый).
- Внутри дисплея организовано дерево из окон, ~window~. У каждого из них, кроме
  корневого, есть родительское окно. Мы должны взять корневое окно (~root-window~) и
  создать свое окно, указав, что родительским для него будет ~root-window~. Создавая
  окно мы можем указать ему координаты. Также есть параметр ~override-redirect~,
  который можно установить в ~on~ и тогда диспетчер окон не будет вмешиваться в эти
  координаты и даже не будет рисовать рамку и заголовок окна.
- После создания окна мы можем извлечь его идентификатор с помощью ~xlib:drawable-id~ и
  отправить его на другую машину, и она сможет подключиться к X-серверу и управлять
  окном.
- Чтобы отобразить окно, мы должны сделать ~xlib:map-window~.
- Чтобы принимать события, которые происходят в окне мы используем
  ~xlib:event-case~. После появления окна на экране приходит событие ~:exposure~, в
  ответ на которое...
- ...мы можем что-нибудь нарисовать в окне, и...
- Мы должны сделать ~xlib:display-finish-output~ чтобы явным образом отправить все
  запросы из очереди и очистить ее, потому что X11 всегда выполняет буферизацию и
  кеширование.
- Мы можем повторять последние два шага (отрисовку и отправку буфера), каждый раз когда
  нам нужно вывести что-то еще.
- Завершая работу мы должны отмапить окно используя ~xlib:unmap-window~
- Удалить окно ~xlib:destroy-window~
- Закрыть дисплей ~xlib:close-display~

На клиент не возлагается обязанность очищать что-то - сервер должен сам заметить когда
соединение закрывается клиентом и очистить все необходимое самостоятельно. Поэтому
удаление окна и закрытие дисплея можно опустить.

Если программа передала свое окно другой программе, она должна сообщить X-серверу до
того, как она будет убита, установив ~close-down-mode~. Существует команда
~kill-temporary-clients~, которую стоит вызвать, когда вы полностью закончите работу с
окном.

В нашем примере, получив событие ~:exposure~ мы отрисуем некоторую демонстрационную
картинку с помощью рекурсивной процедуры ~reccurence~. А событие перемещения указателя
мыши в область окна приведет к закрытию окна:

#+BEGIN_SRC lisp
  (ql:quickload 'clx)

  (defun full-window-state (w)
    (xlib:with-state (w)
      (values (xlib:drawable-width w) (xlib:drawable-height w)
              (xlib:drawable-x w) (xlib:drawable-y w)
              (xlib:window-map-state w))))

  (defun recurrence (display window screen white black &optional (point-count 100000))
    (let ((gc (xlib:create-gcontext :drawable window :background white :foreground black)))
      (multiple-value-bind (width height) (full-window-state window)
        (xlib:clear-area window)
        (draw-ppict window gc point-count 0.0 0.0 (* width 0.5) (* height 0.5))
        (xlib:display-force-output display))
      (xlib:free-gcontext gc)))

  ;;; Draw points.  X assumes points are in the range of width x height,
  ;;; with 0,0 being upper left and 0,H being lower left.
  ;;; hw and hh are half-width and half-height of screen

  (defun draw-ppict (win gc count x y hw hh)
    "Recursively draw pretty picture"
    (unless (zerop count)
      (let ((xf (floor (* (+ 1.0 x) hw ))) ;These lines center the picture
            (yf (floor (* (+ 0.7 y) hh ))))
        (xlib:draw-point win gc xf yf)
        (draw-ppict win gc (1- count)
                    (- (* y (1+ (sin (* 0.7 x)))) (* 1.2 (sqrt (abs x))))
                    (- 0.21 x)
                    hw
                    hh))))

  (defun recurrence-demo (x y width height &optional (host ""))
    (let* ((display (xlib:open-display host))
           (screen (first (xlib:display-roots display)))
           (white (xlib:screen-white-pixel screen))
           (black (xlib:screen-black-pixel screen))
           (root-window (xlib:screen-root screen))
           (my-window (xlib:create-window
                       :parent root-window
                       :x x
                       :y y
                       :width width
                       :height height
                       :background white
                       :override-redirect :on
                       :event-mask (xlib:make-event-mask :exposure :enter-window))))
      (xlib:map-window my-window)
      (setf (xlib:window-priority my-window) :above)
      (xlib:event-case (display :force-output-p t :discard-p t)
        (:exposure     () (recurrence display my-window screen white black))
        (:enter-notify () t))
      (xlib:destroy-window my-window)
      (xlib:close-display display)))

  ;; (recurrence-demo 10 10 700 700)
#+END_SRC
