#+STARTUP: showall indent hidestars

#+TITLE: Разработка сетевого протокола

* Интро

Мы хотим разработать многофункциональный протокол для трансляции видео и аудио на базе
UDP, способный устойчиво работать в сетях с плохой пропускной способностью, таких как,
например, 3G.

* Требования к протоколу

- Многопоточность, то есть поддержка нескольких потоков:
  - управляющий
  - видео
  - аудио
- Опциональная гарантия доставки — управляющий поток имеет 100% гарантию, видео нам
  нужно меньше всего — мы там можем дропать фрейм, аудио нам все-таки бы хотелось.
- Приоритезация потоков — чтобы аудио уходило вперед, а управляющий вообще летел.
- Опциональное шифрование: или все данные, или только заголовки и критичные данные.

* Простая UDP-отсылка

Открываем UDP-соединение, забираем данные, упаковываем и отправляем. Соответствующий
код будет выглядеть так:

#+BEGIN_SRC c
  #define SERVER "127.0.0.1"
  #define BUFLEN 512  // Max length of buffer
  #define PORT 8888   // The port on which to send data

  int main(void)
  {
      struct sockaddr_in si;
      int s, i, slen=sizeof(si);
      char buf[BUFLEN];
      char message[BUFLEN];

      if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
      {
          fprintf(stderr, "socket() failed\n");
          exit(1);
      }

      memset((char *) &si, 0, sizeof(si));
      si.sin_family = AF_INET;
      si.sin_port = htons(PORT);

      if (inet_aton(SERVER , &si.sin_addr) == 0)
      {
          fprintf(stderr, "inet_aton() failed\n");
          exit(1);
      }

      message = get_new_data();

      if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si, slen)==-1)
      {
          fprintf(stderr, "sendto() failed\n");
          exit(1);
      }

      message = get_new_data();

      if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si, slen)==-1)
      {
          fprintf(stderr, "sendto() failed\n");
          exit(1);
      }
  }
#+END_SRC

#+BEGIN_SRC ditaa :file ../../img/netproto-01.png
    +--+--+--+--+--+       +--+--+--+--+--+
    |  |  |  |  |  |       |  |  |  |  |  |
    +--+--+--+--+--+       +--+--+--+--+--+
  ------------------------------------------------------------->
#+END_SRC

Но мы получим такую картину: если мы начинаем беспорядочно слать UDP пакеты в socket,
то по статистике к 21-му пакету вероятность того, что он дойдет, будет всего лишь
85%. То есть packet loss уже будет 15%, что никуда не годится. Это нужно исправлять.

* Pacer

Pacer — это такая штука, которая раздвигает пакеты во времени и контролирует их потерю;
смотрит, какой сейчас packet loss, в зависимости от этого адаптируется под скорость
канала.

#+BEGIN_SRC ditaa :file ../../img/netproto-02.png
    +--+ +--+ +--+ +--+ +--+       +--+ +--+ +--+ +--+ +--+
    |  | |  | |  | |  | |  |       |  | |  | |  | |  | |  |
    +--+ +--+ +--+ +--+ +--+       +--+ +--+ +--+ +--+ +--+
  ------------------------------------------------------------->
#+END_SRC


Как мы помним, для мобильных сетей 1-3% packet loss — это норма. Соответственно, надо с
этим как-то работать. Что делать, если мы теряем пакеты?

#+BEGIN_COMMENT

#+TBLNAME: data-table :export none
 |  x |    y1 |    y2 |
 |----+-------+-------|
 |  1 |   100 |   100 |
 |  3 | 99.55 | 99.85 |
 |  5 | 99.00 | 99.50 |
 |  7 | 98.25 | 99.25 |
 | 10 | 97.45 | 99.00 |
 | 13 | 96.35 | 98.75 |
 | 15 | 95.10 | 98.50 |
 | 17 | 94.00 | 98.25 |
 | 20 | 90.00 | 98.00 |
 | 21 | 85.00 | 97.95 |

#+END_COMMENT

#+BEGIN_SRC gnuplot :var data=data-table :file ../../img/netproto-03.png

set title "Simple UDP vs Pacer"

set xlabel "Packets"
set xrange [1:21]
set xtics 1,1,21

set ylabel "Probabiluty"
set yrange [85:100]
set ytics 85,1,100

plot data u 1:2 w lp lw 2 title 'Simple UDP', \
     data u 1:3 w lp lw 1 title 'Pacer'

#+END_SRC

* Retransmit

#+BEGIN_SRC plantuml :file ../../img/netproto-04.png

Server -> Client: pkt1
Client --> Server: ack1
Server -> Client: pkt2
Client --> Server: ack2
Server ->  : pkt3 (lost)

note over Client, Server: Retransmit Period

Server -> Client : pkt3
Client --> Server: ack3

#+END_SRC

В TCP, как известно, есть алгоритм fast retransmit: мы отправляем один пакет, второй,
если пакет потеряли, то через некоторое время (retransmit period) отправляем этот же
пакет.

Какие здесь плюсы? Никаких проблем, никакой избыточности, но есть минус — некоторый
retransmit period.
