#+TITLE: Минимальный Forth

#+STARTUP: showall indent hidestars

* Интро

Forth - один из тех чуждых языков, который большинство программистов относят к
категории странных, вроде Haskell, Lisp и.т.д. Настолько странных, что они предпочли бы
не думать об этом и продолжать писать код, за который им платят. Но это неправильно, и
если вы настоящий программист, вы должны хотя бы понимать этот язык, даже если вы
никогда не будете его использовать.

Лисп является вершиной языков высокого уровня, и возможности из лиспа десятки лет
добавляются в более распространенные языки. Но Forth в этом смысле является вершиной
низкоуровневых языков. Из коробки у него нет возможностей вроде динамического
управления памятью и даже строк. Фактически, на его примитивном уровне отсутствуют даже
такие базовые концепции как IF-выражения и циклы.

Почему же тогда вы могли бы хотеть узнать Forth? На это есть несколько очень веских
причин:

Прежде всего, Forth минимален. Вы действительно можете написать Forth целиком в,
скажем, 2000 строк кода. Я имею в виду не только программу Forth, я имею в виду полную
операционную систему Forth, среду и язык. Вы можете загружать такой Forth на голом ПК,
и он выдает подсказку, где вы можете начать делать какую-то полезную работу. Forth,
который у вас здесь, не минимален и использует Linux-процесс как его "базовый ПК"
(исключительно для обучающих целей). Это позволяет полностью понять систему. Кто может
сказать, что он полностью понимает, как работает Linux, или gcc?

Во-вторых, у Forth есть своеобразное свойство начальной загрузки. Под этим я
подразумеваю, что после написания небольшого ассемблерного кода, для общения с
оборудованием и реализации нескольких примитивов, весь остальной язык и компилятор
написан в самом Forth. Помните, я уже говорил, что Forth не хватает IF-выражений и
циклов? Конечно, на самом деле это не так, потому что такой lanuage был бы бесполезен,
но я имел в виду, что IF-утверждения и циклы написаны в самом Forth.

Теперь, конечно, это распространено и на других языках, и на этих языках мы называем это
"библиотеками". Например, в C ~printf~ представляет собой библиотечную функцию,
написанную на C. Но в Forth это выходит за рамки просто библиотек. Можете ли вы
представить, как написать на C ~if~?

И это подводит нас к третьей причине: если вы можете написать ~if~ в Forth, то зачем
ограничивать себя обычными конструкциями ~if~ / ~while~ / ~for~ / ~switch~? Вам нужен
итератор по списку чисел? Вы можете добавить её в язык. Как насчет оператора, который
извлекает переменные непосредственно из файла конфигурации и делает их доступными как
переменные Forth? Или как насчет добавления языка зависимостей вроде ~Makefile~ к
языку? В Forth в этом нет проблем. Как насчет модификации компилятора Forth, чтобы
позволить сложные стратегии инлайнинга? - да легко! Эта концепция не распространена в
языках программирования, но имеет имя (на самом деле два имени): ~макросы~ (под
которыми я имею в виду макросы в стиле ~Lisp~, а не хромой препроцессор C) и ~языки
предметной области~ (DSL).

Эта статья не посвящена изучению Forth как языка, здесь только рассказывается о том,
как писать Forth. Фактически, пока вы не поймете, как написан Forth, у вас будет только
очень поверхностное понимание того, как его использовать.

* Сборка

Если вы хотите запустить этот Forth, а не просто прочитать его, вам понадобится Linux
на процессоре не ниже i386. Linux, потому что вместо того, чтобы напрямую
программировать на на голом ПК, что вполне возможно, я использую более простое, для
учебных целей, предположение, о том, что "оборудование" - это процесс Linux с
несколькими базовыми системными вызовами (чтение, запись и выход, вот это все). i386
необходим, потому что мне пришлось написать немного кода на ассемблере, а i386 на
сегодняшний день является наиболее распространенным. (Конечно, когда я говорю «i386»,
любой 32-разрядный или 64-разрядный процессор x86 подойдет. Я компилирую все это на
64-битном процессоре).

Опять же, чтобы собрать все это, вам понадобится gcc и GAS (GNU-ассемблер). Команды для
сборки и запуска кода (сохраните файл как 'jonesforth.S') такие:

#+BEGIN_SRC sh
  gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
  cat jonesforth.f - | ./jonesforth
#+END_SRC

Если вы хотите запустить свои собственные программы Forth, вы можете:

#+BEGIN_SRC sh
  cat jonesforth.f myprog.f | ./jonesforth
#+END_SRC

Если вы хотите загрузить свой собственный код Forth, а затем продолжить чтение
пользовательских команд, вы можете сделать следующее:

#+BEGIN_SRC sh
  cat jonesforth.f myfunctions.f - | ./jonesforth
#+END_SRC

* Словарь

В Forth, как вы узнаете, функции называются «словами», и, так же, как и на других
языках, у них есть ~имя~ и ~определение~. Вот два слова Forth:

#+BEGIN_SRC forth
  : DOUBLE DUP + ;              \ имя: "DOUBLE"     определение: "DUP +"
  : QUADRUPLE DOUBLE DOUBLE ;   \ имя: "QUADRUPLE"  определение: "DOUBLE DOUBLE"
#+END_SRC

Слова, как встроенные, так и те, которые программист определяет позже, хранятся в
словаре, который является только связанным списком записей словаря.

#+BEGIN_SRC ditaa :file ../../img/forth-dict-list.png
<--- DICTIONARY ENTRY (HEADER) --------------------->
+----------------------+------------+---------------+------------- - - - -
| LINK POINTER         | LENGTH/    | NAME          | DEFINITION
|                      | FLAGS      |               |
+----------------------+------------+---------------+------------- - - - -
<---4 bytes-----------> <--1 byte--> <-- N bytes -->
#+END_SRC

Мы дойдем до определения слова позже. Сейчас просто посмотрите на заголовок. Первые 4
байта - это указатель ссылки. Он указывает на предыдущее слово в словаре, и для первого
слова в словаре является указателем ~NULL~. Затем появляется байт длины/флагов. Длина
слова может составлять до 31 символа (используется 5 бит), а три верхних бита
используются для различных флагов, про которые я расскажу позже. За этим следует само
имя, и в этой реализации имя всегда кратно 4 байтам, и первоначально заполнено нулевыми
байтами. Это просто для того, чтобы определение начиналось с 32-битной границы.

Переменная Forth, называемая ~LATEST~, содержит указатель на последнее заданное слово,
другими словами, ~голову~ этого связанного списка.

~DOUBLE~ и ~QUADRUPLE~ могут выглядеть так::

#+BEGIN_SRC ditaa :file ../../img/forth-dict-2words.png
  pointer to previous word
     ^
     |
  +--|------+---+---+---+---+---+---+---+---+------------- - - - -
  | LINK    | 6 | D | O | U | B | L | E | 0 | (definition ...)
  +---------+---+---+---+---+---+---+---+---+------------- - - - -
     ^       len                         padding
     |
  +--|------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
  | LINK    | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | (definition ...)
  +---------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
     ^       len                                     padding
     |
     |
    LATEST
#+END_SRC

Вы должны увидеть из этого, как можно реализовать поиск слова в словаре (просто пройти
по записям, начинающимся с той, на которую указывает LATEST, и сопоставляя имена, пока
вы не найдете совпадение или не наткнетесь на указатель NULL в конце словаря).

И как добавить слово в словарь (создать новое определение, установить его LINK в LATEST
и установить LATEST, чтобы он указывал на новое слово). Мы увидим именно эти функции,
реализованные в ассемблере позже.

Одним из интересных последствий использования связанного списка является то, что вы
можете переопределять слова, и более новое определение слова переопределяет более
старое. Это важная концепция в Forth, потому что это означает, что любое слово (даже
"встроенные" или "стандартные" слова) могут быть переопределены новым определением,
либо для его улучшения, либо для его ускорения или даже для его отключения. Однако
из-за того, как компилируются слова Forth, которые вы поймете ниже, слова, определенные
с использованием старого определения слова, продолжают использовать старое
определение. Только новые слова, определенные после нового определения, используют
новое определение.

* Прямой шитый код

Теперь мы перейдем к действительно важному, для пониманию Forth, аспекту. Если вы не
поймете этот раздел, то вы не поймете как работает Forth, и это будет неудачей с моей
стороны.

Давайте поговорим сначала о том, что означает "шитый код". Представьте себе
своеобразную версию Cи, где вам разрешено вызывать только функции без аргументов. (Не
беспокойтесь, о том, что такой язык будет совершенно бесполезен) Итак, в нашем
своеобразном Cи код будет выглядеть так:

#+BEGIN_SRC c
  f () {
      a ();
      b ();
      c ();
  }
#+END_SRC

...и так далее. Как бы функция, скажем, ~f~ выше, была скомпилирована стандартным
компилятором Cи в машинный код? Например для i386 так:

#+BEGIN_SRC asm
  f:
      CALL a          #  E8 08 00 00 00
      CALL b          #  E8 1C 00 00 00
      CALL c          #  E8 2C 00 00 00
      ;;  сейчас мы пока игнорируем возврат из функции
#+END_SRC

~E8~ - это машинный код x86 для «CALL» функции. В первые 20 лет компьютерная память
была ужасно дорогой, и мы могли бы беспокоиться о том, что расходуем впустую
память повторенными байтами «E8». Мы можем сэкономить 20% в размере кода (и,
следовательно, дорогостоящей памяти), сжав это:

#+BEGIN_SRC asm
  08 00 00 00   #  Просто адреса функций, без CALL
  1C 00 00 00
  2C 00 00 00
#+END_SRC

На 16-битной машине, подобной той, на которой Forth был запущен в первый раз, экономия
еще больше - 33%.

(Историческое примечание: Если модель исполнения, используемая Forth, кажется странной,
то она была полностью мотивирована необходимостью экономить память на ранних
компьютерах. Это сжатие не так важно сейчас, когда наши машины имеют больше памяти
в своих кэшах L1, чем в ранних компьютерах, но модель исполнения по-прежнему обладает
некоторыми полезными свойствами)

Конечно, этот код больше не будет работать непосредственно на процессоре. Вместо этого
нам нужно написать интерпретатор, который берет каждый адрес и вызывает его.

На машине i386 получается, что этот интерпретатор можно легко написать в двух
ассемблерных инструкциях, которые превращаются всего в 3 байта машинного кода. Давайте
сохраним в регистре ~%esi~ указатель на следующее слово для выполнения:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-01.png
        08 00 00 00 <- Сейчас мы выполняем это.  %esi указывает на _следующую_ процедуру.
%esi -> 1C 00 00 00
        2C 00 00 00
#+END_SRC

В i386 есть инструкция ~LODSL~ (или в терминологии руководств Intel, ~LODSW~). Она
делает две вещи:
- читает из памяти, на которую указывает ~%esi~ 4 байта в регистр ~%eax~
- увеличивает значение в регистре ~%esi~ на 4

Итак, после выполнения инструкции ~LODSL~ ситуация выглядит так:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-02.png
        08 00 00 00 <- Мы продолжаем выполнять это
        1C 00 00 00 <- %eax сейчас содержит этот адрес (0x0000001C)
%esi -> 2C 00 00 00
#+END_SRC

Сейчас нам надо сделать ~jmp~ на адрес, содержащийся в ~%eax~. Это снова всего одна
x86-инструкция, которая записывается как ~JMP *(%eax)~. И после того как мы сделаем JMP
ситуация выглядит так:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-03.png
          08 00 00 00
          1C 00 00 00 <- Сейчас мы выполняем новую процедуру
  %esi -> 2C 00 00 00
#+END_SRC

Для выполнения этой работы каждая подпрограмма сопровождается двумя инструкциями:
~LODSL; JMP *(%eax)~, которые буквально переходят к следующей подпрограмме.

И это подводит нас к нашей первой части реального кода! Ну, то есть, это макрос.

#+NAME: macro_next
#+BEGIN_SRC asm
  .macro NEXT
      lodsl
      jmp *(%eax)
  .endm
#+END_SRC

Этот макрос называется ~NEXT~. Это "фортизм". Он раскрывается в эти две инструкции.

Каждый примитив Forth, который мы пишем, должен быть завершен ~NEXT~. Думайте об
этом как о ~return~.

Все, что описано выше, называется ~прямым шитым кодом~.

Подводя итог: мы сжимаем наши вызовы функций до списка адресов и используем макрос,
чтобы переходить к следующей функции в списке. Мы также используем один регистр
(~%esi~), как своего рода указатель инструкции, указывая на следующую функцию в списке.

Я просто дам вам намек на то, что должно произойти, сказав, что определение Forth,
такое как:

#+BEGIN_SRC forth
  : QUADRUPLE DOUBLE DOUBLE ;   \ имя: "QUADRUPLE"  определение: "DOUBLE DOUBLE"
#+END_SRC

на самом деле компилирует (не совсем точно, но мы сразу увидим, почему) список адресов
функций для DOUBLE, DOUBLE и специальную функцию EXIT для завершения.

На данный момент, остроглазые эксперты ассемблера могут воскликнуть: "вы сделали
ошибку!".

Ага, я лгал вам о ~JMP *(%eax)~.

* Коссвенный шитый код

Оказывается, что ~прямой шитый код~ интересен, но только если вы хотите просто
выполнить список функций, написанных на ассемблере. Поэтому QUADRUPLE будет работать
только в том случае, если DOUBLE является функцией языка ассемблера. В ~прямом шитом
коде~ QUADRUPLE будет выглядеть так:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-04.png
          +------------------+
          | addr of DOUBLE   |------------------> (ассемблерный код double)
          +------------------+                    NEXT
  %esi -> | addr of DOUBLE   |
          +------------------+
#+END_SRC

Мы можем добавить дополнительный уровень косвенности, позволяющей нам запускать как
слова, написанные на ассемблере (примитивы, написанные для скорости), так и слова,
написанные на Forth-е, как списки адресов.

Дополнительная косвенность является причиной скобок в ~JMP *(%eax)~.

Давайте посмотрим, как QUADRUPLE и DOUBLE действительно выглядят в Forth:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-05.png
  : QUADRUPLE DOUBLE DOUBLE ;
  +------------------+
  | codeword         |
  +------------------+          : DOUBLE DUP + ;
  | addr of DOUBLE   |--------> +------------------+
  +------------------+          | codeword         |
  | addr of DOUBLE   |          +------------------+
  +------------------+          | addr of DUP      |--------> +------------------+
  | addr of EXIT     |          +------------------+          | codeword         |---+
  +------------------+  %esi -> | addr of +        |----+     +------------------+   |
                                +------------------+    |     | assembly to      |<--+
                                | addr of EXIT     |    |     | implement DUP    |
                                +------------------+    |     |    ..            |
                                                        |     |    ..            |
                                                        |     | NEXT             |
                                                        |     +------------------+
                                                        |
                                                        +---> +------------------+
                                                              | codeword         |---+
                                                              +------------------+   |
                                                              | assembly to      |<--+
                                                              | implement +      |
                                                              |    ..            |
                                                              | NEXT             |
                                                              +------------------+
#+END_SRC

Это та часть, где вам может понадобиться дополнительная чашка кофе. Что изменилось, так
это то, что я добавил дополнительный указатель на начало определения. В Forth это
иногда называют ~codeword~. Кодовое слово является указателем на интерпретатор для
запуска функции. Для примитивов, написанных на языке ассемблера, ~codeword~ просто
указывает на сам код - его не нужно интерпретировать, он просто запускается.

В словах, написанных в Forth (например, QUADRUPLE и DOUBLE), кодовое слово указывает на
функцию интерпретатора.

Я вскоре покажу вам функцию интерпретатора, но давайте вспомним наш косвенный ~JMP
*(%eax)~ с "дополнительными" скобками. Возьмем случай, когда мы выполняем DOUBLE, как
показано, и вызывается DUP. Обратите внимание, что ~%esi~ указывает на адрес ~+~

Ассемблерный код для DUP в конце делает ~NEXT~. Это:
- читает адрес ~+~ в ~%eax~ - теперь ~%eax~ указывает на ~codeword~ ~+~
- увеличивает ~%esi~ на 4
- выполняет ~jmp~ на содержимое того адреса, который лежит в ~%eax~ → т.е. ~jmp~ по
  адресу, лежащему в ~codeword~ слова ~+~, → т.е. ~jmp~ на ассемблерный код, реализующий
  ~+~.


#+BEGIN_SRC ditaa :file ../../img/forth-interpret-06.png

  +------------------+
  | codeword         |
  +------------------+
  | addr of DOUBLE   |--------> +------------------+
  +------------------+          | codeword         |
  | addr of DOUBLE   |          +------------------+
  +------------------+          | addr of DUP      |----------> +------------------+
  | addr of EXIT     |          +------------------+            | codeword         |---+
  +------------------+          | addr of +        |----+       +------------------+   |
                                +------------------+    |       | assembly to      |<--+
                        %esi -> | addr of EXIT     |    |       | implement DUP    |
                                +------------------+    |       |    ..            |
                                                        |       |    ..            |
                                                        |       | NEXT             |
                                                        |       +------------------+
                                                        |
                                                        +-----> +------------------+
                                                                | codeword         |---+
                                                                +------------------+   |
                                                     сейчас мы  | assembly to      |<--+
                                                     исполняем  | implement +      |
                                                     эту        |    ..            |
                                                     функцию    |    ..            |
                                                                | NEXT             |
                                                                +------------------+
#+END_SRC

Поэтому я надеюсь, что я убедил вас, что ~NEXT~ делает примерно то, что вы
ожидаете. Это ~коссвенный шитый код~.

Я не сказал о четырех вещах. Интересно, сможете ли вы догадаться о них, не читая
дальше?

Вот список этих вещей:
- что делает ~EXIT~?
- как происходит вызов функции, т.е. как ~%esi~ начинает указывать на часть QUADRUPLE,
  а затем указывать на часть DOUBLE?
- Что входит в ~codeword~ для слов, написанных на Forth?
- Как компилировать функцию, которая делает что-то еще, кроме вызова других функций,
  например функцию, которая содержит число, такую как ~: DOUBLE 2 * ;~?

* Интерпретатор и стек возвратов

Не останавливаясь на этом, давайте поговорим о третьей и второй проблемах,
интерпретаторе и стек возврата.

Слова, которые определены в Forth, нуждаются в ~codeword~, которое указывает на
небольшое количество кода, который протягивает им "руку помощи". Им не нужно многого,
но им нужно то, что известно как ~интерпретатор~, хотя на самом деле он не является
интерпретатором в том же смысле, как, например, медленный интерпретатор байт-кода
Java. Этот интерпретатор просто устанавливает несколько машинных регистров, чтобы затем
слово могло выполняться на полной скорости с использованием модели коссвенного шитого
кода, показанной выше.

Одна из вещей, которые должны произойти, когда QUADRUPLE вызывает DOUBLE, заключается в
том, что мы сохраняем старый указатель инструкций ~%esi~ и создаем новый, указывающий
на первое слово в DOUBLE. Поскольку нам нужно будет восстановить старый ~%esi~ в конце
слова DOUBLE (в конце концов, это как вызов функции), нам понадобится стек для хранения
этих "адресов возврата" (старых значений ~%esi~).

Как вы, наверно видели в документации, Forth имеет два стека, обычный ~стек параметров~
и ~стек возвратов~, который немного загадочен. Но наш ~стек возвратов~ - это просто тот
стек, о котором я говорил в предыдущем абзаце, используемый для сохранения ~%esi~ когда
из одного слова Forth вызывается другое слово Forth.

В этом Forth мы используем обычный указатель стека (~%esp~) для ~стека параметров~. Мы
будем использовать другой указатель стека i386 (~%ebp~, обычно называемый "указателем
фрейма") для ~стека возвратов~.

У меня есть два макроса, которые просто оборачивают детали использования ~%ebp~ для
~стека возвратов~. Вы используете их, например, ~PUSHRSP %eax~ (push ~%eax~ в стеке возвратов)
или ~POPRSP %ebx~ (pop вершину стека возвратов в %ebx).

#+NAME: macro_pushrsp
#+BEGIN_SRC asm
  .macro PUSHRSP reg
      lea -4(%ebp), %ebp   // push reg on to return stack
      movl \reg, (%ebp)
  .endm
#+END_SRC

#+NAME: macro_poprsp
#+BEGIN_SRC asm
  .macro POPRSP reg
      mov (%ebp),\reg     // pop top of return stack to reg
      lea 4(%ebp), %ebp
  .endm
#+END_SRC

И с этим мы теперь можем поговорить об интерпретаторе.

В Forth функция интерпретатора часто называется DOCOL (я думаю, что это означает "DO
COLON", потому что все определения Forth начинаются с двоеточия, как в ~: DOUBLE DUP ;~

Интерпретатору (на самом деле это не "интерпретация") нужно push-нуть старый ~%esi~ в
стек и установить ~%esi~, чтобы он указывал на первое слово в определении. Помните, как
мы перешли к функции с помощью ~JMP *(%eax)~? Вследствие этого удобно, что ~%eax~
содержит адрес этого ~codeword~, поэтому просто добавляя к нему 4, мы получаем адрес
первого слова данных. Наконец, после установки ~%esi~, он просто делает NEXT, который
вызывает запуск первого слова.

#+NAME: docol
#+BEGIN_SRC asm
      .text
      .align 4
  DOCOL:
      PUSHRSP %esi         // push %esi on to the return stack
      addl $4, %eax        // %eax points to codeword, so make
      movl %eax, %esi      // %esi point to first data word
      NEXT
#+END_SRC

Чтобы это было совершенно ясно, посмотрим, как работает DOCOL при прыжке с QUADRUPLE в
DOUBLE:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-07.png
          QUADRUPLE:
          +------------------+
          | codeword         |
          +------------------+           DOUBLE:
          | addr of DOUBLE   |---------> +------------------+
          +------------------+   %eax -> | addr of DOCOL    |
  %esi -> | addr of DOUBLE   |           +------------------+
          +------------------+           | addr of DUP      |
          | addr of EXIT     |           +------------------+
          +------------------+           | etc.             |
                                         +------------------+
#+END_SRC

Во-первых, вызов DOUBLE вызывает DOCOL (кодовое слово DOUBLE). DOCOL делает следующее:
он push-ит старый ~%esi~ на стек возвратов. ~%eax~ указывает на ~codeword~ DOUBLE,
поэтому мы просто добавляем к нему 4, чтобы получить наш новый ~%esi~:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-08.png
              QUADRUPLE:
                +------------------+
                | codeword         |
                +------------------+           DOUBLE:
                | addr of DOUBLE   |--------> +------------------+
top of return   +------------------+  %eax -> | addr of DOCOL    |
stack points -> | addr of DOUBLE   |  + 4 =   +------------------+
                +------------------+  %esi -> | addr of DUP      |
                | addr of EXIT     |          +------------------+
                +------------------+          | etc.             |
                                              +------------------+
#+END_SRC

Затем он делает NEXT и так как из-за магии шитого кода, это увеличивает ~%esi~ снова,
то вызывается DUP.

Ну, похоже, это работает.

Здесь есть одна второстепенная вещь. Поскольку DOCOL - это первый кусок ассемблерного
кода, который должен быть определен в этом файле (остальные - только макросы), и
поскольку я обычно компилирую этот код с сегментом ~.text~, начинающимся с адреса 0,
DOCOL имеет адрес 0. Поэтому, если вы дизассемблируете код и увидите слово с ~codeword~
0, вы сразу же поймете, что это слово Forth (а не ассемблерный примитив), и поэтому
использует DOCOL в качестве интерпретатора.

* Начинаем

Теперь давайте перейдем к гайкам и болтам. Когда мы запускаем программу, нам нужно
настроить несколько вещей, таких как стек возвратов. Но как только мы сможем, мы хотим
перейти в код Forth (хотя большая часть «раннего» кода Forth все равно должна быть
написана как примитивы на языке ассемблера).

Это то, что делает код настройки:
- Делает небольшую вступительную часть,
- Настраивает отдельный стек возврата (NB: Linux дает нам обычный стек параметров уже),
- затем сразу переходит к слову Forth, называемому QUIT.  Несмотря на свое название,
  QUIT никуда не выходит. Он сбрасывает некоторое внутреннее состояние и начинает
  чтение и интерпретацию команд. (Причина, по которой он называется QUIT, заключается в
  том, что вы можете вызывать QUIT из вашего собственного кода Forth, чтобы «выйти» из вашей
  программы и вернуться к интерпретации).

#+NAME: asm_entry
#+BEGIN_SRC asm
      /* Assembler entry point. */
      .text
      .globl  _start
  _start:
      cld
      mov     %esp, var_S0            # Save the initial data stack pointer in Forth variable S0.
      mov     $return_stack_top, %ebp # Initialise the return stack.
      call    set_up_data_segment

      mov     $cold_start, %esi        # Initialise interpreter.
      NEXT                            # Run interpreter!

      .section .rodata
  cold_start:                         # High-level code without a codeword.
      .int QUIT
#+END_SRC

* Встроенные слова

Помните наши словарные записи? Давайте приведем их вместе с кодовым словом и словами
данных, чтобы увидеть, как

#+BEGIN_SRC forth
  : DOUBLE DUP ;
#+END_SRC

действительно выглядит в памяти.

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-09.png
          +---> указатель на предыдущее слово
          |
      +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
  +-->| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
  |   +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
  |              len                         pad  codeword        |
  |                                                               |
  +----- указатель из следующего слова                            +---> указатель на codeword DUP
#+END_SRC

Вначале мы не можем просто написать буквально ~: DOUBLE DUP;~ , потому что нам еще
нечем читать строку, разбивать ее на пробелы, анализировать каждое слово и.т.д. Поэтому
вместо этого нам придется определять встроенные слова, используя конструкторы данных
ассемблера GNU (например, .int, .byte, .string, .ascii и.т.д.)

#+BEGIN_SRC asm
      .int  <указатель на предыдущее слово>
      .byte 6         # len
      .ascii "DOUBLE" # name
      .byte 0         # padding
  DOUBLE:
      .int DOCOL      # codeword
      .int DUP        # указатель на codeword DUP
      .int PLUS       # указатель на codeword +
      .int EXIT       # указатель на codeword EXIT
#+END_SRC

Но это быстро утомляет, поэтому я определяю ассемблерный макрос, чтобы я мог просто
написать:

#+BEGIN_SRC asm
  defword "DOUBLE",6,,DOUBLE
  .int DUP,PLUS,EXIT
#+END_SRC

и получить точно такой же эффект. Не беспокойтесь о деталях реализации этого макроса -
он может показаться сложным.

#+NAME: macro_defword
#+BEGIN_SRC asm
      /* Flags - это мы обсудим потом */
      .set F_IMMED,0x80
      .set F_HIDDEN,0x20
      .set F_LENMASK,0x1f  # length mask

      // Store the chain of links.
      .set link,0

  .macro defword name, namelen, flags=0, label
      .section .rodata
      .align 4
      .globl name_\label
      name_\label :
      .int link               # link
      .set link,name_\label
      .byte \flags+\namelen   # flags + length byte
      .ascii "\name"          # имя
      .align 4                # padding to next 4 byte boundary
      .globl \label
      \label :
      .int DOCOL              # codeword - the interpreter
      # list of word pointers follow
  .endm
#+END_SRC

Таким образом я хочу, писать слова, написанные на ассемблере. Мы должны написать
некоторое количество базового кода, прежде чем будет достаточно "инфраструктуры", чтобы
начать писать слова Forth, но также я хочу определить некоторые общие слова Forth в
языке ассемблера для скорости, хотя я мог писать их на Forth.

Вот как DUP выглядит в памяти:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-10.png
          +---> указатель на предыдущее слово
          |
      +---------+---+---+---+---+------------+
  +-->| LINK    | 3 | D | U | P | code_DUP   | -----> указывает на ассемблерный код DUP,
  |   +---------+---+---+---+---+------------+        который заканчивается на NEXT
  |              len              codeword
  |
  +----- указатель из следующего слова
#+END_SRC

Опять же, для краткости я собираюсь написать макрос ассемблера с именем ~defcode~. Как
и в случае с ~defword~ выше, не беспокойтесь о сложных деталях макроса.

#+NAME: macro_defcode
#+BEGIN_SRC asm
  .macro defcode name, namelen, flags=0, label
      .section .rodata
      .align 4
      .globl name_\label
  name_\label :
      .int    link               # link
      .set    link,name_\label
      .byte   \flags+\namelen    # flags + length byte
      .ascii  "\name"            # the name
      .align  4                  # padding to next 4 byte boundary
      .globl  \label
  \label :
      .int    code_\label        # codeword
      .text
      //.align 4
      .globl  code_\label
      code_\label :              # assembler code follows
  .endm
#+END_SRC

Теперь несколько простых примитивов Forth. Они написаны на ассемблере для
скорости. Если вы понимаете язык ассемблера i386, то стоит их прочитать.

#+NAME: simple_primitives
#+BEGIN_SRC asm
      defcode "DROP",4,,DROP
      pop     %eax            # drop top of stack
      NEXT

      defcode "SWAP",4,,SWAP
      pop     %eax            # swap top two elements on stack
      pop     %ebx
      push    %eax
      push    %ebx
      NEXT

      defcode "DUP",3,,DUP
      mov     (%esp), %eax     # duplicate top of stack
      push    %eax
      NEXT

      defcode "OVER",4,,OVER
      mov     4(%esp), %eax    # get the second element of stack
      push    %eax            # and push it on top
      NEXT

      defcode "ROT",3,,ROT
      pop     %eax
      pop     %ebx
      pop     %ecx
      push    %ebx
      push    %eax
      push    %ecx
      NEXT

      defcode "-ROT",4,,NROT
      pop     %eax
      pop     %ebx
      pop     %ecx
      push    %eax
      push    %ecx
      push    %ebx
      NEXT

      defcode "2DROP",5,,TWODROP
      pop     %eax            # drop top two elements of stack
      pop     %eax
      NEXT

      defcode "2DUP",4,,TWODUP
      mov     (%esp), %eax     # duplicate top two elements of stack
      mov     4(%esp), %ebx
      push    %ebx
      push    %eax
      NEXT

      defcode "2SWAP",5,,TWOSWAP
      pop     %eax            # swap top two pairs of elements of stack
      pop     %ebx
      pop     %ecx
      pop     %edx
      push    %ebx
      push    %eax
      push    %edx
      push    %ecx
      NEXT

      defcode "?DUP",4,,QDUP
      movl    (%esp), %eax     # duplicate top of stack if non-zero
      test    %eax, %eax
      jz      1f
      push    %eax
  1:
      NEXT

      defcode "1+",2,,INCR
      incl    (%esp)          # increment top of stack
      NEXT

      defcode "1-",2,,DECR
      decl    (%esp)          # decrement top of stack
      NEXT

      defcode "4+",2,,INCR4
      addl    $4, (%esp)       # add 4 to top of stack
      NEXT

      defcode "4-",2,,DECR4
      subl    $4, (%esp)       # subtract 4 from top of stack
      NEXT

      defcode "+",1,,ADD
      pop     %eax            # get top of stack
      addl    %eax, (%esp)     # and add it to next word on stack
      NEXT

      defcode "-",1,,SUB
      pop     %eax            # get top of stack
      subl    %eax, (%esp)     # and subtract it from next word on stack
      NEXT

      defcode "*",1,,MUL
      pop     %eax
      pop     %ebx
      imull   %ebx, %eax
      push    %eax            # ignore overflow
      NEXT
#+END_SRC

В этом Forth только ~/MOD~ примитив. Позже мы определим слова ~/~ и ~MOD~ в терминах
примитива ~/MOD~. Конструкция ассемблерной команды ~idiv~, которая оставляет как частное,
так и остаток, делает этот выбор очевидным.

#+NAME: mod
#+BEGIN_SRC asm
  defcode "/MOD",4,,DIVMOD
  xor     %edx, %edx
  pop     %ebx
  pop     %eax
  idivl   %ebx
  push    %edx       # push remainder
  push    %eax       # push quotient
  NEXT
#+END_SRC

Множество сравнительных операций, таких как ~=~, ~<~, ~>~, и.т.д

Стандарт ANSI Forth говорит, что слова сравнения должны возвращать все (двоичные) ~1~
для TRUE и всех ~0~ для FALSE. Однако это немного странное соглашение, поэтому этот
Forth не следует ему и возвращает более нормальное (для программистов на си) значение ~1~
для TRUE и ~0~ для FALSE.

#+NAME: comparison
#+BEGIN_SRC asm
  defcode "=",1,,EQU
  pop     %eax                # top two words are equal?
  pop     %ebx
  cmp     %ebx, %eax
  sete    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "<>",2,,NEQU
  pop     %eax                # top two words are not equal?
  pop     %ebx
  cmp     %ebx, %eax
  setne   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "<",1,,LT
  pop     %eax
  pop     %ebx
  cmp     %eax, %ebx
  setl    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode ">",1,,GT
  pop     %eax
  pop     %ebx
  cmp     %eax, %ebx
  setg    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "<=",2,,LE
  pop     %eax
  pop     %ebx
  cmp     %eax, %ebx
  setle   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode ">=",2,,GE
  pop     %eax
  pop     %ebx
  cmp     %eax, %ebx
  setge   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0=",2,,ZEQU
  pop     %eax                # top of stack equals 0?
  test    %eax, %eax
  setz    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0<>",3,,ZNEQU
  pop     %eax                # top of stack not 0?
  test    %eax, %eax
  setnz   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0<",2,,ZLT
  pop     %eax                # comparisons with 0
  test    %eax, %eax
  setl    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0>",2,,ZGT
  pop     %eax
  test    %eax, %eax
  setg    %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0<=",3,,ZLE
  pop     %eax
  test    %eax, %eax
  setle   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "0>=",3,,ZGE
  pop     %eax
  test    %eax, %eax
  setge   %al
  movzbl  %al, %eax
  pushl   %eax
  NEXT

  defcode "AND",3,,AND
  pop     %eax                # bitwise AND
  andl    %eax, (%esp)
  NEXT

  defcode "OR",2,,OR
  pop     %eax                # bitwise OR
  orl     %eax, (%esp)
  NEXT

  defcode "XOR",3,,XOR
  pop     %eax                # bitwise XOR
  xorl    %eax, (%esp)
  NEXT

  defcode "INVERT",6,,INVERT
  notl    (%esp)              # this is the Forth bitwise "NOT" function (cf. NEGATE and NOT)
  NEXT
#+END_SRC

* Возвращение из форт-слов

Время поговорить о том, что происходит, когда мы делаем EXIT. На этой диаграмме
QUADRUPLE вызывает DOUBLE, и DOUBLE собирается сделать EXIT (посмотрите, куда указывает
~%esi~)

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-11.png
  QUADRUPLE
  +------------------+
  | codeword         |
  +------------------+           DOUBLE
  | addr of DOUBLE   |---------> +------------------+
  +------------------+           | codeword         |
  | addr of DOUBLE   |           +------------------+
  +------------------+           | addr of DUP      |
  | addr of EXIT     |           +------------------+
  +------------------+           | addr of +        |
                                 +------------------+
                         %esi -> | addr of EXIT     |
                                 +------------------+
#+END_SRC

Что происходит, когда функция выполняет NEXT? Выполняется следующий код:

#+NAME: exit
#+BEGIN_SRC asm
  defcode "EXIT",4,,EXIT
  POPRSP  %esi     // pop return stack into %esi
  NEXT
#+END_SRC

EXIT получает старый ~%esi~, который мы сохранили ранее в ~стеке возвратов~, и помещает
его в ~%esi~. Итак, после этого (но до NEXT) мы получаем:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-12.png
          QUADRUPLE
          +------------------+
          | codeword         |
          +------------------+           DOUBLE
          | addr of DOUBLE   |---------> +------------------+
          +------------------+           | codeword         |
  %esi -> | addr of DOUBLE   |           +------------------+
          +------------------+           | addr of DUP      |
          | addr of EXIT     |           +------------------+
          +------------------+           | addr of +        |
                                         +------------------+
                                         | addr of EXIT     |
                                         +------------------+
#+END_SRC

И NEXT просто завершает работу, в этом случае, просто вызвав DOUBLE снова.

* Литералы

Последний момент, который я "замалчивал" раньше, заключался в том, как иметь дело с
функциями, которые делают что-либо помимо вызова других функций. Например, предположим,
что DOUBLE был определен следующим образом:

#+BEGIN_SRC forth
  : DOUBLE 2 * ;
#+END_SRC

Он делает то же самое, но как мы его скомпилируем, так как он содержит буквальный 2?
Одним из способов было бы иметь функцию под названием ~2~ (которую вы должны были бы
написать на ассемблере), но вам понадобится функция для каждого отдельного литерала,
который вы хотели использовать.

Forth решает это, компилируя функцию, используя специальное слово LIT:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-13.png
  +---------------------------+-------+-------+-------+-------+-------+
  | (usual header of DOUBLE)  | DOCOL | LIT   | 2     | ✴     | EXIT  |
  +---------------------------+-------+-------+-------+-------+-------+
#+END_SRC

LIT выполняется обычным способом, но то, что он делает дальше, определенно не
нормально. Он смотрит на ~%esi~ (который теперь указывает на номер 2), захватывает его,
толкает его в стек, а затем манипулирует ~%esi~, чтобы пропустить номер, как если бы он
никогда не был там.

Что интересно, так это то, что весь захват и манипуляция может быть выполнена с
использованием одной байтовой команды i386, нашего старого друга ~LODSL~. Вместо того,
чтобы рисовать диаграммы, посмотрите, можете ли вы узнать, как работает ~LIT~:

#+NAME: exit
#+BEGIN_SRC asm
  defcode "LIT",3,,LIT
  # %esi указывает на следующую команду, но в этом случае это указатель на следующий
  # литерал, представляющий собой 4 байтовое значение. Получение этого литерала в %eax
  # и инкремент %esi на x86 -  это удобная однобайтовая инструкция! (см. NEXT macro)
  lodsl
  # push the literal number on to stack
  push %eax
  NEXT
#+END_SRC

* Память

Важным моментом в Forth является то, что он дает вам прямой доступ к самым низким
деталям машины. Манипулирование памятью часто осуществляется в Forth, и вот примитивы
для этого:

#+NAME: store
#+BEGIN_SRC asm
  defcode "!",1,,STORE
  pop     %ebx                # address to store at
  pop     %eax                # data to store there
  mov     %eax, (%ebx)         # store it
  NEXT

  defcode "@",1,,FETCH
  pop     %ebx                # address to fetch
  mov     (%ebx), %eax         # fetch it
  push    %eax                # push value onto stack
  NEXT

  defcode "+!",2,,ADDSTORE
  pop     %ebx                # address
  pop     %eax                # the amount to add
  addl    %eax, (%ebx)         # add it
  NEXT

  defcode "-!",2,,SUBSTORE
  pop     %ebx                # address
  pop     %eax                # the amount to subtract
  subl    %eax, (%ebx)         # add it
  NEXT
#+END_SRC

~!~ и ~@~ (STORE и FETCH) работают с 32-битными словами. Также полезно иметь
возможность читать и писать байты, поэтому мы также определяем стандартные слова ~C@~ и
~C!~. Байт-ориентированные операции работают только на архитектуре, которая их
разрешает (i386 является одним из них).

#+NAME: char_store
#+BEGIN_SRC asm
  defcode "C!",2,,STOREBYTE
  pop     %ebx                # address to store at
  pop     %eax                # data to store there
  movb    %al, (%ebx)          # store it
  NEXT

  defcode "C@",2,,FETCHBYTE
  pop     %ebx                # address to fetch
  xor     %eax, %eax
  movb    (%ebx), %al          # fetch it
  push    %eax                # push value onto stack
  NEXT

  /* C@C! is a useful byte copy primitive. */
  defcode "C@C!",4,,CCOPY
  movl    4(%esp), %ebx        # source address
  movb    (%ebx), %al          # get source character
  pop     %edi                # destination address
  stosb                       # copy to destination
  push    %edi                # increment destination address
  incl    4(%esp)             # increment source address
  NEXT

  /* and CMOVE is a block copy operation. */
  defcode "CMOVE",5,,CMOVE
  mov     %esi, %edx           # preserve %esi
  pop     %ecx                # length
  pop     %edi                # destination address
  pop     %esi                # source address
  rep     movsb               # copy source to destination
  mov     %edx, %esi           # restore %esi
  NEXT
#+END_SRC

* Встроенные переменные

Это некоторые встроенные переменные и соответствующие стандартные слова Forth. Из них
единственное, что мы обсуждали до сих пор, было LATEST, что указывает на последнее
(последнее определенное) слово в словаре Forth. LATEST также является словом Forth,
которое выталкивает адрес переменнуй LATEST в стек, поэтому вы можете читать или писать
ее с помощью операторов ~@~ и ~!~. Например, чтобы напечатать текущее значение LATEST
(и это применимо к любой переменной Forth), вы должны:

#+BEGIN_SRC forth
  LATEST @ . CR
#+END_SRC

Чтобы уменьшить определение переменных, я использую макрос ~defvar~, похожий на
~defword~ и ~defcode~ выше. (Фактически, ~defvar~ макрос использует ~defcode~ для
создания заголовка в словаре).

#+NAME: macro_defvar
#+BEGIN_SRC asm
  .macro defvar name, namelen, flags=0, label, initial=0
      defcode \name,\namelen,\flags,\label
      push    $var_\name
      NEXT
      .data
      .align 4
      var_\name :
      .int \initial
  .endm
#+END_SRC

Встроенные переменные:
- STATE   - состояние интерпретации(0) или компиляции слова (отличным от нуля)
- LATEST  - указатель на последнее заданное слово в словаре.
- HERE    - указатель на следующий свободный байт памяти. При компиляции скомпилированные слова
  помещаются тут.
- S0      - хранит адрес верхней части стека параметров.
- BASE    - текущая база для печати и чтения чисел.

#+NAME: built_in_vars
#+BEGIN_SRC asm
  defvar "STATE",5,,STATE
  defvar "HERE",4,,HERE
  defvar "LATEST",6,,LATEST,name_SYSCALL0   # SYSCALL0 must be last in built-in dictionary
  defvar "S0",2,,SZ
  defvar "BASE",4,,BASE,10
#+END_SRC

* Встроенные константы

Встроенные константы:
- VERSION   - это текущая версия этого Forth.
- R0        - адрес вершины стека возвратов.
- DOCOL     - Указатель на DOCOL.
- F_IMMED   - текущее значение флага IMMEDIATE.
- F_HIDDEN  - Текущее значение флага HIDDEN.
- F_LENMASK - Маска длины в  flags/len байте
- SYS_ * и числовые коды различных системных вызовов Linux (из <asm/unistd.h>)

#+NAME: built_in_constants
#+BEGIN_SRC asm
  //#include <asm-i386/unistd.h>  // вам может понадобиться это вместо этого
  #include <asm/unistd.h>

  .macro defconst name, namelen, flags=0, label, value
      defcode \name,\namelen,\flags,\label
      push $\value
      NEXT
  .endm

  defconst "VERSION",7,,VERSION,JONES_VERSION
  defconst "R0",2,,RZ,return_stack_top
  defconst "DOCOL",5,,__DOCOL,DOCOL
  defconst "F_IMMED",7,,__F_IMMED,F_IMMED
  defconst "F_HIDDEN",8,,__F_HIDDEN,F_HIDDEN
  defconst "F_LENMASK",9,,__F_LENMASK,F_LENMASK

  defconst "SYS_EXIT",8,,SYS_EXIT,__NR_exit
  defconst "SYS_OPEN",8,,SYS_OPEN,__NR_open
  defconst "SYS_CLOSE",9,,SYS_CLOSE,__NR_close
  defconst "SYS_READ",8,,SYS_READ,__NR_read
  defconst "SYS_WRITE",9,,SYS_WRITE,__NR_write
  defconst "SYS_CREAT",9,,SYS_CREAT,__NR_creat
  defconst "SYS_BRK",7,,SYS_BRK,__NR_brk

  defconst "O_RDONLY",8,,__O_RDONLY,0
  defconst "O_WRONLY",8,,__O_WRONLY,1
  defconst "O_RDWR",6,,__O_RDWR,2
  defconst "O_CREAT",7,,__O_CREAT,0100
  defconst "O_EXCL",6,,__O_EXCL,0200
  defconst "O_TRUNC",7,,__O_TRUNC,01000
  defconst "O_APPEND",8,,__O_APPEND,02000
  defconst "O_NONBLOCK",10,,__O_NONBLOCK,04000
#+END_SRC

* Стек возвратов

Эти слова позволяют получить доступ к стеку возвратов. Напомним, что регистр %ebp всегда
указывает на вершину стека возвратов.

#+NAME: return_stack_words
#+BEGIN_SRC asm
  defcode ">R",2,,TOR
  pop     %eax                # pop parameter stack into %eax
  PUSHRSP %eax                # push it on to the return stack
  NEXT

  defcode "R>",2,,FROMR
  POPRSP  %eax                # pop return stack on to %eax
  push    %eax                # and push on to parameter stack
  NEXT

  defcode "RSP@",4,,RSPFETCH
  push     %ebp
  NEXT

  defcode "RSP!",4,,RSPSTORE
  pop     %ebp
  NEXT

  defcode "RDROP",5,,RDROP
  addl    $4, %ebp            # pop return stack and throw away
  NEXT
#+END_SRC

* Стек параметров (данных)

Эти функции позволяют вам управлять стеком параметров. Напомним, что Linux
устанавливает для нас стек параметров, и он доступен через регистр ~%esp~.

#+NAME: data_stack_words
#+BEGIN_SRC asm
  defcode "DSP@",4,,DSPFETCH
  mov     %esp, %eax
  push    %eax
  NEXT

  defcode "DSP!",4,,DSPSTORE
  pop     %esp
  NEXT
#+END_SRC

* Ввод и вывод

Это наши первые действительно сложные примитивы FORTH. Я решил написать их на
ассемблере, но удивительно, что в реальных реализациях FORTH они часто пишутся в
терминах более фундаментальных примитивов FORTH.

Я решил избежать этого, потому что я думаю, что это просто скрывает реализацию. В конце
концов, вы можете не понимать ассемблер, но вы можете просто подумать об этом как о
непрозрачном блоке кода, который делает то, что он говорит.

Давайте сначала обсудим ввод.

Слово KEY считывает следующий байт из stdin (и push-ит его на стек
параметров). Поэтому, если KEY вызывается, и кто-то нажимает на клавишу пробела, то
число 32 (ASCII-код пробела) помещается в стек.

В FORTH нет различий между чтением кода и чтением ввода. Мы могли бы читать и
компилировать код, мы могли бы читать слова для выполнения, мы могли бы попросить
пользователя набрать свое имя - в конечном итоге все это происходит через KEY.

Реализация KEY использует входной буфер определенного размера (определенный в конце
этого файла). Он вызывает системный вызов Linux read(2) для заполнения этого буфера и
отслеживает его положение в буфере с помощью пары переменных, и если у него
заканчивается входной буфер, он автоматически заполняет его. Если KEY обнаруживает, что
stdin закрыт, он выходит из программы, поэтому, когда вы нажимаете ^D, система FORTH
полностью завершается.

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-14.png
 +----buffer          +-----bufftop
 |                    |
 |                    V
 |  +-------------------------------+--------------------------------------+
 +->| INPUT READ FROM STDIN ....... | unused part of the buffer            |
	+-------------------------------+--------------------------------------+
	                  ^
                      |
                      +----currkey (next character to read)

	<---------------------- BUFFER_SIZE (4096 bytes) ---------------------->
#+END_SRC

#+NAME: word_key
#+BEGIN_SRC asm
      defcode "KEY",3,,KEY
      call _KEY
      push %eax               # push return value on stack
      NEXT
  _KEY:
      mov     (currkey), %ebx
      cmp     (bufftop), %ebx
      jge     1f              # exhausted the input buffer?
      xor     %eax, %eax
      mov     (%ebx), %al     # get next key from input buffer
      inc     %ebx
      mov     %ebx,(currkey)  # increment currkey
      ret
  1:
      # Out of input, use read(2) to fetch more input from stdin.
      xor     %ebx, %ebx      # 1st param: stdin
      mov     $buffer, %ecx   # 2nd param: buffer
      mov     %ecx,currkey
      mov     $BUFFER_SIZE, %edx  # 3rd param: max length
      mov     $__NR_read, %eax # syscall: read
      int     $0x80
      test    %eax, %eax      # If %eax <= 0, then exit.
      jbe     2f
      addl    %eax, %ecx      # buffer+%eax = bufftop
      mov     %ecx,bufftop
      jmp     _KEY
  2:
      # Error or end of input: exit the program.
      xor     %ebx, %ebx
      mov     $__NR_exit, %eax # syscall: exit
      int     $0x80

      .data
      .align 4
  currkey:
      # Current place in input buffer (next character to read).
      .int buffer
  bufftop:
      # Last valid data in input buffer + 1.
      .int buffer
#+END_SRC

Напротив, выход намного проще. Слово EMIT выводит один байт в stdout. Эта реализация
просто использует системный вызов ~write~. Никакой попытки сделать буфер не
производится, но было бы хорошим упражнением добавить его.

#+NAME: word_emit
#+BEGIN_SRC asm
      defcode "EMIT",4,,EMIT
      pop %eax
      call _EMIT
      NEXT
  _EMIT:
      mov     $1, %ebx        # 1st param: stdout

      # write needs the address of the byte to write
      mov     %al, emit_scratch
      mov     $emit_scratch, %ecx # 2nd param: address

      mov     $1, %edx        # 3rd param: nbytes = 1

      mov     $__NR_write, %eax   # write syscall
      int     $0x80
      ret

      .data           # NB: easier to fit in the .data section
  emit_scratch:
      .space 1        # scratch used by EMIT
#+END_SRC

Вернемся к вводу. WORD - это слово , которое читает следующее полное слово со
стандартного ввода. Если подробнее, он сначала пропускает любые пробелы (пробелы,
вкладки, символы новой строки и.т.д.). Затем он вызывает KEY, чтобы читать символы во
внутреннем буфере, пока не наткнется на пробел. Затем он вычисляет длину прочитанного
слова и возвращает адрес и длину как два слова в стеке (с длиной в верхней части
стека).

Обратите внимание, что WORD имеет единственный внутренний буфер, который он
перезаписывает каждый раз (скорее, как статическая строка в си). Также обратите
внимание, что внутренний буфер WORD составляет всего 32 байта, и нет проверки для
переполнения. 31 байт - это максимальная длина слова FORTH, которое мы поддерживаем, и
это то, для чего WORD и используется: чтения слов FORTH при компиляции и выполнении
кода. Возвращенные строки не заканчиваются NUL.

Начальный адрес и длина строки - это обычный способ представления строк в FORTH (не
заканчивающийся символом ASCII NUL, как в C), и поэтому строки FORTH могут содержать
любой символ, включая NUL, и могут быть любой длины.

WORD не подходит для простого считывания строк (например, пользовательского ввода)
из-за всех вышеперечисленных особенностей и ограничений.

Обратите внимание, что при выполнении вы увидите:

#+BEGIN_SRC forth
  WORD FOO
#+END_SRC

который помещает «FOO» и длину 3 в стек, но при компиляции:

#+BEGIN_SRC forth
  : BAR WORD FOO ;
#+END_SRC

будет ошибка (или, по крайней мере, это не сделает то, что вы можете ожидать). Позже мы
поговорим о компиляции и про ~режим немедленного исполнения~, и вы поймете, почему.

#+NAME: word_word
#+BEGIN_SRC asm
      defcode "WORD",4,,WORD
      call    _WORD
      push    %edi            # push base address
      push    %ecx            # push length
      NEXT
  _WORD:
      # Search for first non-blank character.  Also skip \ comments.
  1:
      call    _KEY            # get next key, returned in %eax
      cmpb    $'\\', %al      # start of a comment?
      je      3f              # if so, skip the comment
      cmpb    $' ', %al
      jbe     1b              # if so, keep looking

      # Search for the end of the word, storing chars as we go.
      mov     $word_buffer, %edi  # pointer to return buffer
  2:
      stosb                   # add character to return buffer
      call    _KEY            # get next key, returned in %al
      cmpb    $' ', %al       # is blank?
      ja      2b              # if not, keep looping

      # Return the word (well, the static buffer) and length. */
      sub     $word_buffer, %edi
      mov     %edi, %ecx      # return length of the word
      mov     $word_buffer, %edi  # return address of the word
      ret

      # Code to skip \ comments to end of the current line.
  3:
      call    _KEY
      cmpb    $'\n', %al      # end of line yet?
      jne     3b
      jmp     1b

      .data                   # NB: easier to fit in the .data section
      # A static buffer where WORD returns.  Subsequent calls
      # overwrite this buffer.  Maximum word length is 32 chars.
  word_buffer:
      .space 32
#+END_SRC

Помимо чтения слов, нам нужно будет читать цифры, и для этого мы используем функцию
NUMBER. Она анализирует числовую строку, например, возвращаемую WORD, и push-ит число в
стек параметров.

эта функция использует переменную BASE в качестве базы (radix) для преобразования,
поэтому, например, если BASE равна 2, мы ожидаем двоичное число. Обычно BASE составляет
10.

Если слово начинается с символа '-', тогда возвращаемое значение отрицательно.

Если строка не может быть проанализирована как число (или содержит символы за пределами
текущей BASE), тогда нам нужно вернуть индикацию ошибки. Таким образом, NUMBER
фактически возвращает два элемента в стеке. В верхней части стека мы возвращаем
количество несконвертированных символов (т. Е. Если 0, то все символы были
преобразованы, поэтому нет ошибки). Второй элемент от вершины стека - это
распарсенное число или частичное значение, если произошла ошибка.

#+NAME: word_number
#+BEGIN_SRC asm
      defcode "NUMBER",6,,NUMBER
      pop     %ecx            # length of string
      pop     %edi            # start address of string
      call    _NUMBER
      push    %eax            # parsed number
      push    %ecx            # number of unparsed characters (0 = no error)
      NEXT

  _NUMBER:
      xor     %eax, %eax
      xor     %ebx, %ebx

      test    %ecx, %ecx      # trying to parse a zero-length string is an error, but will return 0.
      jz      5f

      movl    var_BASE, %edx  # get BASE (in %dl)

      # Check if first character is '-'.
      movb    (%edi), %bl     # %bl = first character in string
      inc     %edi
      push    %eax            # push 0 on stack
      cmpb    $'-', %bl       # negative number?
      jnz     2f
      pop     %eax
      push    %ebx            # push <> 0 on stack, indicating negative
      dec     %ecx
      jnz     1f
      pop     %ebx            # error: string is only '-'.
      movl    $1, %ecx
      ret
      # Loop reading digits.
  1:
      imull   %edx, %eax      # %eax *= BASE
      movb    (%edi), %bl     # %bl = next character in string
      inc     %edi
      # Convert 0-9, A-Z to a number 0-35.
  2:
      subb    $'0', %bl       # < '0'?
      jb      4f
      cmp     $10, %bl        # <= '9'?
      jb      3f
      subb    $17, %bl        # < 'A'? (17 is 'A'-'0')
      jb      4f
      addb    $10, %bl
  3:
      cmp     %dl, %bl        # >= BASE?
      jge     4f
      # OK, so add it to %eax and loop.
      add     %ebx, %eax
      dec     %ecx
      jnz     1b
      # Negate the result if first character was '-' (saved on the stack).
  4:
      pop     %ebx
      test    %ebx, %ebx
      jz      5f
      neg     %eax
  5:
      ret
#+END_SRC

* Просмотр словаря

Мы подходим к нашей прелюдии о том, как компилируется код FORTH, но сначала нам нужно
еще немного инфраструктуры.

Слово FIND принимает строку (слово, которое анализируется WORD - см. выше) и находит
его его в словаре. Фактически он возвращает адрес заголовка словаря, если он находит
его, или 0, в противном случае

Поэтому, если DOUBLE определен в словаре, тогда

#+BEGIN_SRC forth
  WORD DOUBLE FIND
#+END_SRC

возвращает следующий указатель:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-15.png
  +----указатель, возвращенный WORD DOUBLE FIND
  |
  |
  |  +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
  +->| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
     +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
#+END_SRC

See also >CFA and >DFA.

FIND не находит словарные записи, помеченные как HIDDEN. См. ниже, почему.

#+NAME: word_number
#+BEGIN_SRC asm
      defcode "FIND",4,,FIND
      pop     %ecx            # %ecx = length
      pop     %edi            # %edi = address
      call    _FIND
      push    %eax            # %eax = address of dictionary entry (or NULL)
      NEXT

  _FIND:
      push    %esi            # Save %esi so we can use it in string comparison.

      # Now we start searching backwards through the dictionary for this word.
      mov     var_LATEST, %edx # LATEST points to name header of the latest word in the dictionary
  1:
      test    %edx, %edx      # NULL pointer?  (end of the linked list)
      je      4f

      # Compare the length expected and the length of the word.
      # Note that if the F_HIDDEN flag is set on the word, then by a bit of trickery
      # this won't pick the word (the length will appear to be wrong).
      xor     %eax, %eax
      movb    4(%edx), %al    # %al = flags+length field
      andb    $(F_HIDDEN|F_LENMASK), %al # %al = name length
      cmpb    %cl, %al        # Length is the same?
      jne     2f

      # Compare the strings in detail.
      push    %ecx            # Save the length
      push    %edi            # Save the address (repe cmpsb will move this pointer)
      lea     5(%edx), %esi   # Dictionary string we are checking against.
      repe    cmpsb           # Compare the strings.
      pop     %edi
      pop     %ecx
      jne     2f              # Not the same.

      # The strings are the same - return the header pointer in %eax
      pop     %esi
      mov     %edx, %eax
      ret
  2:
      mov     (%edx), %edx    # Move back through the link field to the previous word
      jmp     1b              # .. and loop.
  4:
      # Not found.
      pop     %esi
      xor     %eax, %eax      # Return zero to indicate not found.
      ret
#+END_SRC

FIND возвращает указатель словаря, но при компиляции нам нужен указатель кодового слова
(напомним, что определения FORTH скомпилированы в списки указателей на
~codeword~-ы). Стандартное слово ~>CFA~ превращает указатель словаря в указатель на
~codeword~.

В приведенном ниже примере показан результат:

#+BEGIN_SRC forth
  WORD DOUBLE FIND >CFA
#+END_SRC

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-16.png
  +----FIND возвратил этот указатель           +-----›CFA преобразовал в указатель сюда
  |                                            |
  |                                            V
  |  +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
  +->| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
     +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                                                 codeword
#+END_SRC

NB: поскольку имена различаются по длине, это не просто простое приращение.

В этом FORTH вы не можете легко превратить указатель кодового слова обратно в указатель
на элемент словаря, но это не так для большинства реализаций FORTH, где они хранят
обратный указатель в определении (с очевидной стоимостью памяти / сложности).

Причина, по которой они делают это, заключается в том, что это бывает полезно, чтобы
быстро декомпилировать определения FORTH.

Что означает ~CFA~? Мое лучшее предположение - "Code Field Address"

#+NAME: word_number
#+BEGIN_SRC asm
      defcode ">CFA",4,,TCFA
      pop     %edi
      call    _TCFA
      push    %edi
      NEXT
  _TCFA:
      xor     %eax, %eax
      add     $4, %edi        # Skip link pointer.
      movb    (%edi), %al     # Load flags+len into %al.
      inc     %edi            # Skip flags+len byte.
      andb    $F_LENMASK, %al # Just the length, not the flags.
      add     %eax, %edi      # Skip the name.
      addl    $3, %edi        # The codeword is 4-byte aligned.
      andl    $~3, %edi
      ret
#+END_SRC

В связи с >CFA рассмотрим >DFA, который берет адрес записи словаря, возвращаемый FIND,
и возвращает указатель на первое поле данных.

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-17.png
  +----FIND возвратил этот указатель           +-----›CFA преобразовал в указатель сюда
  |                                            |
  |                                            |            +-----›DFA преобразовал в указатель сюда
  |                                            |            |
  |                                            V            V
  |  +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
  +->| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
     +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                                                 codeword
#+END_SRC

(Обратите внимание на этот момент, кто знаком с исходным кодом FIG-FORTH / ciforth: Это
>DFA определение отличается от их, потому что у них есть дополнительная косвенность).

Как легко можно увидеть >DFA легко определяется в FORTH, просто путем добавления 4 к
результату >CFA.

#+NAME: word_number
#+BEGIN_SRC asm
  defword ">DFA",4,,TDFA
  .int TCFA       # >CFA     (get code field address)
  .int INCR4      # 4+       (add 4 to it to get to next word)
  .int EXIT       # EXIT     (return from FORTH word)
#+END_SRC

* Компиляция

Теперь мы поговорим о том, как FORTH компилирует слова. Напомним, что определение слова
выглядит следующим образом:

#+BEGIN_SRC forth
  : DOUBLE DUP + ;
#+END_SRC

и мы должны превратить это в:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-18.png
       +---> указатель на предыдущее слово
       |
     +-+-------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
     | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
     +---------+---+---+---+---+---+---+---+---+------------+--+---------+------------+------------+
       ^        len                         pad  codeword      |
       |                                                       +--> указатель на codeword DUP
       +---- LATEST указывает сюда
#+END_SRC

Теперь нам нужно решить несколько задач:
- Куда поместить новое слово?
- Как мы читаем слова?
- Как мы определяем слова ~:~ (COLON) и ~;~ (SEMICOLON)?

FORTH решает это довольно изящно и, как вы можете ожидать, очень низкоуровневым
способом, который позволяет вам изменить способ работы компилятора над вашим
собственным кодом.

FORTH имеет функцию INTERPRET (настоящий интерпретатор на этот раз, а не DOCOL),
которая работает в цикле, читая слова (используя WORD), просматривая их (используя
FIND), превращая их в указатели кодового слова (используя >CFA) и решая, что с ними
делать.

То, что он делает, зависит от режима интерпретатора (в переменной STATE).

Когда STATE равно нулю, интерпретатор просто запускает каждое слово, когда оно
находит их. Это называется "немедленным режимом" (immediate mode).

Интересные вещи происходят, когда STATE не равен нулю - "режим компиляции" (compiling
mode). В этом режиме интерпретатор добавляет указатель ~codeword~ в
пользовательскую память (переменная HERE указывает на следующий свободный байт
пользовательской памяти - см. Раздел СЕГМЕНТ ДАННЫХ ниже).

Таким образом, вы сможете увидеть, как мы можем определить ~:~ (COLON). Общий план:
- (1) Использовать WORD для чтения имени определяемой функции.
- (2) Построить запись словаря - только часть заголовка - в пользовательской памяти:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-19.png
                                                         +-- Впоследствии здесь HERE указывает, где
    +---> указатель на предыдущее слово (из LATEST)      |   интерпретатор начнет добавлять
    |                                                    V   codewords
  +-+-------+---+---+---+---+---+---+---+---+------------+
  | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
  +---------+---+---+---+---+---+---+---+---+------------+
             len                         pad  codeword
#+END_SRC

- (3) Установить LATEST, чтобы указать на новое слово, ...
- (4) .. и самое главное оставить ЗДЕСЬ, указывая сразу после нового ~codeword~. Здесь
  интерпретатор будет добавлять кодовые слова.
- (5) Установить STATE в 1. Это вызовет переход в режим компиляции, поэтому интерпретатор
  начинает добавлять кодовые слова к нашему частично сформированному заголовку.

После того, как ~:~ запущен, наш вход находится здесь:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-20.png
  +---+--------+-----+---+---+
  | ː | DOUBLE | DUP | + | ; |
  +---+--------+-----+---+---+
               ^
               |
               +---следующий байт, возвращеннй KEY будет символом 'D' из DUP
#+END_SRC

поэтому интерпретатор (теперь он находится в режиме компиляции, поэтому я думаю, что
это на самом деле компилятор) читает "DUP", просматривает его в словаре, получает его
указатель на кодовое слово и добавляет его.

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-21.png
                                        HERE обновлена до этой точки--+
                                                                      |
                                                                      V
  +---------+---+---+---+---+---+---+---+---+------------+------------+
  | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        |
  +---------+---+---+---+---+---+---+---+---+------------+------------+
             len                         pad  codeword
#+END_SRC

Затем мы читаем ~+~, получаем указатель его ~codeword~ и добавляем его:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-22.png
                                            HERE обновлена до этой точки--+
                                                                          |
                                                                          V
  +---------+---+---+---+---+---+---+---+---+------------+------------+---+
  | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | + |
  +---------+---+---+---+---+---+---+---+---+------------+------------+---+
             len                         pad  codeword
#+END_SRC

Теперь проблема заключается в следующем. Очевидно, что мы не хотим, чтобы мы читали ~;~
скомпилировали его и продолжали компилировать все подряд.

На этом этапе FORTH использует трюк. Помните, что длина байта в определении словаря не
просто байт длины, но также может содержать флаги. Один флаг называется флагом
IMMEDIATE (F_IMMED в этом коде). Если слово в словаре помечено как IMMEDIATE, тогда
интерпретатор запускает его немедленно _даже если он находится в режиме компиляции_.

Вот как это слово ~;~ (SEMICOLON) работает - как слово, помеченное в словаре как
IMMEDIATE.

Все, что оно делает, - это добавляет кодовое слово для EXIT в текущее определение и
возвращает к немедленному режиму (установкой STATE на 0). Вскоре мы увидим его
фактическое определение; и мы увидим, что это действительно очень простое определение,
объявленное IMMEDIATE.

После чтения интерпретатором ~;~ и выполнения его "немедленно", мы получаем это:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-23.png
                                                   HERE обновлена до этой точки--+
                                                                                 |
                                                                                 V
  +---------+---+---+---+---+---+---+---+---+------------+------------+---+------+
  | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | + | EXIT |
  +---------+---+---+---+---+---+---+---+---+------------+------------+---+------+
             len                         pad  codeword
#+END_SRC

и STATE установлена в 0;

И это вся работа, наше новое определение скомпилировано, и мы вернулись в
непосредственный режим, простых чтений и выполнений слов, возможно, включая вызов,
чтобы проверить наше новое слово DOUBLE.

Единственная последняя заминка в том, что, хотя пока слово компилируется, оно было в
полуготовом состоянии. Мы, разумеется, не хотели бы, чтобы DOUBLE был вызван кем-то в
это время. Есть несколько способов сделать это это, но в FORTH мы устанавливаем байт
длины слова с флагом HIDDEN (F__HIDDEN в этом коде) во время его компиляции. Это предотвращает
обнаружение компилируемого слова с помощью FIND и, таким образом, теоретически
предотвращает любой шанс его вызова.

Вышеприведенное объясняет, как компилировать ~:~ (COLON) и ~;~ (SEMICOLON), и через
мгновение я их определю. Функция: (COLON) может быть сделана немного более общей, если
написать ее в двух частях. Первая часть, называемая CREATE, создает только заголовок:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-24.png
              HERE обновлена до этой точки--+
                                            |
                                            V
  +---------+---+---+---+---+---+---+---+---+
  | LINK    | 6 | D | O | U | B | L | E | 0 |
  +---------+---+---+---+---+---+---+---+---+
             len                         pad
#+END_SRC

и вторая часть, фактическое определение ~:~ (COLON), вызывает CREATE и добавляет кодовое
слово DOCOL:

#+BEGIN_SRC ditaa :file ../../img/forth-interpret-25.png
                           HERE обновлена до этой точки--+
                                                         |
                                                         V
  +---------+---+---+---+---+---+---+---+---+------------+
  | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
  +---------+---+---+---+---+---+---+---+---+------------+
             len                         pad  codeword
#+END_SRC

CREATE является стандартным словом FORTH, и преимущество этого разделения состоит в
том, что мы можем его повторно использовать для создания других типов слов (а не только
тех, которые содержат код, но например и таких, которые содержат переменные, константы
и другие данные).

#+NAME: word_number
#+BEGIN_SRC asm
  defcode "CREATE",6,,CREATE

      # Get the name length and address.
      pop     %ecx            # %ecx = length
      pop     %ebx            # %ebx = address of name

      # Link pointer.
      movl    var_HERE, %edi  # %edi is the address of the header
      movl    var_LATEST, %eax    # Get link pointer
      stosl                   # and store it in the header.

      # Length byte and the word itself.
      mov     %cl,%al         # Get the length.
      stosb                   # Store the length/flags byte.
      push    %esi
      mov     %ebx, %esi      # %esi = word
      rep     movsb           # Copy the word
      pop     %esi
      addl    $3, %edi        # Align to next 4 byte boundary.
      andl    $~3, %edi

      # Update LATEST and HERE.
      movl    var_HERE, %eax
      movl    %eax, var_LATEST
      movl    %edi, var_HERE
      NEXT
#+END_SRC
