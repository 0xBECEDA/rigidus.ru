#+STARTUP: showall indent hidestars

#+TITLE: IOTA реализация

* Интро

IOTA - криптовалюта для интернета вещей. Базовой структурой является, так называемый
~tangle~ - вариант направленного ациклического графа (DAG). Несмотря на то, что "tangle"
означает "клубок", структурно это скорее похоже на связаный шарф.

** Граф транзакций

Каждый узел (vertex) представляет собой транзакцию, каждое ребро направленно и
представляет собой ссылку на хэш ранее созданной транзакции.

Из одного вертекса может быть не более двух ссылок на предыдущие транзакции. Очевидно,
первый вертекс не может иметь предшественников, а второй имеет только одного.
Предполагаю, что для таких genesis-вертексов в соответствующих полях размещены нули.

Узлы, на которые нет ссылок, называются оконечными (~tips~). Из множества известных
узлов выбираются те, хэш которых будет помещен в ссылочное поле новой создаваемой
транзакции.

В каждый момент времени по крайней мере один ~tip~ будет существовать, поэтому если
новые транзакции приходят редко, то ~tangle~ вырождается в ~chain~, т.е. каждая
следующая транзакция подтверждает только одну предыдущую.

Напротив, если множество транзакций приходят одномоментно, то все они будут ссылаться
на один доступный ~tip~, что выглядит как "одуванчик", где этот ~tip~ в центре.

Так как каждый узел при создании захватывает два оконечных узла (если может),
предполагается тенденция уменьшения кол-ва свободных оконечных узлов - в пределе до
одного.

Если в момент создания транзакции доступны более чем два ~tip~-а, то необходимо выбрать
среди них те, которые будут подтверждаться. Можно было бы выбирать случайно, но есть
более интересный алгоритм, который называется ~unweighted random walk~

Используя этот алгоритм мы помещаем ~walker~-a в genesis-транзакцию и на каждом шаге он
переходит на одну из транзакций, которая апрувит ту, где он сейчас находится. Если
таких транзакций несколько, то выбор одной из них происходит случайным образом.

Таким образом, благодаря этому механизму, последние транзакции связываются с
предпоследними и получается именно "вязаный шарф", а не клубок, где вероятность связи
коррелирует с близостью к genesis-у.

** Эмиссия

Отсутствует, все монеты были созданы в первой транзакции.

** Протокол подтверждения

Каждый узел, создающий новую транзакцию должен подтвердить (approve) две другие
транзакции, если их подтверждение не приводит к возникновению отрицательного баланса.

Например возможна ситуация (double spending), когда ~А~ имеет на балансе 5 монет и
создает две транзакции, в первой из которых пересылает их ~B~, а во второй - ~C~. В
таком случае узел, подтверждающий обе транзакции, должен отвергнуть одну из этих
транзакций, т.к. в результате ~A~ будет иметь отрицительный баланс.

Это приведет к формированию двух ветвей, из которых должна быть отброшена одна. По
протоколу, будет отброшена более "легкая" ветвь, т.е. та, которая содержит в себе
меньше узлов.


* Ссылки

  - whitepaper https://iota.org/IOTA_Whitepaper.pdf
  - референсная реализация: https://github.com/iotaledger/iri
  - демонстрашка на js: https://public-rdsdavdrpd.now.sh/
  - демонстрашка unweighted random walk: https://public-xnmzdqumwy.now.sh/

* Вопросы

- Топология сети?
- Протокольный уровень правило взаимодействия узлов?
- Как работают консенсус и валидация блоков? Кто проверяет?
- Механизмы хранения данных как устроены хранилища?
- Смарт-контракты: да, нет, другие подходы
- Что такое коссвенное подтверждение?
- Что такое скрытые оконечники

* Транзакция

Я взял кусок класса транзакции из сорцов:

#+BEGIN_SRC java
  public class Transaction implements Persistable {
      public static final int SIZE = 1604;

      public byte[] bytes;

      public Hash address;
      public Hash bundle;
      public Hash trunk;
      public Hash branch;
      public Hash obsoleteTag;
      public long value;
      public long currentIndex;
      public long lastIndex;
      public long timestamp;

      public Hash tag;
      public long attachmentTimestamp;
      public long attachmentTimestampLowerBound;
      public long attachmentTimestampUpperBound;

      public int validity = 0;
      public int type = TransactionViewModel.PREFILLED_SLOT;
      public long arrivalTime = 0;

      //public boolean confirmed = false;
      public boolean parsed = false;
      public boolean solid = false;
      public long height = 0;
      public String sender = "";
      public int snapshot;

      ...
  }
#+END_SRC
