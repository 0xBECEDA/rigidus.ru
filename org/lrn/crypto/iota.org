#+STARTUP: showall indent hidestars

#+TITLE: IOTA - криптовалюта для интернета вещей.

* Как работает IOTA

IOTA - криптовалюта для интернета вещей. Базовой структурой является, так называемый
~tangle~ - вариант направленного ациклического графа (DAG). Несмотря на то, что "tangle"
означает "клубок", структурно это скорее похоже на связаный шарф.

** Граф транзакций

Каждый узел (vertex) представляет собой транзакцию, каждое ребро является направленным,
и представляет собой ссылку на хэш ранее созданной транзакции.

Из одного вертекса может быть не более двух ссылок на предыдущие транзакции. Очевидно,
первый вертекс не может иметь предшественников, а второй имеет только одного.
Предполагаю, что для таких genesis-вертексов в соответствующих полях размещены нули.

Узлы, на которые нет ссылок, называются оконечными (~tips~). Из множества известных
узлов выбираются те, хэш которых будет помещен в ссылочное поле новой создаваемой
транзакции.

В каждый момент времени по крайней мере один ~tip~ будет существовать, поэтому если
новые транзакции приходят редко, то ~tangle~ вырождается в ~chain~, т.е. каждая
следующая транзакция подтверждает только одну предыдущую.

[[img:iota-chain.png]]

Напротив, если множество транзакций приходят одномоментно, то все они будут ссылаться
на один доступный ~tip~, что выглядит как "одуванчик", где этот ~tip~ в центре.

[[img:iota-star.png]]

Так как каждый узел при создании захватывает два оконечных узла (если может),
предполагается тенденция уменьшения кол-ва свободных оконечных узлов - в пределе до
одного.

Если в момент создания транзакции доступны более чем два ~tip~-а, то необходимо выбрать
среди них те, которые будут подтверждаться. Можно было бы выбирать случайно, но есть
более интересный алгоритм, который называется ~unweighted random walk~

Его суть в следующем: мы помещаем ~walker~-a в genesis-транзакцию и на каждом шаге он
переходит на одну из транзакций, которая апрувит ту, где он сейчас находится. Если
таких транзакций несколько, то выбор одной из них происходит случайным образом.

[[img:unweighted-random-walk.gif]]

Таким образом, благодаря этому механизму, последние транзакции связываются с
предпоследними и получается именно "вязаный шарф".

Однако, при использовании этого алгоритма сеть не может противодействовать появлению
"ленивых оконечных узлов", ~lazy tips~, которые вместо исполнения алгоритма ~unweighted
random walk~ просто подтверждают старые, уже много раз подтвержденные транзакции -
такой подход вычислительно дешевле но не помогает сети, т.к. новые тразакции не
подтверждаются.

[[img:bad-unweighted-random-walk.png]]

Решение состоит в том, чтобы встроить в систему стимулы против подобного поведения,
так, чтобы ~lazy tips~ были бы подтверждены сетью с меньшей вероятностью. Введем термин
"совокупный вес", ~cumulative weight~, чтобы отразить важность транзакции. ~Cumulative
weight~ рассчитываестя как количество подтверждений плюс один. В приведенном примере
транзакция номер 3 имеет совокупный вес равный 5, потому что ее подтверждают четыре
синие транзакции.

[[img:cumulative-weight.png]]

В примере ниже транзакция 16 является ~lazy tip~. Чтобы подтвердить её, ~unweighted
random walk~ должен достичь транзакции 7, а затем выбрать транзакцию 16 за
транзакцией 9. Но в модели предпочтения транзакций с большим ~cumulative weight~ это
врядли произойдет, потому что транзакция 16 имеет кумулятивный вес равный единице, а
транзакция 9 - кумулятивный вес равный семи. Этот механизм эффективно предотвращает
"ленивое" поведение.

[[img:iota-lazy-prevention.png]]

Нужна ли нам вообще случайность? Мы можем всегда выбирать самую тяжелую транзакцию, без
каких-либо вероятностей. Но тогда мы получим множество побочных транзакций, которые
никогда не будут одобрены:

[[img:super-weighed-walk.png]]

** Эмиссия

Отсутствует, все монеты были созданы в первой транзакции. По сценарию в первых
транзакциях они распределяются среди инвесторов.

** Протокол подтверждения

Каждый узел, создающий новую транзакцию должен подтвердить (approve) две другие
транзакции, если их подтверждение не приводит к возникновению отрицательного баланса.

Например возможна ситуация (double spending), когда ~А~ имеет на балансе 5 монет и
создает две транзакции, в первой из которых пересылает их ~B~, а во второй - ~C~. В
таком случае узел, подтверждающий обе транзакции, должен отвергнуть одну из этих
транзакций, т.к. в результате ~A~ будет иметь отрицительный баланс.

Это приведет к формированию двух ветвей, из которых должна быть отброшена одна. По
протоколу, будет отброшена более "легкая" ветвь, т.е. та, которая содержит в себе
меньше узлов.

* Сценарии атаки

** Broken tangle

Идея состоит в том, чтобы выпустить N конфликтующих транзакций, две из которых не могут
подтвердить другие узлы в сети, эффективно разбивая tangle на N подпунктов. В конце
концов один выигрывает, но все, кто отправил транзакции на отвергнутый сегмент, должны
будут повторно отправить их, и к тому времени злоумышленник мог выпустить еще один
набор конфликтных транзакций.

Цель состоит в том, чтобы предотвратить подтверждение большинства транзакций (отказ в
обслуживании)

** Double spending

Большую часть времени узел получает и обменивает транзакции с соседями. Он заботится о
топологии графа только тогда, когда пришло время произвести транзакцию или принять
платеж.

[[img:iota-double-spending.png]]

Сейчас 16:04, и Боб решает отправить сообщение
Он создает транзакцию, которая ссылается на 2 транзакции:
- один депозит 1 йота на адрес Алисы
- другой тратит 1 йоту от адреса Алисы

Это не приводит к double spending, поэтому в 16:07 он прекращает создание транзакции,
содержащей его сообщение

Через 90 минут плохой парень Чарли решает сослаться на сделку Боба и другую сделку,
которая тратит 1 йоту с адреса Алисы

В 17:44 он завершает создание транзакции, которая ссылается на subtangle с искаженным
состоянием.

Никто из нас не заботится об этом, мы не знаем о дурном парне Чарли, потому что наши
узлы продолжают получать все транзакции и делиться ими.

В 19:15 хорошая девочка Диана решает отправить сообщение своей матери, она анализирует
Tangle и видит, что она не должна ссылаться на транзакцию Чарли, поэтому вместо этого
ссылается на транзакцию Боба.

Ее транзакция не является особенной, поэтому она не показана на картинке

Спустя несколько минут умная девушка Ева решает отправить сообщение своему парню. Она
хороша, но она тоже умна и решает потролить плохого парня Чарли

Она находит транзакцию, которая откладывает 1 йоту на адрес Алисы. Она ссылается на эту
сделку, а также на сделку Чарли. Мы видим сделку Евы в 19:21

Позже кто-то другой, производящий транзакцию, будет ссылаться на транзакцию Eva без
каких-либо проблем, потому что она «исправила» проблему, созданную Чарли.

Как мы можем видеть в этом сценарии в течение короткого периода времени, реестр может
быть непоследовательным

Все будет хорошо, если 67% + мощности хеширования контролируются доброжелательными
пользователями.

PS: Стоит подчеркнуть, что в IOTA нас не волнует порядок транзакций. Для проверки
бухгалтерии мы можем совершать транзакции в любом порядке. Это повышает
производительность и помогает масштабироваться до гораздо более высокой TPS, чем
позволяет ledger с упорядочением.


* Необъяснимое

** Координатор

Централизованный (!) сервер "для обеспечения безопасности".

* Ссылки

- whitepaper https://iota.org/IOTA_Whitepaper.pdf
- референсная реализация: https://github.com/iotaledger/iri
- демонстрашка на js: https://public-rdsdavdrpd.now.sh/
- демонстрашка unweighted random walk: https://public-xnmzdqumwy.now.sh/

* Критика

- https://casey.github.io/iota/

* Вопросы

- Топология сети?
- Протокольный уровень правило взаимодействия узлов?
- Как работают консенсус и валидация блоков? Кто проверяет?
- Механизмы хранения данных как устроены хранилища?
- Смарт-контракты: да, нет, другие подходы
- Что такое коссвенное подтверждение?
- Что такое скрытые оконечники

* Транзакция

Я взял кусок класса транзакции из сорцов:

#+BEGIN_SRC java
  public class Transaction implements Persistable {
      public static final int SIZE = 1604;

      public byte[] bytes;

      public Hash address;
      public Hash bundle;
      public Hash trunk;
      public Hash branch;
      public Hash obsoleteTag;
      public long value;
      public long currentIndex;
      public long lastIndex;
      public long timestamp;

      public Hash tag;
      public long attachmentTimestamp;
      public long attachmentTimestampLowerBound;
      public long attachmentTimestampUpperBound;

      public int validity = 0;
      public int type = TransactionViewModel.PREFILLED_SLOT;
      public long arrivalTime = 0;

      //public boolean confirmed = false;
      public boolean parsed = false;
      public boolean solid = false;
      public long height = 0;
      public String sender = "";
      public int snapshot;

      ...
  }
#+END_SRC
