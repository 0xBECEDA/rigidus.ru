#+STARTUP: showall indent hidestars

* Анализируем MyGdxGame
** Организация кода в Java
*** Пакеты
~Пакет~ - это контейнер, который используется для того, чтобы изолировать имена
~классов~. Это сделано для того, чтобы имена классов, созданных разными разработчиками
не конфликтовали друг с другом.

Первая строчка в нашем файле определяет пакет, к которому будет относиться все, что
следует ниже.

Чтобы сделать видимым имена классов из других пакетов предусмотрены операторы
~import~. Они идут в файле сразу за объявлением пакета.

*** Классы

~Класс~ - это шаблон, который описывает поведение ~объекта~.

В качестве примера: класс "собака" описывает поведение объекта "Тузик". Тузик может
гавкать или есть. Другой экземпляр собаки, например "Мухтар" тоже может гавкать или
есть, в этом они похожи. Поэтому все поведение мы можем описать в классе "собака" и все
экземпляры класса будут этим поведением обладать.

*** Объекты

~Объект~ - это экземпляр ~класса~, имеющий независимое от класса состояние.

В нашем примере Тузик может быть голоден или вообще спать - это его состояние, которое
может меняться со временем, но у всех объектов состояние разное. Пока Тузик спит Мухтар
может например лаять. Это потому что Мухтар вообще-то довольно злой - такое вот у него
состояние.

*** Методы

Поведение в Java выражается с помощью ~Методов~. Это намек на то, что раз уж у объекта
есть состояние, и ему нужен метод, чтобы это состояние выразить.

Т.е. когда Тузик злой, он просто лает, а вот когда злой Мухтар, он вообще кусается -
это его метод демонстрации состояния. Технически Тузик тоже может кусаться, как и все
нормальные собаки, у него есть такое поведение. Но Тузик почти никогда не злиться, а
вот Мухтар сидит на цепи и его все бесят. Собака бывает кусачей - только от жизни
собачей.

*** Переменные

~Переменные~ - это ячейки памяти, которые хранят состояние.

В Java все переменные принадлежат какому-то объекту. Какие именно переменные имеет
объект определяется его классом. А вот значения в этих переменных относятся к объекту,
они и есть его состояние.

*** Типы переменных

У каждой переменной есть ~Тип~. Он нужен затем, чтобы определить, сколько памяти должна
занимать переменная. Например, небольшое число занимает куда меньше памяти, чем
картинка.

Тип переменной пишется перед ее именем.

** Разбираем MyGdxGame

*** Переменные

Класс ~MyGdxGame~ имеет две переменные: ~batch~ и ~img~. Эти переменные соответствуют
~окну~, в котором мы будем размещать наши игровые элементы и ~картинке~ со злобным смайликом.

*** Методы

Класс ~MyGdxGame~ имеет три метода.

Первый, ~create~ - вызывается при старте игры. В нем мы создаем ~окно~ и загружаем
~картинку~ в наши переменные. И картинка и окно - на самом деле являются объектами, и у
них есть свои методы.

Последний, ~dispose~ - вызывается при завершении игры. В нем мы освобождаем память,
занятую ~картинкой~ и ~окном~

Между ними находится метод ~render~, в котром выполняются все действия по отрисовке
внутри окна, а именно:
- Заливка окна красным цветом
- Вывод картинки в окно, который производится между вызовами методов ~begin~ и ~end~ на
  объекте ~batch~. Как видите ~вызов метода~ производится записью
  ~объект.метод(параметры)~.

Что значит ~вызов метода~? Это примерно так же как и вызов функции - если есть у нас
функция ~y(x)=x*2~, которая удваивает свой параметр (x), то если мы передадим ей в
качестве параметра "5" - она вернет нам значение "10". Внутри функции происходит
какая-то магия, назовем ее "алгоритм".

~Алгоритм~ - это некоторое количество действий, приводящих к какому-то результату.

Например внутри метода ~draw~, который принадлежит объекту, лежащему в переменной
~batch~, есть некоторый ~алгоритм~. Если этому методу передать параметром какую-нибудь
переменную, имеющую тип ~Texture~, то он выполнит какие-то действия, приводящие к тому,
что картинка будет нарисована в окне игры.

Мы, в общем-то это и делаем.

** Как сделать алгоритм

*** Последовательное выполнение

Алгоритм - это, прежде всего, действия. Например, мы можем последовательно вывести
картинку три раза по разным координатам. Измените метод ~render~ между ~batch.begin()~
и ~batch.end()~, чтобы он выглядел так:

#+BEGIN_SRC java
  batch.begin();
  batch.draw(img, 0, 0);
  batch.draw(img, 100, 200);
  batch.draw(img, 200, 100);
  batch.end();
#+END_SRC

И запустите программу (для этого можно нажать Shift+F10). Вы должны получить такое
окно:

[[img:j-linear.png]]

*** Цикл

Если у нас много однотипных последовательных действий, мы могли бы использовать ~цикл~,
для того чтобы сделать их вот так:

#+BEGIN_SRC java
  batch.begin();
  batch.draw(img, 0, 0);
  for (int i=0; i<250; i+=50) {
      batch.draw(img, i, i);
  }
  batch.end();
#+END_SRC

Обратите внимание: теперь мы заключаем действия внутри фигурных скобок, а перед этим
пишем конструкцию ~for~, где через точку с запятой указываем три важных для цикла вещи:
~начальное значение~ переменной ~i~, ~условие выполнения~ цикла, и, наконец,
~приращение~ переменной цикла.

Иными словами, сначала ~i~ будет рано нулю, на каждом шаге цикла ~i~ будет
увеличиваться на 50, и это все будет продолжаться лишь пока ~i~ меньше 250, а после
этого цикл завершится.

Вот что мы получим в результате:

[[img:j-cycle.png]]

Обратите внимание, что теперь мы передаем методу ~draw~ переменную в качестве координат
~x~ и ~y~.

*** Условное выполнение

Иногда алгоритму надо принимать решение о том, что делать, в зависимости от внешних
условий. В нашем случае - от действий игрока, а еще конкретнее - от того, какие кнопки
игрок нажимает.

Допустим, мы хотим знать, нажимал ли игрок клавишу "пробел"? Если он нажимал - то нам
надо вывести картинку где-нибудь поближе к центру экрана.

Тут у нас сразу появляется состояние: был ли нажат пробел? Чтобы хранить это состояние
нам нужна переменная в классе, назовем ее ~pressed~. Изменим верхнюю часть класса вот так:

#+BEGIN_SRC java
  SpriteBatch batch;
  Texture img;
  int pressed = 0;
#+END_SRC

Мы добавили переменную. Теперь в зависимости от значения этой переменной будем выводить
картинку по тем или иным координатам. Изменим код вот так:

#+BEGIN_SRC java
  batch.begin();
  if (pressed == 0) {
      batch.draw(img, 0, 0);
  } else {
      batch.draw(img, 200, 150);
  }
  batch.end();
#+END_SRC

Здесь все просто: если ~pressed~ содержить ноль, как мы изначально и сказали, то каждый
раз, когда будет вызываться ~render~, а это примерно 60 раз в секунду, картинка будет
выводиться с координатами (0;0). Но если по какой-то причине ~pressed~ не будет
содержать ноль, то картинка будет выведена с координатами (200,150) и мы сразу это
увидим.

А теперь нам надо чуть выше в коде добавить ту самую причину, по которой там будет не
ноль:

#+BEGIN_SRC java
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
      this.pressed = 1;
  }
  batch.begin();
#+END_SRC

Здесь мы постоянно следим, не нажат ли ~пробел~. Если он нажат, мы сразу же помещаем в
~pressed~ значение 1. И вот тогда то и заработает наш код по отрисовке картинки ближе к
центру экрана.

Попробуйте сами. На всякий случай я оставлю тут окончательный код нашего класса:

#+BEGIN_SRC java
  public class MyGdxGame extends ApplicationAdapter {
      SpriteBatch batch;
      Texture img;
      int pressed = 0;

      @Override
      public void create () {
          batch = new SpriteBatch();
          img = new Texture("badlogic.jpg");
      }

      @Override
      public void render () {
          Gdx.gl.glClearColor(1, 0, 0, 1);
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
              this.pressed = 1;
          }
          batch.begin();
          if (pressed == 0) {
              batch.draw(img, 0, 0);
          } else {
              batch.draw(img, 200, 150);
          }
          batch.end();
      }

      @Override
      public void dispose () {
          batch.dispose();
          img.dispose();
      }
  }
#+END_SRC
