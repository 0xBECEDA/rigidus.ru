#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света,
предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения, загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State_1 = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State_1 = digitalRead(btn_1);

      if (State_1) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь я напишу код, который решает нашу задачу, т.е. формирует задержку
выключения. Чтобы "есть слона по кускам" я создам шаблон скетча, в который буду
вставлять куски кода, которые следуют далее. Этот шаблон включает пару глобальных
констант, начальную инициализацию =setup= и placeholder-ы для переменных и содержимого
внутреннего цикла:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1 = 8;
  const int relay_1 = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn_1_released= (по-умолчанию - =true=). Это первая из наших глобальных
переменных. Ее имя намекает, что я хочу управлять более чем одним реле.

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_1_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_1_released) {
          btn_1_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_1_released) {
          Serial.println("btn_1_released");
          delay(100);
          btn_1_released = true;
          <<on_btn_release>>
      }
      <<btn_1_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state_1=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state_1 = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state_1=. Если мы "включаемся", то должны установить задержку =duration_1=, а если мы
"выключаемся", то задержку можно явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration_1 = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state_1) {
      Serial.println("switch off, state_1 = LOW");
      state_1 = LOW;
      duration_1 = 0;
  } else {
      Serial.println("switch on, state_1 = HIGH");
      state_1 = HIGH;
      duration_1 = period_1;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period_1=:

#+NAME: vars
#+BEGIN_SRC c
  const long period_1 = 4000;
#+END_SRC

Если для второй кнопки мне потребуется более длинная задержка, я смогу сделать
=period_2= и получить желаемое.

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state_1 == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, в этом коде возможна ошибка, когда происходит переполнение! На нашей
платформе unsigned long - это четырехбайтовое значение, которое будет переполняться
каждые 49.7102696181 дней, если отсчитывать с момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (вероятно, почти 50 дней), потому что дальнейшие действия внутри
условия (last_time>=interval) не будут выполнены, и задержка не будет снята, а
состояние не переключится.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, таким образом =cur-mils= тоже "перескочит через ноль". А следующая проверка
отработает штатно, т.к. переполнения уже не будет. Ошибка увеличения задержки на этой
операции не будет превышать одного =interval=-а, что вполне приемлимо для нашей задачи.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state_1 == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration_1= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration_1= значение =interval= пока
=duration_1= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration_1 - interval;
  if ( decremented < 0 ) {
      state_1 = LOW;
      Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
  } else {
      duration_1 = decremented;
      Serial.print("duration_1 = ");
      Serial.println(decremented);
  }
#+END_SRC

Я помещаю логику задержки =check_duration= внутрь блока =btn_1_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_1_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state_1=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch_1 = state_1;
  if ( latch_1 != prev_latch_1 ) {
      prev_latch_1 = latch_1;
      digitalWrite(relay_1, latch_1);
      Serial.print("=> "); Serial.println(latch_1);
  }
#+END_SRC

** Arduino-решение

Скетч, который у нас получился:

#+BEGIN_SRC c
  const int btn_1 = 8;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              Serial.println("btn_pressed");
              if (HIGH == state_1) {
                  Serial.println("switch off, state_1 = LOW");
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  Serial.println("switch on, state_1 = HIGH");
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              Serial.println("btn_1_released");
              delay(100);
              btn_1_released = true;

          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      Serial.print("last_time = "); Serial.println(last_time);
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                          Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
                      } else {
                          duration_1 = decremented;
                          Serial.print("duration_1 = ");
                          Serial.println(decremented);
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
          Serial.print("=> "); Serial.println(latch_1);
      }
  }
#+END_SRC

* Upload to Attiny13

После успешной отладке на Arduino-прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
=Attiny13= в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (In-System Programmer)
для нашей Attiny13. Для этого нужно загрузить в нее скетч =ArduinoISP=, он находится в
меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyUSB0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я
заливал программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось в меню
Tools выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами код. Но перед этим придется удалить из
него отладочный вывод и переназначить вывод =bnt_1=, так как шестиногая микросхема
attiny13 не имеет вывода номер восемь, который мы раньше использовали как вход кнопки.

#+NAME: arduino_sketch_for_attiny13
#+BEGIN_SRC c
  const int btn_1 = 3;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              if (HIGH == state_1) {
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              delay(100);
              btn_1_released = true;
          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                      } else {
                          duration_1 = decremented;
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Это конечно многовато, тем не менее все работает:

[TODO:gmm] - video

** C-level

Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять с
одного микроконтроллера тремя выключателями с задержкой, а не одним.

Правда, один из этих свободных выводов - RESET, и чтобы использовать его нужны
некоторые ухищрения, описанные тут (https://habr.com/ru/post/110894/).

В попытке уменьшить размер программы и получить больший контроль над RESET, мы можем
отказаться от заливки в микроконтроллер Arduino Core и спуститься на уровень ниже,
запрограммировав микроконтроллер на языке Си. А все необходимые для этого вещи мы
сможем подсмотреть в том же Arduino Core.

Но сначала нам надо посмотреть, что конкретно делает Arduino IDE, когда компилирует и
заливает программу в микроконтроллер. Это можно сделать, установив в File ->
Preferences галочки "Show verbose output during compilation & upload"

Теперь при загрузке скетча мы можем получить довольно много информации о том, что
происходит "под капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через =Makefile=:

#+NAME: Makefile
#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = ./
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = delay_switch3
  MCU = attiny13
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  $(PROGRAM).elf: $(PROGRAM).o
      $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  $(PROGRAM).hex: $(PROGRAM).elf
      $(Q)$(OBJCOPY) -O ihex $< $@

  %.o: %.c
      $(Q)$(CC) $(CFLAGS) -o $@ -c $<

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

  clean:
      $(Q)rm -f $(OBJS)
      $(Q)rm -f *.elf
      $(Q)rm -f *.hex

  objdump:
      avr-objdump -dS $(PROGRAM).elf > $(PROGRAM).asm

  extract:
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:r:$(PROJECT_PATH)/$(PROGRAM).bin:r

  disasm:
      avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
#+END_SRC

Если вы будете использовать этот Makefile убедитесь, что табуляции в начале строк не
заменены на пробелы, потому что для Makefile они значимы.

Теперь будем менять код, чтобы компилятор Си смог его прожевать.

Для начала я перенес все константы в define. Чтобы сделать задержку, которая
предотвращает "дребезг контактов" я скопировал из Arduino Core функцию =delay=.

Потом я нашел в Arduino Core функцию =millis=, но оказалось, что она зависит от
переменной =ovrf=. Эта переменная инкрементируется каждый раз, когда приходит
прерывание от таймера, поэтому мне пришлось добавить саму переменную и процедуру
обработки прерывания (она начинается с =ISR=).

Также мне потребовалось скопировать в начало =main= процедуру инициализации таймера, в
которой я даже не стал пока разбираться - и после этого я смог заставить этот сишный
код работать:

#+NAME: c_code
#+BEGIN_SRC c :tangle delay_switch2.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3
  #define relay_1 PB4

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif

      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1)) // if (digitalRead(bnt_1) == HIGH)
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }
      }
  }
#+END_SRC

Этот код уже весит 662 байта (а не 794 как предыдущий), что дает нам право на попытку
поуправлять одновременно двумя релешками и двумя кнопками. Я просто скопировал
управляющий код и изменил необходимые имена переменных:

#+NAME: c_code_with_2_ctrls
#+BEGIN_SRC c :tangle delay_switch3.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3 // pin2
  #define relay_1 PB4 // pin3

  #define btn_2 PB2 // pin7
  #define relay_2 PB1 //pin6

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  const long interval = 1000;
  unsigned long prev_mils = 0;

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int btn_2_released = true;
  boolean state_2 = LOW;
  long duration_2 = 0;
  const long period_2 = 4000;
  boolean prev_latch_2 = LOW;
  boolean latch_2 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif


      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1))
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }


          if(PINB & (1 << btn_2))
          {
              if (btn_2_released) {
                  btn_2_released = false;
                  delay(100);
                  if (HIGH == state_2) {
                      state_2 = LOW;
                      duration_2 = 0;
                  } else {
                      state_2 = HIGH;
                      duration_2 = period_2;
                  }
              }

          } else {
              if (!btn_2_released) {
                  delay(100);
                  btn_2_released = true;
              }
              if (state_2 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_2 - interval;
                          if ( decremented < 0 ) {
                              state_2 = LOW;
                          } else {
                              duration_2 = decremented;
                          }
                      }
                  }
              }
          }

          latch_2 = state_2;
          if ( latch_2 != prev_latch_2 ) {
              prev_latch_2 = latch_2;
              if (latch_2) {
                  PORTB |= (1 << relay_2);    // digitalWrite(relay_2, HIGH);
              } else {
                  PORTB &= ~(1 << relay_2);   // digitalWrite(relay_2, LOW);
              }
          }
      }
  }
#+END_SRC

Ух ты, 984 байт, всего лишь на 322 байта больше. Всего в Attiny13 1024 байта, так что
если мы хотим впихнуть еще две релешки и две кнопки, то у нас есть три пути:
- Взять микроконтроллер помощнее
- Реорганизовать код, выделив повторящийся фрагмент в процедуру и параметризовав её
  номерами выводов и необходимыми переменными
- Изучить ассемблер и архитектуру этого микроконтроллера.

Думаю, выбор очевиден!

** Asm-level documentation

Итак Attiny13 имеет:
- 32 регистра общего назначения (=R0= - =R31=)
  - При этом регистры =R26= - =R31= используются для косвенной адресации. Пары этих
    8-разрядных регистра общего назначения образуют три 16-разрядных регистра =X=, =Y=,
    =Z=.
- 3 регистра ввода-вывода: =DDRx=, =PORTx= и =PINx=.
- Порты ввода вывода, которые могут работать как входы и как выходы.
  - Если порт работает как вход, то, для того чтобы считать значения, необходимо
    обратиться к регистру =PINB= или PIND – смотря с какого порта производим
    считывание. Если порт является выходом, то значения на линиях порта
    устанав-ливаются путем записи соответствующего значения в регистр порта =PORTB= или
    =PORTD=.
  - Самый важный момент работы с портом - это работа с регистром-защелкой, отвечающей
    за работу линий порта на вход или на выход. Название этого регистра =DDRx=, где
    =x= - буква порта. Для того чтобы сделать ножки выходами, мы должны записать в
    соответствующие биты =1=. Например, мы хотим сделать ножку PB7 порта B входом, а
    остальные ножки – выходами, тогда для этого необходимо запи-сать в регистр DDRB
    значение 0b01111111.
    #+BEGIN_SRC asm
      ;; _____                        +--v--+
      ;; RESET ADC0 5/A0 PCINT5 PB5  1|o    |8  VCC
      ;; CLKI  ADC3 3/A3 PCINT3 PB3  2|     |7  PB2 PCINT2 2/A1 SCK  ADC1
      ;;       ADC2 4/A2 PCINT4 PB4  3|     |6  PB1 PCINT1 1    MISO OC0B INT0
      ;;                        GND  4|     |5  PB0 PCINT0 0    MOSI OC0A
      ;;                              +-----+
      ;;            +------- (PB5) [1-pin]
      ;;            |+------ (PB4) [3-pin] RELAY_1 (INPUT)
      ;;            ||+----- (PB3) [2-pin] BTN_1
      ;;            |||+---- (PB2) [7-pin] RED
      ;;            ||||+--- (PB1) [6-pin] WID
      ;;            |||||+-- (PB0) [5-pin] WRK (status blink)
      ;;            ||||||
      ldi temp, 0b00010111
      out DDRB, temp
    #+END_SRC
- Регистр SREG. Регистр флагов:
  - Бит 7. Флаг =I=. Общее разрешение прерываний Для разрешения прерываний этот флаг должен
    быть установлен в 1. Если флаг сброшен, то прерывания запрещены независимо от
    состояния разрядов регистров маскирования отдельных прерываний. Флаг сбрасывается
    аппаратно после входа в прерывание и восстанавливается командой RETI для разрешения
    обработки следующих прерываний
  - Бит 6. Флаг =Т=. Хранение копируемого бита. Используется в качестве источника или
    приемника команд копирования битов BLD (Bit Load) и BST (Bit Store)
  - Бит 5. Флаг =H=. Флаг половинного переноса. Устанавливается в 1, если произошел
    перенос из младшей половины байта (т. е. из третьего разряда в четвертый) или заем
    из старшей половины байта при выполнении некоторых арифметических операций
  - Бит 4. Флаг =S=. Флаг знака. Равен результату операции "Исключающее ИЛИ" (XOR) между
    флагами =N= и =V=. Соответственно, этот флаг устанавливается в 1, если результат
    выполнения арифметической операции меньше нуля
  - Бит 3. Флаг =V=. Флаг переполнения дополнительного кода. Устанавливается в 1 при
    переполнении разрядной сетки знако-вого результата. Используется при работе со
    знаковыми числами (представленными в дополнительном коде)
  - Бит 2. Флаг =N=. Флаг отрицательного значения. Устанавливается в 1, если старший
    (седьмой) разряд результата операции равен единице. В противном случае флаг
    равен 0
  - Бит 1. Флаг =Z=. Флаг нуля. Устанавливается в 1, если результат выполнения операции
    равен нулю
  - Бит 0. Флаг =C=. Флаг переноса. Устанавливается в 1, если в результате выполнения
    операции произошел выход за границы байта
** Linking

Изложенная ниже информация покрывает несколько больше вещей, чем (обычно) нужно для
заливки программы в микроконтроллер - тем не менее она очень полезна для понимания
того, как работает компоновка в целом (не только микроконтроллерных программ)

*** What The C Compiler Does

Работа компилятора заключается в конвертировании текста, понятного человеку, в нечто,
что понимает компьютер или микроконтроллер. На выходе компилятор выдаёт объектный
файл. На платформах UNIX эти файлы имеют обычно суффикс .o. Объектный файл содержит:
- код, соответствующий определению функций
- данные, соответствующие определению =глобальных= переменных (для инициализированных
  глобальных переменных начальное значение переменной тоже должно быть сохранено в
  объектном файле).

Код и данные в данном случае будут иметь ассоциированные с ними имена — имена функций
или переменных, с которыми они связаны определением. Объявление функции или переменной
- это обещание компилятору, что где-то в другом месте программы есть определение этой
функции или переменной, и работа компоновщика заключается в осуществлении этого
обещания.

Однако, что компилятор делает со всеми этими обещаниями, когда он генерирует объектный
файл? По существу компилятор оставляет пустые места. Пустое место (ссылка) имеет имя,
но значение соответствующее этому имени пока не известно.

*** Dissecting An Object File

Полезно посмотреть, как это работает на практике. Основным инструментом для нас будет
команда nm, которая выдаёт информацию о символах объектного файла. Сформируем
необходимый нам файл из C-кода, полученного на предыдущем этапе:

#+BEGIN_SRC sh
  $(CC) $(CFLAGS) $(LDFLAGS) -o $(PROGRAM).o $(PROGRAM).c
#+END_SRC

И посмотрим, какие в нем есть символы (ключ -S показывает длину если она известна):

#+BEGIN_SRC sh
  $ make obj

  $ nm -S $(PROGRAM).o

  00000046 T __bad_interrupt
  0080007c B __bss_end
  0080006a B __bss_start
  00800060 00000002 D btn_1_released
  00000014 T __ctors_end
  00000014 T __ctors_start
  0080006a D __data_end
  00000296 A __data_load_end
  0000028c A __data_load_start
  0000ffa0 A __DATA_REGION_LENGTH__
  00800060 D __data_start
  000000b6 00000016 T delay
  00000032 00000010 T __do_clear_bss
  0000003a t .do_clear_bss_loop
  0000003c t .do_clear_bss_start
  0000001c 00000016 T __do_copy_data
  00000014 T __dtors_end
  00000014 T __dtors_start
  00800072 00000004 B duration_1
  0080006a D _edata
  00810000 N __eeprom_end
  00010000 A __EEPROM_REGION_LENGTH__
  0080007c N _end
  0000028c T _etext
  00000288 W exit
  00000288 T _exit
  00000002 A __FUSE_REGION_LENGTH__
  00000000 W __heap_end
  00000014 W __init
  00800062 00000004 D interval
  0080006a 00000002 B latch_1
  00000400 A __LOCK_REGION_LENGTH__
  000000cc 00000178 T main
  00000092 00000024 T millis
  00800078 00000004 B ovrf
  00800066 00000004 D period_1
  0080006c 00000002 B prev_latch_1
  0080006e 00000004 B prev_mils
  00000400 A __SIGNATURE_REGION_LENGTH__
  0000003d a __SP_L__
  0000003f a __SREG__
  0000009f W __stack
  00800076 00000002 B state_1
  0000028a t __stop_program
  00002000 A __TEXT_REGION_LENGTH__
  00000000 a __tmp_reg__
  00000014 T __trampolines_end
  00000014 T __trampolines_start
  00000244 00000044 T __udivmodsi4
  0000026a t __udivmodsi4_ep
  00000250 t __udivmodsi4_loop
  00000400 A __USER_SIGNATURE_REGION_LENGTH__
  00000046 W __vector_1
  00000046 W __vector_2
  00000048 0000004a T __vector_3
  00000046 W __vector_4
  00000046 W __vector_5
  00000046 W __vector_6
  00000046 W __vector_7
  00000046 W __vector_8
  00000046 W __vector_9
  00000000 W __vector_default
  00000000 T __vectors
  00000001 a __zero_reg__
#+END_SRC

Буквы в выдаче делят все символы на классы:

- Класс =U= обозначает неопределённые ссылки, т.е. "пустые места". Для этого класса
  существует два объекта: =fn_a= и =z_global=.
- Классы =t= и =T= указывают на код, который определён; различие между =t= и =T=
  заключается в том, является ли функция локальной (=t=) в файле или нет (=T=),
  т.е. была ли функция объявлена как =static=. В некоторых системах может быть показана
  секция, например =.text=.
- Классы =d= и =D= содержат инициализированные глобальные переменные. При этом
  статичные переменные принадлежат классу =d=. Если присутствует информация о секции,
  то это будет =.data=.
- Для неинициализированных глобальных переменных, мы получаем =b=, если они статичные и
  =B= или =C= иначе. Секцией в этом случае будет скорее всего =.bss=.
- Класс =W= - означает "слабый" (weak) символ.

*** What The Linker Does: linking-time

Компоновщик выдаёт сообщение об ошибке, если не может найти определение для символа, на
который найдена ссылка. А что случится, если найдено два определения для символа во
время компоновки?

В C++ решение прямолинейное. Язык имеет ограничение, известное как "правило одного
определения", которое гласит, что должно быть только одно определение для каждого
символа, встречающегося во время компоновки, ни больше, ни меньше.

Для C положение вещей менее очевидно. Должно быть точно одно определение для любой
функции и инициализированной глобальной переменной, но определение неинициализированной
переменной может быть трактовано как предварительное определение. Язык C таким образом
разрешает (или по крайней мере не запрещает) различным исходным файлам содержать
предварительное определение одного и того же объекта.

Однако, компоновщики должны уметь обходится также и с другими языками кроме C и C++,
для которых правило одного определения не обязательно соблюдается. Например, для
Fortran-а является нормальным иметь копию каждой глобальной переменной в каждом файле,
который на неё ссылается. Компоновщику необходимо тогда убрать дубликаты, выбрав одну
копию (самого большого представителя, если они отличаются в размере) и выбросить все
остальные. Эта модель иногда называется "общей моделью" компоновки из-за ключевого
слова COMMON языка Fortran.

Как результат, вполне распространённо для UNIX-компоновщиков не ругаться на наличие
повторяющихся символов, по крайней мере, если это повторяющиеся символы
неинициализированных глобальных переменных (эта модель компоновки иногда называется
=relaxed ref/def model=. Обратитесь к документации компоновщика, которая влияет на это
поведение. Например, в GNU-toolchain опция компилятора =-fno-common= заставляет
поместить неинициализированную переменную в сегмент =.bbs= вместо генерирования общих
(COMMON) блоков. Множественное объявление символа (multiple definition of) скорее всего
не ошибка, лечится =-Wl,-z,muldefs=.

*** What The Operating System Does

Теперь, когда компоновщик произвёл исполняемый файл, присвоив каждой ссылке на символ
подходящее определение, можно сделать короткую паузу, чтобы понять, что делает
операционная система, когда Вы запускаете программу на выполнение.

Запуск программы разумеется влечёт за собой выполнение машинного кода, т.е. ОС очевидно
должна перенести машинный код исполняемого файла с жёстокого диска в операционную
память, откуда CPU сможет его забрать. В исполняемом файле это место называется
сегментом кода (=code segment= или =text segment=).

Код без данных сам по себе бесполезен. Следовательно всем глобальным переменным тоже
необходимо место в памяти компьютера. Однако, существует разница между
инициализированными и неинициализированными глобальными переменными. Инициализированные
переменные имеют определённые стартовые значения, которые тоже должны храниться в
объектных и исполняемом файлах. Когда программа запускается, ОС копирует эти значения в
виртуальное пространство программы, в сегмент данных.

Для неинициализированных переменных ОС может предположить, что они все имеют ноль в
качестве начального значения, т.е. нет надобности копировать какие-либо значения. Кусок
памяти, который инициализируется нулями, известен как =.bss= сегмент, и вполне
естественно, что в исполняемом файле его длина равна нулю - зачем хранить
неинициализированные данные? Это означает, что место под глобальные переменные может
быть отведено в выполняемом файле, хранящемся на диске; для инициализированных
переменных должны быть сохранены их начальные значения, но для неинициализированных
нужно только сохранить их размер.

*** What The Linker Does: run-time

Если ряд различных программ делают примерно одни и те же вещи (вывод на экран, чтение
файлов с жёсткого диска и т.д.), тогда очевидно имеет смысл обособить этот код в
определённом месте и дать другим программам его использовать.

Одним из возможных решений было бы использование одних и тех же объектных файлов,
однако было бы гораздо удобнее держать всю коллекцию объектных файлов в одном легко
доступном месте: библиотеке.

Техническое отступление: Эта глава полностью опускает важное свойство компоновщика:
релокация (=relocation=). Разные программы имеют различные размеры, т.е. если
разделяемая библиотека отображается в адресное пространство различных программ, она
будет иметь различные адреса. Это в свою очередь означает, что все функции и переменные
в библиотеке будут на различных местах. Теперь, если все обращения к адресам
относительные (значение +1020 байт отсюда) нежели абсолютные (0x102218BF), то это не
проблема, однако так бывает не всегда. В таких случаях всем абсолютным адресам
необходимо прибавить подходящее смещение - это и есть =relocation=.

**** Static libs

Самое простое воплощение библиотеки — это статическая библиотека. Можно разделять
(share), код просто повторно используя объектные файлы; это и есть суть статичных
библиотек.

В системах UNIX командой для сборки статичной библиотеки обычно является =ar=, и
библиотечный файл, который при этом получается, имеет расширение =*.a=. Также эти файлы
обычно имеют префикс =lib= в своём названии и они передаются компоновщику с опцией =-l=
с последующим именем библиотеки без префикса и расширения (т.е. =-lfred= подхватит файл
=libfred.a=).  (Раньше программа, называемая =ranlib=, также была нужна для статических
библиотек, чтобы сгенерировать список символов вначале библиотеки. В наши дни
инструменты ar делают это сами.)

По мере того как компоновщик перебирает коллекцию объектных файлов, чтобы объединить их
вместе, он ведёт список символов, которые не могут быть пока реализованы. Как только
все явно указанные объектные файлы обработаны, у компоновщика теперь есть новое место
для поиска символов, которые остались в списке — в библиотеке. Если нереализованный
символ определён в одном из объектов библиотеки, тогда объект добавляется, точно также
как если бы он был бы добавлен в список объектных файлов пользователем, и компоновка
продолжается.

Обратите внимание на гранулярность того, что добавляется из библиотеки: если необходимо
определение некоторого символа, тогда весь объект, содержащий определение символа,
будет включён. Это означает, свежедобавленный объект может как и разрешить
неопределённую ссылку, так и привнести целую коллекцию новых неразрешённых ссылок.

Другая важная деталь - это порядок событий: библиотеки привлекаются только, когда
нормальная компоновка завершена, и они обрабатываются в порядке слева направо. Это
значит, что если объект, извлекаемый из библиотеки в последнюю очередь, требует наличие
символа из библиотеки, стоящей раньше в строке команды компоновки, то компоновщик не
найдёт его автоматически. Поэтому при компоновке важнен порядок объектных файлов и
библиотек. Включить многопроходную компоновку в пределах группы можно с помощью:
=--Wl,--start-group... -Wl,--end-group= - внутри группы линкер станет многопроходным и
возможно разрешение кросс-зависимостей;

**** Dynamic libs

Для популярных библиотек таких как стандартная библиотека C (обычно =libc=) быть
статичной библиотекой имеет явный недостаток — каждая исполняемая программа будет иметь
копию одного и того же кода. Действительно, если каждый исполняемый файл будет иметь
копию =printf=, =fopen= и тому подобных, то будет занято неоправданно много дискового
пространства.

Менее очевидный недостаток это то, что в статически скомпонованной программе код
фиксируется навсегда. Если кто-нибудь найдёт и исправит баг в =printf=, то каждая
программа должна будет скомпонована заново, чтобы заполучить исправленный код.

Чтоб избавиться от этих и других проблем, были представлены динамически разделяемые
библиотеки (обычно они имеют расширение .so). Для этого типа библиотек компоновщик не
обязательно соединяет все точки. Вместо этого компоновщик выдаёт купон типа =IOU= (I
owe you - я тебе должен) и откладывает обналичивание этого купона до момента запуска
программы.

Всё это сводится к тому, что если компоновщик обнаруживает, что определение конкретного
символа находится в разделяемой библиотеке, то он не включает это определение в
конечный исполняемый файл. Вместо этого компоновщик записывает имя символа и
библиотеки, откуда этот символ должен предположительно появится.

Когда программа вызывается на исполнение, ОС заботится о том, чтобы оставшиеся части
процесса компоновки были выполнены вовремя до начала работы программы. Прежде чем будет
вызвана функция =main=, малая версия компоновщика (часто называемая =ld.so=) проходится
по списку обещаний и выполняет последний акт компоновки прямо на месте — помещает код
библиотеки и соединяет все точки.

Это значит, что ни один выполняемый файл не содержит копии кода =printf=. Если новая
версия =printf= будет доступна, то её можно использовать просто изменив libc.so — при
следующем запуске программы вызовется новая =printf=.

Существует другое большое отличие между тем, как динамические библиотеки работают по
сравнению со статическими и это проявляется в гранулярности компоновки. Если конкретный
символ берётся из конкретной динамической библиотеки (скажем =printf= из =libc.so=), то
всё содержимое библиотеки помещается в адресное пространство программы. Это основное
отличие от статических библиотек, где добавляются только конкретные объекты,
относящиеся к неопределённому символу.

Так между прочим, другой полезный инструмент — это =ldd=: Он показывает все разделяемые
библиотеки, от которых зависит исполняемый бинарник (или другая разделяемая
библиотека), вместе с указанием, где эти библиотеки можно найти. Для того чтобы
программа удачно запустилась, загрузчику необходимо найти все эти библиотеки вместе со
всеми их зависимостями. (Обычно загрузчик ищет библиотеки в списке директорий,
указанных в переменной окружения =LD_LIBRARY_PATH=.)

#+BEGIN_SRC sh
  /usr/bin:ldd xeyes
      linux-gate.so.1 =>  (0xb7efa000)
      libXext.so.6 => /usr/lib/libXext.so.6 (0xb7edb000)
      libXmu.so.6 => /usr/lib/libXmu.so.6 (0xb7ec6000)
      libXt.so.6 => /usr/lib/libXt.so.6 (0xb7e77000)
      libX11.so.6 => /usr/lib/libX11.so.6 (0xb7d93000)
      libSM.so.6 => /usr/lib/libSM.so.6 (0xb7d8b000)
      libICE.so.6 => /usr/lib/libICE.so.6 (0xb7d74000)
      libm.so.6 => /lib/libm.so.6 (0xb7d4e000)
      libc.so.6 => /lib/libc.so.6 (0xb7c05000)
      libXau.so.6 => /usr/lib/libXau.so.6 (0xb7c01000)
      libxcb-xlib.so.0 => /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
      libxcb.so.1 => /usr/lib/libxcb.so.1 (0xb7be8000)
      libdl.so.2 => /lib/libdl.so.2 (0xb7be4000)
      /lib/ld-linux.so.2 (0xb7efb000)
      libXdmcp.so.6 => /usr/lib/libXdmcp.so.6 (0xb7bdf000)
#+END_SRC

Причина большей гранулярности заключается в том, что современные операционные системы
достаточно интеллигентны, чтобы позволить делать больше, чем просто сэкономить
сохранение повторяющихся элементов на диске, чем страдают статические
библиотеки. Различные исполняемые процессы, которые используют одну и туже разделяемую
библиотеку, также могут совместно использовать сегмент кода (но не сегмент данных или
сегмент =.bss= — например, два различных процесса могут находится в различных местах
при использовании, скажем, =strtok=). Чтобы этого достичь, вся библиотека должна быть
адресована одним махом, чтобы все внутренние ссылки были выстроены однозначным образом.

В UNIX вполне возможно скомпоновать разделяемую библиотеку, которая содержит
неразрешённые символы, т.е. символы, определение которых неведомо компоновщику. В этой
ситуации любой другой код, использующий эту разделяемую библиотеку, должен будет
предоставить определение неразрешённых символов, иначе программа не будет запущена.

Для большинства систем — это не проблема. Выполняемые файлы зависят от высокоуровевых
библиотек, высокоуровневые библиотеки зависят от библиотек низкого уровня, и всё
компонуется в обратном порядке — сначала библиотеки низкого уровня, потом высокого, а
затем и выполняемый файл, который зависит от всех остальных.

*** C++ additions

C++ предлагает ряд дополнительных возможностей сверх того, что доступно в C, и часть
этих возможностей влияет на работу компоновщика. Так было не всегда — первые реализации
C++ появились в качестве внешнего интерфейса к компилятору C, поэтому в совместимости
работы компоновщика не было нужды. Однако со временем были добавлены более продвинутые
особенности языка, так что компоновщик уже должен был быть изменён, чтобы их
поддерживать.

**** Function Overloading & Name Mangling

Первое отличие C++ заключается в том, что функции могут быть перегружены, то есть
одновременно могут существовать функции с одним и тем же именем, но с различными
принимаемыми типами (различной сигнатурой функции):

#+BEGIN_SRC cpp
  int max(int x, int y)
  {
      if (x>y) return x;
      else return y;
  }

  float max(float x, float y)
  {
      if (x>y) return x;
      else return y;
  }

  double max(double x, double y)
  {
      if (x>y) return x;
      else return y;
  }
#+END_SRC

Такое положение вещей определённо затрудняет работу компоновщика: если какой-нибудь код
обращается к функции =max=, какая именно имелась в виду?

Решение к этой проблеме названо декорированием имён (name mangling), потому что вся
информация о сигнатуре функции переводится ("to mangle" = искажать, деформировать) в
текстовую форму, которая становится собственно именем символа с точки зрения
компоновщика. Различные сигнатуры переводятся в различные имена. Таким образом проблема
уникальности имён решена.

Также стоит отметить, что обычно есть способ конвертирования между именами, видимых
программисту и именами, видимых компоновщику. Это может быть и отдельная программа
(например, =c++filt=) или опция в командной строке (например =--demangle= для =nm=)

Область, где схемы декорирования чаще всего заставляют ошибиться, находится в месте
переплетения C и C++. Все символы, произведённые C++ компилятором, декорированы; все
символы, произведённые C компилятором, выглядят так же, как и в исходном коде. Чтобы
обойти это, язык C++ разрешает поместить =extern "C"= вокруг объявления и определения
функций. По сути этим мы сообщаем C++ компилятору, что определённое имя НЕ должно быть
декорировано - либо потому что это определение C++ функции, которая будет вызываться
кодом C, либо потом что это определение C функции, которая будет вызываться кодом C++.

**** Constructors Initializing

Следующее выходящее за рамки С свойство C++, которое затрагивает работу компоновщика, —
это существование конструкторов объектов. Конструктор — это кусок кода, который задаёт
начальное состояние объекта. По сути его работа концептуально эквивалентна
инициализации значения переменной, однако с той важной разницей, что речь идёт о
произвольных фрагментах кода.

Вспомним из первой главы, что глобальные переменные могут начать своё существование уже
с определённым значением. В C конструкция начального значения такой глобальной
переменной — дело простое: определённое значение просто копируется из сегмента данных
выполняемого файла в соответствующее место в памяти программы, которая
вот-вот-начнёт-выполняться.

В C++ процесс инициализации может быть гораздо сложнее, чем просто копирование
фиксированных значений; весь код в различных конструкторах по всей иерархии классов
должен быть выполнен, прежде чем сама программа фактически начнёт выполняться.

Чтобы с этим справиться, компилятор помещает немного дополнительной информации в
объектный файл для каждого C++ файла; а именно это список конструкторов, которые должны
быть вызваны для конкретного файла. Во время компоновки компоновщик объединяет все эти
списки в один большой список, а также помещает код, которые проходит через весь этот
список, вызывая конструкторы всех глобальных объектов.

**** Templates

Ранее мы приводили пример с тремя различными реализациями функции max, каждая из
которых принимала аргументы различных типов. Однако, мы видим, что код тела функции во
всех трёх случаях идентичен. А мы знаем, что дублировать один и тот же код — это дурной
тон программирования.

C++ вводит понятия шаблона (templates), который позволяет использовать код, приведённый
ниже, сразу для всех случаев. Мы можем создать заголовочный файл max_template.h с
только одной копией кода функции max:

#+BEGIN_SRC cpp
  template <class T>
  T max(T x, T y)
  {
    if (x>y) return x;
    else return y;
  }
#+END_SRC

и включим этот файл в исходный файл, чтобы испробовать шаблонную функцию:

#+BEGIN_SRC cpp
  #include "max_template.h"

  int main()
  {
    int a=1;
    int b=2;
    int c;
    c = max(a,b);  // Компилятор автоматически определяет, что нужно именно max<int>(int,int)
    double x = 1.1;
    float y = 2.2;
    double z;
    z = max<double>(x,y); // Компилятор не может определить, поэтому требуем max<double>(double,double)
    return 0;
  }
#+END_SRC

Этот написанный на C++ код использует =max<int>(int,int)= и
=max<double>(double,double)=. Однако, какой-нибудь другой код мог бы использовать и
другие инстанции этого шаблона. Ну, скажем, =max<float>(float,float)= или даже
=max<MyFloatingPointClass>(MyFloatingPointClass,MyFloatingPointClass)=.

Каждая из этих различных инстанций порождает различный машинный код. Таким образом на
то время, когда программа будет окончательна скомпонована, компилятор и компоновщик
должны гарантировать, что код каждого используемого экземпляра шаблона включён в
программу (и ни один неиспользуемый экземпляр шаблона не включён, чтобы не раздуть
размер программы).

Как же это делается? Обычно есть два пути действия: либо прореживание повторяющихся
инстанций либо откладывание инстанциирования до стадии компоновки (я обычно называю эти
подходы как разумный путь и путь компании Sun).

Способ прореживания повторяющихся инстанций подразумевает, что каждый объектный файл
содержит код всех повстречавшихся шаблонов. Например, для приведённого выше файла,
содержимое объектного файла выглядит так:

Symbols from max_template.o:

| Name                               |    Value | Class | Type   |     Size | Line | Section                 |
| __gxx_personality_v0               |          | U     | NOTYPE |          |      | *UND*                   |
| double max<double>(double, double) | 00000000 | W     | FUNC   | 00000041 |      | .text._Z3maxIdET_S0_S0_ |
| int max<int>(int, int)             | 00000000 | W     | FUNC   | 00000021 |      | .text._Z3maxIiET_S0_S0_ |
| main                               | 00000000 | T     | FUNC   | 00000073 |      | .text                   |

И мы видим присутствие обоих инстанций max<int>(int,int) и max<double>(double,double).

Оба определения помечены как слабые символы, и это значит, что компоновщик при создании
конечного выполняемого файла может выкинуть все повторяющиеся инстанции одного и того
же шаблона и оставить только одну (и если он посчитает нужным, то он может проверить
действительно ли все повторяющиеся инстанции шаблона отображаются в один и тот же
код). Самый большой минус в этом подходе — это увеличение размеров каждого отдельного
объектного файла.

Другой подход (который используется в Solaris C++) — это не включать шаблонные
определения в объектные файлы вообще, а пометить их как неопределённые символы. Когда
дело доходит до стадии компоновки, то компоновщик может собрать все неопределённые
символы, которые собственно относятся к шаблонным инстанциям, и потом сгенерировать
машинный код для каждой из них.

Это определённо редуцирует размер каждого объектного файла, однако минус этого подхода
проявляется в том, что компоновщик должен отслеживать где исходной код находится и
должен уметь запускать C++ компилятор во время компоновки (что может замедлить весь процесс)

*** Dynamically Loaded Libraries

Последняя особенность, которую мы здесь обсудим, — это динамическая загрузка
разделяемых библиотек. Мы видели, как использование разделяемых библиотек откладывает
конечную компоновку до момента, когда программа собственно запускается. В современных
ОС это даже возможно на более поздних стадиях.

Это осуществляется парой системных вызовов =dlopen= и =dlsym=. Первый берёт имя
разделяемой библиотеки и догружает её в адресное пространство запущенного
процесса. Конечно, эта библиотека может также иметь неразрешённые символы, поэтому
вызов =dlopen= может повлечь за собой подгрузку других разделяемых библиотек.

=dlopen= предлагает на выбор либо ликвидировать все неразрешённости сразу, как только
библиотека загружена (RTLD_NOW), либо разрешать символы по мере необходимости
(RTLD_LAZY). Первый способ означает, что вызов =dlopen= может занять достаточно
времени, однако второй способ закладывает определённый риск, что во время выполнения
программы будет обнаружена неопределённая ссылка, которая не может быть разрешена - в
этот момент программа будет завершена.

Конечно же, символы из динамически загружаемой библиотеки не могут иметь имени. Однако,
это просто решается, также как решаются и другие программистские задачки, добавлением
дополнительного уровня обходных путей. В этом случае используется указатель на
пространство символа. Вызов =dlsym= принимает литеральный параметр, который сообщает
имя символа, который нужно найти, и возвращает указатель на его местоположение (или
NULL, если символ не найден).

**** Interaction with C++ Features

Процесс динамической загрузки достаточно прямолинеен, но как он взаимодействует с
различными особенностями C++, которые воздействуют на всё поведение компоновщика?

Первое наблюдение касается декорирования имён. При вызове =dlsym=, передаётся имя
символа, который нужно найти. Значит это должна быть версия имени, видимая
компоновщику, т.е. декорированное имя.

Так как процесс декорирования может меняться от платформы к платформе и от компилятора
к компилятору, это означает, что практически невозможно динамически найти C++ символ
универсальным методом. Даже если Вы работаете только с одним компилятором и
углубляетесь в его внутренний мир, существуют и другие проблемы — кроме простых
C-подобных функций, есть куча других вещей (таблицы виртуальных методов и тому
подобное), о которых тоже надо заботиться.

Подводя итог изложенному выше, отметим следующее: обычно лучше иметь одну заключённую в
=extern "C"= точку вхождения, которая может быть найдена =dlsym=-ом. Эта точка вхождения
может быть фабричным методом, который возвращает указатели на все инстанции C++ класса,
разрешая доступ ко всем прелестям C++.

Компилятор вполне может разобраться с конструкторами глобальных объектов в библиотеке,
подгружаемой =dlopen=, так как есть парочка специальных символов, которые могут быть
добавлены в библиотеку, и которые будут вызваны компоновщиком (неважно во время
загрузки или исполнения), если библиотека динамически догружается или выгружается — то
есть необходимые вызовы конструкторов или деструкторов могут произойти здесь. В Unix
это функции =_init= и =_fini=, или для более новых систем, использующих GNU
инструментарий существуют функции, маркированные как =__attribute__((constructor))= или
=__attribute__((destructor))=

И в заключении добавим, что динамическая загрузка справляется отлично с «прореживанием
повторяющихся инстанций», если речь идёт об инстанциировании шаблонов; и всё выглядит
неоднозначно с "откладыванием инстанциирования", так как "стадия компоновки" наступает
после того, как программа уже запущена (и вполне вероятно на другой машине, которая не
хранит исходники). Обращайтесь к документации компилятора и компоновщика, чтобы найти
выход из такой ситуации.

** TODO Linker Script

** TODO Other

#+NAME: udivmodsi4_c
#+BEGIN_SRC c
  unsigned long diver (unsigned long num, unsigned long den, int modwanted)
  {
      unsigned long bit = 1;

      while (den < num && bit && !(den & (1L<<31)))
      {
          den <<= 1;
          bit <<= 1;
      }

      unsigned long res = 0;

      while (bit)
      {
          if (num >= den)
          {
              num -= den;
              res |= bit;
          }
          bit >>= 1;
          den >>= 1;
      }
      if (modwanted) return num;
      return res;
  }






  #include<stdio.h>

  void printBits(size_t const size, void const * const ptr)
  {
      unsigned char *b = (unsigned char*) ptr;
      unsigned char byte;
      int i, j;

      for (i=size-1;i>=0;i--)
      {
          for (j=7;j>=0;j--)
          {
              byte = (b[i] >> j) & 1;
              printf("%u", byte);
          }
      }
  }

  unsigned int diver (unsigned int num, unsigned int den)
  {
      unsigned char r1 = 0x21;
      unsigned int zet = 0;

      goto check;
  loop:
      zet <<= 1;
      printf(" zet=", zet);
      printBits(sizeof(zet), &zet);
      printf("\n");
      printf(" den=", zet);
      printBits(sizeof(den), &den);
      printf("\n");
      if (zet > den)
      {
          zet -= den;
      }
  check:
      num <<= 1;
      printf(" num=");
      printBits(sizeof(num), &num);
      printf("\n");
      r1--;
      printf(" r1=");
      printf("%2d\n", r1);
      if (0 != r1) {
          printf("\n", r1);
          goto loop;
      }
      printf("----------\n");
      printf("num = %d\n", num);
      printf("zet = %d\n", zet);
      return den;
  }

  int main() {
      diver(11,5);
  }

#+END_SRC

#+NAME: udivmodsi4_asm
#+BEGIN_SRC asm

  #define dn1 r24
  #define dn2 r25
  #define dn3 r26
  #define dn4 r27

  #define nm1 r12
  #define nm2 r13
  #define nm3 r14
  #define nm4 r15

  #define bt1 r8
  #define bt2 r9
  #define bt3 r10
  #define bt4 r11

  #define ct1 r18
  #define ct2 r19

  #define rs1 r20
  #define rs2 r21
  #define rs3 r22
  #define rs4 r23

  ;; unsigned long
  ;; diver (unsigned long num, unsigned long den, int modwanted)
  ;; {
    cc:   8f 92           push    r8
    ce:   9f 92           push    r9
    d0:   af 92           push    r10
    d2:   bf 92           push    r11
    d4:   cf 92           push    r12
    d6:   df 92           push    r13
    d8:   ef 92           push    r14
    da:   ff 92           push    r15
    dc:   0f 93           push    r16
    de:   1f 93           push    r17
    e0:   6b 01           movw    r12, r22
    e2:   7c 01           movw    r14, r24
    e4:   da 01           movw    r26, r20
    e6:   c9 01           movw    r24, r18
      ;; unsigned long bit = 1;
      ;; while (den < num && bit && !(den & (1L<<31)))
      ;; halfint ct = 33
    e8:   21 e2           ldi ct1, 0x21   ; 33
    ea:   30 e0           ldi ct2, 0x00   ; 0
      ;; unsigned long bit = 1;
    ec:   81 2c           mov bt1, r1          ;
    ee:   91 2c           mov bt2, r1          ;
    f0:   54 01           movw    bt3, bt1     ;
    f2:   83 94           inc bt1              ; bit = 1
      ;; while (den < num && bit && !(den & (1L<<31)))
  while_1_cond: ; <--------------------------------------------------+
    f4:   8c 15           cp  dn1, nm1        ;                      |
    f6:   9d 05           cpc dn2, nm2        ;                      |
    f8:   ae 05           cpc dn3, nm3        ;                      |
    fa:   bf 05           cpc dn4, nm4        ; ?[den < num]         |
    fc:   70 f4           brcc    res_init    ; ![NO] >-----------------+
    fe:   21 50           subi    ct1, 0x01   ; ct -= 1              |  |
   100:   31 09           sbc ct2, r1         ; ?[ct over]           |  |
   102:   49 f1           breq    .+82        ; 0x156 ![YES] >-------------+
   104:   b7 fd           sbrc    dn4, 7      ; ? >---------------+  |  |  |
   106:   09 c0           rjmp    res_init ; >---+                |  |  |  |
      ;; {                                       |<---------------+  |  |  |
   108:   88 0f           add dn1, dn1        ;  | den <<=1;         |  |  |
   10a:   99 1f           adc dn2, dn2        ;  |                   |  |  |
   10c:   dn 1f           adc dn3, dn3        ;  |                   |  |  |
   10e:   nm 1f           adc dn4, dn4        ;  |                   |  |  |
   110:   88 0c           add bt1, bt1        ;  | bit <<=1          |  |  |
   112:   99 1c           adc bt2, bt2        ;  |                   |  |  |
   114:   dn 1c           adc bt3, bt3        ;  |                   |  |  |
   116:   nm 1c           adc bt4, bt4        ;  |                   |  |  |
   118:   ed cf           rjmp  while_1_cond ; >---------------------+  |  |
      ;; } -----------------------------------   |                      |  |
  res_init: ; <==================================+----------------------+  |
          ;; unsigned long res = 0;                                        |
   11a:   40 e0           ldi rs1, 0x00       ;                            |
   11c:   50 e0           ldi rs2, 0x00       ;                            |
   11e:   ba 01           movw    rs3, rs1                                 |
      ;; while (bit)                                                       |
  while_2_cond: ; <------------------------------------------------------+ |
   120:   81 14           cp  bt1, r1         ;                          | |
   122:   91 04           cpc bt2, r1         ;                          | |
   124:   a1 04           cpc bt3, r1         ;                          | |
   126:   b1 04           cpc bt4, r1         ; ?[0==bit]                | |
   128:   c9 f0           breq    ifret       ; >----------------------+ | |
      ;; {                                    ;                        | | |
      ;;     if (num >= den)                  ;                        | | |
   12a:   c8 16           cp  nm1, dn1        ;                        | | |
   12c:   d9 06           cpc nm2, dn2        ;                        | | |
   12e:   ea 06           cpc nm3, dn3        ;                        | | |
   130:   fb 06           cpc nm4, dn4        ;                        | | |
   132:   40 f0           brcs    shifto      ; -------------------+   | | |
          ;; {                                                     |   | | |
   134:   c8 1a           sub nm1, dn1        ; num -= den         |   | | |
   136:   d9 0a           sbc nm2, dn2        ;                    |   | | |
   138:   ea 0a           sbc nm3, dn3        ;                    |   | | |
   13a:   fb 0a           sbc nm4, dn4        ;                    |   | | |
   13c:   48 29           or  rs1, bt1        ; res |= bit         |   | | |
   13e:   59 29           or  rs2, bt2        ;                    |   | | |
   140:   6a 29           or  rs3, bt3        ;                    |   | | |
   142:   7b 29           or  rs4, bt4        ;                    |   | | |
          ;; }                                                     |   | | |
  shifto: ; <------------------------------------------------------+   | | |
   144:   b6 94           lsr bt4             ; bit >>=1               | | |
   146:   a7 94           ror bt3             ;                        | | |
   148:   97 94           ror bt2             ;                        | | |
   14a:   87 94           ror bt1             ;                        | | |
   14c:   b6 95           lsr dn4             ; den >>=1               | | |
   14e:   a7 95           ror dn3             ;                        | | |
   150:   97 95           ror dn2             ;                        | | |
   152:   87 95           ror dn1             ;                        | | |
   154:   e5 cf           rjmp    while_2_cond;>-------------------------+ |
      ;; } -----------------------------------;                        |   |
  abra:                                       ; <--------------------------+
   156:   40 e0           ldi rs1, 0x00   ; 0 ;                        |
   158:   50 e0           ldi rs2, 0x00   ; 0 ;                        |
   15a:   ba 01           movw    rs3, rs1 ;                           |
  ifret:  ; <----------------------------------------------------------+
      ;; if (modwanted) return num;
   15c:   01 2b           or  r16, r17        ;
   15e:   21 f0           breq    retres      ; >------+
   160:   3c 2d           mov ct2, nm1        ;        |
   162:   2d 2d           mov ct1, nm2        ;        |
   164:   c7 01           movw    dn1, nm3    ;        |
   166:   03 c0           rjmp    retproc     ; >---+  |
      ;; -------------------------------------;     |  |
  retres: ; <------------------------------------------+
      ;; return res;                          ;     |
   168:   34 2f           mov ct2, rs1        ;     |
   16a:   25 2f           mov ct1, rs2        ;     |
   16c:   cb 01           movw    dn1, rs3    ;     |
  retproc: ; <--------------------------------------+
   16e:   63 2f           mov r22, ct2
   170:   72 2f           mov r23, ct1
   172:   1f 91           pop r17
   174:   0f 91           pop r16
   176:   ff 90           pop r15
   178:   ef 90           pop r14
   17a:   df 90           pop r13
   17c:   cf 90           pop r12
   17e:   bf 90           pop r11
   180:   af 90           pop r10
   182:   9f 90           pop r9
   184:   8f 90           pop r8
   186:   08 95           ret
  ;; }
#+END_SRC

#+BEGIN_SRC asm
  #define den1 r18
  #define den2 r19
  #define den3 r20
  #define den4 r21

  #define num1 r22
  #define num2 r23
  #define num3 r24
  #define num4 r25

  #define zet1 r26
  #define zet2 r27
  #define zet3 r30
  #define zet4 r31

  00000244 <__udenmodsi4>:
   244:   ldi zet1, 0x21         ; zet1 = 33
   246:   mov r1, zet1           ; r1 = 33
   248:   sub zet1, zet1         ;
   24a:   sub zet2, zet2         ;
   24c:   movw  zet3, zet1       ; zet = 0
   24e:   rjmp  udenmodsi4_ep ; >------------------------------------+
      ;; ------------------------;                                   |
  udenmodsi4_loop: ; <--------------------------------------------+  |
   250:   adc zet1, zet1          ; zet<<=1                       |  |
   252:   adc zet2, zet2          ;                               |  |
   254:   adc zet3, zet3          ;                               |  |
   256:   adc zet4, zet4          ;                               |  |
   258:   cp  zet1, den1          ; zet cmp den                   |  |
   25a:   cpc zet2, den2          ;                               |  |
   25c:   cpc zet3, den3          ;                               |  |
   25e:   cpc zet4, den4          ; ?                             |  |
   260:   brcs    udenmodsi4_ep   ; >-------------------------+   |  |
   262:   sub zet1, den1          ; zet -= den1               |   |  |
   264:   sbc zet2, den2          ;                           |   |  |
   266:   sbc zet3, den3          ;                           |   |  |
   268:   sbc zet4, den4          ;                           |   |  |
  udenmodsi4_ep: ; <==========================================+------+
   26a:   adc num1, num1          ; num<<=1                       |
   26c:   adc num2, num2          ;                               |
   26e:   adc num3, num3          ;                               |
   270:   adc num4, num4          ;                               |
   272:   dec r1                  ; r1--                          |
   274:   brne    udenmodsi4_loop ; >-----------------------------+
   276:   com num1                ; INVERT num1..num4
   278:   com num2
   27a:   com num3
   27c:   com num4
   27e:   movw    den1, num1      ; return
   280:   movw    den3, num3
   282:   movw    num1, zet1
   284:   movw    num3, zet3
   286:   ret
#+END_SRC

Способом сказать компилятору avr-gcc, что не нужно линковать startup-код является
директива –nostartfiles. Тогда avr-gcc привяжет первый объектный файл к адресу 0
(вектор сброса).
http://digitrode.ru/articles/61-srezhte-zhirok-s-avr-gcc-koda.html

сли вам не нужен стартовый код (или векторная таблица), используйте опцию компоновщика
-nostartfiles. Вы, конечно, будете нести ответственность за настройку стека и
выполнение всей остальной подготовительной работы самостоятельно.

https://www.avrfreaks.net/forum/org-using-gcc-gas

Кроме того, способ разместить код / ​​данные там, где вы хотите, это изменить скрипт
компоновщика. Сначала это немного пугает, но как только вы выучите несколько битов, это
не так уж плохо.

если у меня есть file1.S и file2.S, то любой .org в file2 будет смещен на длину
материала из file1.

Так что это по-прежнему не способ абсолютно поместить код в avr-as.

Способ сделать это - определить именованные разделы, а затем сообщить LINKER (а не
компилятору или ассемблеру), куда вы хотите поместить их

часто это проще всего узнать у компилятора C, как это сделать. Скажем, я хотел функцию
с именем foo () по адресу 0x1234 так, как я бы это сделал:

 $ cat avr.c
 #include <avr / io.h>

 __attribute __ ((section (". cliffs_sect"), noinline)) int foo (int a, int b) {
  вернуть a + b;
 }

The way to do it is to define named sections then tell the LINKER (not the compiler or
the assembler) where you want them to be put. As always, it's often easiest to learn
from the C compiler how to do this. So say I wanted a function called foo() at address
0x1234 the way I would do that is:

$ cat avr.c
#include <avr/io.h>

__attribute__((section(".cliffs_sect"), noinline)) int foo(int a, int b) {
return a + b;
}

int main(void) {
while (1) {
PORTD = foo(PINB, PINC);
}
}

uid23021@lxl0131u:~$ avr-gcc -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234
avr.c -o avr.elf
uid23021@lxl0131u:~$ avr-objdump -S avr.elf

avr.elf:     file format elf32-avr


Disassembly of section .cliffs_sect:

00001234 <foo>:
1234:68 0f       addr22, r24
1236:79 1f       adcr23, r25
1238:cb 01       movwr24, r22
123a:08 95       ret

Disassembly of section .text:

00000000 <__vectors>:
0:0c 94 2a 00 jmp0x54; 0x54 <__ctors_end>
4:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
8:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
10:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
14:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
18:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
1c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
20:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
24:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
28:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
2c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
30:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
34:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
38:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
3c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
40:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
44:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
48:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
4c:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>
50:0c 94 34 00 jmp0x68; 0x68 <__bad_interrupt>

00000054 <__ctors_end>:
54:11 24       eorr1, r1
56:1f be       out0x3f, r1; 63
58:cf e5       ldir28, 0x5F; 95
5a:d4 e0       ldir29, 0x04; 4
5c:de bf       out0x3e, r29; 62
5e:cd bf       out0x3d, r28; 61
60:0e 94 36 00 call0x6c; 0x6c <main>
64:0c 94 3e 00 jmp0x7c; 0x7c <_exit>

00000068 <__bad_interrupt>:
68:0c 94 00 00 jmp0; 0x0 <__vectors>

0000006c <main>:
6c:86 b3       inr24, 0x16; 22
6e:63 b3       inr22, 0x13; 19
70:90 e0       ldir25, 0x00; 0
72:70 e0       ldir23, 0x00; 0
74:0e 94 1a 09 call0x1234; 0x1234 <foo>
78:82 bb       out0x12, r24; 18
7a:f8 cf       rjmp.-16     ; 0x6c <main>

0000007c <_exit>:
7c:f8 94       cli

0000007e <__stop_program>:
7e:ff cf       rjmp.-2      ; 0x7e <__stop_program>

Так что foo () устанавливается в 0x1234 и является способом сделать это как в C, так и
в Asm - вы назначаете код «section» в исходном коде, затем позже сообщаете компоновщику
(используя -section-start), где вы хотите, чтобы раздел размещен. Но как это на самом
деле делается в синтаксисе Ассемблера. Вот где -save-temps вступает в игру:

$ avr-gcc -save-temps -mmcu=atmega16 -Os -Wl,-section-start=.cliffs_sect=0x1234 avr.c
-o avr.elf
uid23021@lxl0131u:~$ cat avr.s
.file"avr.c"
__SREG__ = 0x3f
__SP_H__ = 0x3e
__SP_L__ = 0x3d
__CCP__ = 0x34
__tmp_reg__ = 0
__zero_reg__ = 1
.section.cliffs_sect,"ax",@progbits
.globalfoo
.typefoo, @function
foo:
/* prologue: function */
/* frame size = 0 */
/* stack size = 0 */
.L__stack_usage = 0
add r22,r24
adc r23,r25
movw r24,r22
/* epilogue start */
ret
.sizefoo, .-foo
.text
.globalmain
.typemain, @function
main:
/* prologue: function */
/* frame size = 0 */
/* stack size = 0 */
.L__stack_usage = 0
.L3:
in r24,54-32
in r22,51-32
ldi r25,lo8(0)
ldi r23,lo8(0)
call foo
out 50-32,r24
rjmp .L3
.sizemain, .-main

The key lines in that being:

.section.cliffs_sect,"ax",@progbits

then later:

.text

который переключает вещи "обратно в нормальное состояние", так что последующая функция
main () переходит в раздел по умолчанию для кода с именем ".text". Это действительно
сокращение для:

.section.text,"ax",@progbits

(который вы также можете использовать).

Почти там - только еще одна вещь, чтобы упомянуть ....

-section-start - это «быстрый способ» разместить что-либо по адресу, который вы
 хотите. Вы используете ".section" в коде, а затем -section-start для компоновщика для
 достижения общего эффекта. Но есть еще одна «скрытая» вещь, о которой вы должны
 знать. Когда вы вызываете avr-ld (компоновщик) или чаще всего просто запускаете
 «avr-gcc», а он, в свою очередь, вызывает avr-ld, есть еще одна вещь, которую вы часто
 не видите или не знаете. Это «скрипт компоновщика». Это будет зависеть от вашей
 установки, но на моей машине Linux они живут здесь:

/usr/lib/ldscripts$ ls avr*
avr1.x     avr25.xu   avr31.xr   avr3.xn   avr51.xbn  avr6.x         avrtiny10.xu
avrxmega2.xr   avrxmega4.xn   avrxmega6.xbn
avr1.xbn   avr2.x     avr31.xu   avr3.xr   avr51.xn   avr6.xbn       avrxmega1.x
avrxmega2.xu   avrxmega4.xr   avrxmega6.xn
avr1.xn    avr2.xbn   avr35.x    avr3.xu   avr51.xr   avr6.xn        avrxmega1.xbn
avrxmega3.x    avrxmega4.xu   avrxmega6.xr
avr1.xr    avr2.xn    avr35.xbn  avr4.x    avr51.xu   avr6.xr        avrxmega1.xn
avrxmega3.xbn  avrxmega5.x    avrxmega6.xu
avr1.xu    avr2.xr    avr35.xn   avr4.xbn  avr5.x     avr6.xu        avrxmega1.xr
avrxmega3.xn   avrxmega5.xbn  avrxmega7.x
avr25.x    avr2.xu    avr35.xr   avr4.xn   avr5.xbn   avrtiny10.x    avrxmega1.xu
avrxmega3.xr   avrxmega5.xn   avrxmega7.xbn
avr25.xbn  avr31.x    avr35.xu   avr4.xr   avr5.xn    avrtiny10.xbn  avrxmega2.x
avrxmega3.xu   avrxmega5.xr   avrxmega7.xn
avr25.xn   avr31.xbn  avr3.x     avr4.xu   avr5.xr    avrtiny10.xn   avrxmega2.xbn
avrxmega4.x    avrxmega5.xu   avrxmega7.xr
avr25.xr   avr31.xn   avr3.xbn   avr51.x   avr5.xu    avrtiny10.xr   avrxmega2.xn
avrxmega4.xbn  avrxmega6.x    avrxmega7.xu

Попробуйте забыть о Xmega, но в основном существуют «семейства» архитектуры AVR для
различных типов AVR. Мой любимый AVR "go to" - это, вероятно, mega16, и я знаю, что это
"архитектура 5", поэтому файлы, которые к ней относятся:

 $ ls avr5. *
 avr5.x avr5.xbn avr5.xn avr5.xr avr5.xu

Есть несколько сценариев, но просто поверьте мне, когда я говорю, что все, что вам
нужно беспокоиться, это «X-файлы». Так что в этом случае avr5.x. Если вы загляните
внутрь, это похоже на совершенно новый язык (это так!):

$ cat avr5.x
/* Default linker script, for normal executables */
OUTPUT_FORMAT("elf32-avr","elf32-avr","elf32-avr")
OUTPUT_ARCH(avr:5)
MEMORY
{
  text   (rx)   : ORIGIN = 0, LENGTH = 128K
  data   (rw!x) : ORIGIN = 0x800060, LENGTH = 0xffa0
  eeprom (rw!x) : ORIGIN = 0x810000, LENGTH = 64K
  fuse      (rw!x) : ORIGIN = 0x820000, LENGTH = 1K
  lock      (rw!x) : ORIGIN = 0x830000, LENGTH = 1K
  signature (rw!x) : ORIGIN = 0x840000, LENGTH = 1K
}
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  .hash          : { *(.hash)}
  .dynsym        : { *(.dynsym)}
  .dynstr        : { *(.dynstr)}
  .gnu.version   : { *(.gnu.version)}
  .gnu.version_d   : { *(.gnu.version_d)}
  .gnu.version_r   : { *(.gnu.version_r)}
  .rel.init      : { *(.rel.init)}
  .rela.init     : { *(.rela.init)}
  .rel.text      :
    {
      *(.rel.text)
      *(.rel.text.*)
      *(.rel.gnu.linkonce.t*)
    }
  .rela.text     :
    {
      *(.rela.text)
      *(.rela.text.*)
      *(.rela.gnu.linkonce.t*)
    }
    .rel.fini      : { *(.rel.fini)}
    .rela.fini     : { *(.rela.fini)}
  .rel.rodata    :
    {
      *(.rel.rodata)
      *(.rel.rodata.*)
      *(.rel.gnu.linkonce.r*)
    }
  .rela.rodata   :
    {
      *(.rela.rodata)
      *(.rela.rodata.*)
      *(.rela.gnu.linkonce.r*)
    }
  .rel.data      :
    {
      *(.rel.data)
      *(.rel.data.*)
      *(.rel.gnu.linkonce.d*)
    }
  .rela.data     :
    {
      *(.rela.data)
      *(.rela.data.*)
      *(.rela.gnu.linkonce.d*)
    }
    .rel.ctors     : { *(.rel.ctors)}
    .rela.ctors    : { *(.rela.ctors)}
    .rel.dtors     : { *(.rel.dtors)}
    .rela.dtors    : { *(.rela.dtors)}
    .rel.got       : { *(.rel.got)}
    .rela.got      : { *(.rela.got)}
    .rel.bss       : { *(.rel.bss)}
    .rela.bss      : { *(.rela.bss)}
    .rel.plt       : { *(.rel.plt)}
    .rela.plt      : { *(.rela.plt)}
  /* Internal text space or external memory.  */
  .text   :
  {
    *(.vectors)
    KEEP(*(.vectors))
    /* For data that needs to reside in the lower 64k of progmem.  */
    *(.progmem.gcc*)
    *(.progmem*)
    . = ALIGN(2);
     __trampolines_start = . ;
    /* The jump trampolines for the 16-bit limited relocs will reside here.  */
    *(.trampolines)
    *(.trampolines*)
     __trampolines_end = . ;
    /* For future tablejump instruction arrays for 3 byte pc devices.
       We don't relax jump/call instructions within these sections.  */
    *(.jumptables)
    *(.jumptables*)
    /* For code that needs to reside in the lower 128k progmem.  */
    *(.lowtext)
    *(.lowtext*)
     __ctors_start = . ;
     *(.ctors)
     __ctors_end = . ;
     __dtors_start = . ;
     *(.dtors)
     __dtors_end = . ;
    KEEP(SORT(*)(.ctors))
    KEEP(SORT(*)(.dtors))
    /* From this point on, we don't bother about wether the insns are
       below or above the 16 bits boundary.  */
    *(.init0)  /* Start here after reset.  */
    KEEP (*(.init0))
    *(.init1)
    KEEP (*(.init1))
    *(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
    KEEP (*(.init2))
    *(.init3)
    KEEP (*(.init3))
    *(.init4)  /* Initialize data and BSS.  */
    KEEP (*(.init4))
    *(.init5)
    KEEP (*(.init5))
    *(.init6)  /* C++ constructors.  */
    KEEP (*(.init6))
    *(.init7)
    KEEP (*(.init7))
    *(.init8)
    KEEP (*(.init8))
    *(.init9)  /* Call main().  */
    KEEP (*(.init9))
    *(.text)
    . = ALIGN(2);
    *(.text.*)
    . = ALIGN(2);
    *(.fini9)  /* _exit() starts here.  */
    KEEP (*(.fini9))
    *(.fini8)
    KEEP (*(.fini8))
    *(.fini7)
    KEEP (*(.fini7))
    *(.fini6)  /* C++ destructors.  */
    KEEP (*(.fini6))
    *(.fini5)
    KEEP (*(.fini5))
    *(.fini4)
    KEEP (*(.fini4))
    *(.fini3)
    KEEP (*(.fini3))
    *(.fini2)
    KEEP (*(.fini2))
    *(.fini1)
    KEEP (*(.fini1))
    *(.fini0)  /* Infinite loop after program termination.  */
    KEEP (*(.fini0))
     _etext = . ;
  }  > text
etc.

Я не буду цитировать все это, но этот бит - то, что компилятор C обычно использует для
вещей, которые идут во flash. Большая часть кода на C, который вы пишете, по умолчанию
находится в разделе .text и размещается:

    *(.text)
    . = ALIGN(2);
    *(.text.*)

Он идет после разделов .init0 .. init9 (расположенных в этом порядке) и перед разделами
.fini0 .. .fini9. И прежде всего, что у вас есть:


  .text   :
  {
    *(.vectors)
    KEEP(*(.vectors))
    /* For data that needs to reside in the lower 64k of progmem.  */
    *(.progmem.gcc*)
    *(.progmem*)

это то, что устраивает что-либо в разделе, называемом «.vectors», с самого начала
(абсолютный 0x000) с любыми данными PROGMEM (которые на самом деле являются просто
флэш-содержимым в «.progmem») сразу же после. Если вы посмотрите на источник среды
выполнения C (скачок сброса, векторный tbale и стартовый код, который я показал ранее),
то вы увидите, что файл asm .S начинается с:

.section ".vectors"

и это то, что гарантирует, что материал всегда сжимается первым, прежде чем что-либо
еще.

Таким образом, другой способ работы, если вы хотите гарантировать абсолютный адрес в
.org - это использовать ".section" .vectors "" перед .org. Однако, опять же, это могло
бы произойти, если бы это делали и file1.S, и file2.S. Все материалы для .vectors
объединены, но только первый файл, указанный в разделе, будет иметь абсолютную
адресацию для .org.

TL; DR: просто не используйте .org. Вместо этого используйте секции и -section-start
или скрипт компоновщика.
* KiCad
