#+STARTUP: showall indent hidestars
#+TOC: headlines 3

#+TITLE: Выключатель с задержкой выключения

* Intro

Мы хотим собрать устройство, которое может служить таймером выключения света в
туалете/ванной комнате, предотвращая ситуацию "забыли выключить".

Это учебно-тестовый проект, в котором на примере простой схемы выключателя с задержкой
выключения можно пройти все этапы проектирования электронного устройства на
микроконтроллере.

Требуется собрать устройство, управляемое кнопкой по следующему алгоритму:
- В состоянии "выключено" нажатие кнопки приводит к включению нагрузки и переходу в
  состояние "включено"
- В состоянии "включено" нажатие кнопки приводит к выключению нагрузки и переходу в
  состояние "выключено"
- В состоянии "включено" через заданное в программе время устройство самостоятельно
  выключает нагрузку и переходит в состояние "выключено"

* Prototyping

Для прототипирования воспользуемся =Arduino Uno= и модулем расширения =Relay Shield=.

В ОС Ubuntu 16.04 установим =Arduino IDE 1.8.9= с сайта https://www.arduino.cc скачав
архив, распаковав его и запустив в терминале =./install.sh=

** Blinking for relay

Чтобы проверить работоспособность платы и модуля расширения, загрузим следующий скетч:

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int relay_2 = 5;
  const int relay_3 = 6;
  const int relay_4 = 7;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(relay_2, OUTPUT);
      pinMode(relay_3, OUTPUT);
      pinMode(relay_4, OUTPUT);
  }

  void loop()  {
      digitalWrite(relay_1,HIGH);
      delay(500);
      digitalWrite(relay_1,LOW);
      delay(500);

      digitalWrite(relay_2,HIGH);
      delay(500);
      digitalWrite(relay_2,LOW);
      delay(500);

      digitalWrite(relay_3,HIGH);
      delay(500);
      digitalWrite(relay_3,LOW);
      delay(500);

      digitalWrite(relay_4,HIGH);
      delay(500);
      digitalWrite(relay_4,LOW);
      delay(500);
  }
#+END_SRC

Чтобы загрузить этот скетч мне понадобилось разрешить доступ к порту следующей
командой:

#+BEGIN_SRC sh
  sudo chmod a+rw /dev/ttyACM0
#+END_SRC

или добавить текущего пользователя в группу которой это разрешено

#+BEGIN_SRC sh
  sudo usermod -a -G dialout $USER
#+END_SRC

** Button

Теперь нам потребуется подключить кнопку на 8 (восьмой) вывод. Резистор на 100 Ом
подтягивает его к земле, когда кнопка не нажата:

[TODO:gmm] - [pic] delay_switch_bb.png

#+BEGIN_SRC c
  const int relay_1 = 4;
  const int btn_1 = 8;

  int State_1 = 0;

  void setup()  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1, INPUT);
  }

  void loop()  {
      State_1 = digitalRead(btn_1);

      if (State_1) {
          digitalWrite(relay_1,HIGH);
      } else {
          digitalWrite(relay_1,LOW);
      }
  }
#+END_SRC

В этом скетче =relay_1= срабатывает, когда кнопка нажата.

[TODO:gmm] - [video]

** Delay

Здесь я напишу код, который решает нашу задачу, т.е. формирует задержку
выключения. Чтобы "есть слона по кускам" я создам шаблон скетча, в который буду
вставлять куски кода, которые следуют далее. Этот шаблон включает пару глобальных
констант, начальную инициализацию =setup= и placeholder-ы для переменных и содержимого
внутреннего цикла:

#+BEGIN_SRC c :tangle delay_switch.c :noweb tangle :exports code :padline no
  const int btn_1 = 8;
  const int relay_1 = 4;

  <<vars>>

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      <<btn_handler>>
  }
#+END_SRC

*** Events of press and release

Когда кнопка нажата, скетч получает информацию об этом, считывая уровень сигнала со
входа, но нам нужно нечто большее: мы хотим отслеживать событие, которое происходит,
когда кнопка нажимается. Чтобы получить это событие нам нужно хранить предыдущее
значение нажатости кнопки и обновлять его после каждого считывания
состояния. Интересующие нас событие происходит тогда, когда предыдущее состояние
нажатости отличается от того что мы считали с вывода.

По причинам, которые станут очевидными далее, я назову предыдущее состояние нажатости
кнопки =btn_1_released= (по-умолчанию - =true=). Это первая из наших глобальных
переменных. Ее имя может намекнуть, что я бы, возможно, хотел управлять более чем одним
реле.

#+NAME: vars
#+BEGIN_SRC c
  boolean btn_1_released = true;
#+END_SRC

Тогда в каждом цикле мы можем отслеживать интересующие нас события нажатия и отпускания
кнопки:

#+NAME: btn_handler
#+BEGIN_SRC c
  <<begin_loop>>

  if (HIGH == digitalRead(btn_1)) {
      if (btn_1_released) {
          btn_1_released = false;
          delay(100);
          Serial.println("btn_pressed");
          <<on_btn_press>>
      }
      <<btn_pressed>>
  } else {
      if (!btn_1_released) {
          Serial.println("btn_1_released");
          delay(100);
          btn_1_released = true;
          <<on_btn_release>>
      }
      <<btn_1_released>>
  }

  <<end_loop>>
#+END_SRC

Delay на 0.1 секунды здесь нужен чтобы избавиться от "дребезга контактов".

*** State

Теперь нам понадобится состояние, которое я назвал =state_1=. Оно показывает, хотим ли мы
высокий или низкий уровень сигнала на выходе.

#+NAME: vars
#+BEGIN_SRC c
  boolean state_1 = LOW;
#+END_SRC

Реакция на событие =нажатия= кнопки обрабатывается в зависимости от текущего значения
=state_1=. Если мы "включаемся", то должны установить задержку =duration_1=, а если мы
"выключаемся", то задержку можно явно обнулить:

#+NAME: vars
#+BEGIN_SRC c
  long duration_1 = 0;
#+END_SRC

#+NAME: on_btn_press
#+BEGIN_SRC c
  if (HIGH == state_1) {
      Serial.println("switch off, state_1 = LOW");
      state_1 = LOW;
      duration_1 = 0;
  } else {
      Serial.println("switch on, state_1 = HIGH");
      state_1 = HIGH;
      duration_1 = period_1;
  }
#+END_SRC

Здесь мы используем переменную =cur_mils=, которую инициализируем в начале каждого
цикла:

#+NAME: begin_loop
#+BEGIN_SRC c
  unsigned long cur_mils = millis();
#+END_SRC

Нам также потребуется размер задержки, который мы сохраним в переменную =period_1=:

#+NAME: vars
#+BEGIN_SRC c
  const long period_1 = 4000;
#+END_SRC

Иногда я люблю полежать в ванне, так что, если мне потребуется более длинная задержка,
чем, например для туалетной комнаты, я смогу сделать =period_2= и получить желаемое.

*** Out of duration

Теперь будем обрабатывать тот момент, когда задержка истекает. Очевидно, что мы дожны
проверять истекла ли она, только когда находимся в состоянии =HIGH=. Мы также не хотим
проверять чаще чем один раз в какой-то =interval= времени, допустим секунду:

#+NAME: vars
#+BEGIN_SRC c
  const long interval = 1000;
#+END_SRC

Чтобы не проверять слишком часто, мы будем запоминать время последней проверки в
переменной =prev_mils=:

#+NAME: vars
#+BEGIN_SRC c
  unsigned long prev_mils = 0;
#+END_SRC

Таким образом вычитая из текущего времени =cur-mils= время последней проверки
=prev-mils=, мы узнаем сколько времени прошло с момента последней проверки. Если это
время меньше чем =interval= то проверять не надо:

#+BEGIN_SRC c
  if (state_1 == HIGH) {
      unsigned long last_time = cur_mils - prev_mils;
      if (last_time >= interval) {
          prev_mils = cur_mils;
          ...
      }
  }
#+END_SRC

Внимание, в этом коде возможна ошибка, когда происходит переполнение! На нашей
платформе unsigned long - это четырехбайтовое значение, которое будет переполняться
каждые 49.7102696181 дней, если отсчитывать с момента включения микроконтроллера.

В момент переполнения =cur-mils= оказывается много меньше =prev-mils=, и если мы явным
образом не обработаем такую ситуацию, то включенное состояние сохранится значительно
дольше чем ожидалось (вероятно, почти 50 дней), потому что дальнейшие действия внутри
условия (last_time>=interval) не будут выполнены, и задержка не будет снята, а
состояние не переключится.

Чтобы этого не произошло, обнаружив переполнение, мы запишем в =prev-mils= значение
=cur-mils=, таким образом =cur-mils= тоже "перескочит через ноль". А следующая проверка
отработает штатно, т.к. переполнения уже не будет. Ошибка увеличения задержки на этой
операции не будет превышать одного =interval=-а, что вполне приемлимо для нашей задачи.

#+NAME: check_duration
#+BEGIN_SRC c
  if (state_1 == HIGH) {
      if (cur_mils < prev_mils) {
          prev_mils = cur_mils;
      } else {
          unsigned long last_time = cur_mils - prev_mils;
          if ( last_time >= interval ) {
              Serial.print("last_time = "); Serial.println(last_time);
              prev_mils = cur_mils;
              <<duration_decrement>>
          }
      }
  }
#+END_SRC

Если после детекта переполнения цикл =loop= будет выполнен быстрее чем за одну
микросекунду, то на следующем цикле проверка cur_mils < prev_mils не вернет =true=, и
управление получит ветка =else=. Тогда =last_time= будет вычислен в ноль и будет в
любом случае меньше чем =interval=, поэтому дальше все тоже пойдет штатно.

*** Decrementing duration

Теперь мы можем перейти к рассчету, насколько надо уменьшить =duration_1= и не пора ли
перейти в состояние =LOW=. Будем вычитать из =duration_1= значение =interval= пока
=duration_1= не станет отрицательным:

#+NAME: duration_decrement
#+BEGIN_SRC c
  long decremented = duration_1 - interval;
  if ( decremented < 0 ) {
      state_1 = LOW;
      Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
  } else {
      duration_1 = decremented;
      Serial.print("duration_1 = ");
      Serial.println(decremented);
  }
#+END_SRC

Я помещаю логику задержки =check_duration= внутрь блока =btn_1_released=, т.к. так
удобнее анализивать отладочный вывод.

#+NAME: btn_1_released
#+BEGIN_SRC c
  <<check_duration>>
#+END_SRC

*** Latch and output

Теперь можно явным образом обеспечить изменение уровня сигнала на входе реле. Для того
чтобы "дергать за ногу" только когда есть необходимость, я заведу две переменные:

#+NAME: vars
#+BEGIN_SRC c
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;
#+END_SRC

Соответствующий код опять же использует тот же паттерн, что и =state_1=, для определения
события изменения значения:

#+NAME: end_loop
#+BEGIN_SRC c
  latch_1 = state_1;
  if ( latch_1 != prev_latch_1 ) {
      prev_latch_1 = latch_1;
      digitalWrite(relay_1, latch_1);
      Serial.print("=> "); Serial.println(latch_1);
  }
#+END_SRC

** Arduino-решение

Скетч, который у нас получился:

#+BEGIN_SRC c
  const int btn_1 = 8;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      Serial.begin(9600);
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              Serial.println("btn_pressed");
              if (HIGH == state_1) {
                  Serial.println("switch off, state_1 = LOW");
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  Serial.println("switch on, state_1 = HIGH");
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              Serial.println("btn_1_released");
              delay(100);
              btn_1_released = true;

          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      Serial.print("last_time = "); Serial.println(last_time);
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                          Serial.println("millis() >= duration_1 (is over);\n state_1 = LOW;");
                      } else {
                          duration_1 = decremented;
                          Serial.print("duration_1 = ");
                          Serial.println(decremented);
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
          Serial.print("=> "); Serial.println(latch_1);
      }
  }
#+END_SRC

* Upload to Attiny13

После успешной отладке на Arduino-прототипе можно приступить к программированию
микроконтроллера. Я выбрал для реализации младший в линейке микроконтроллеров Atmega -
=Attiny13= в DIP-корпусе.

** Arduino Core for Attiny13

Проверим, как написанный ранее код будет работать на Attiny13. Для этого нам
потребуется ядро Arduino для Attiny13, которое можно взять на
https://github.com/orlv/at13

Файлы из него следует положить по файловому пути, который можно подсмотреть в меню File ->
Preferences -> Sketchbook location, добавив к нему "/hardware". По умолчанию у меня это
"~/Arduino/hardware/". После перезапуска Arduino IDE в списке плат появится Attiny13.

Теперь мы должны сделать из Arduino внутрисхемный программатор (InterSchematic
Programmer) для нашей Attiny13. Для этого нужно загрузить в нее скетч =ArduinoISP=, он
находится в меню File -> Examples -> ArduinoISP. Перед загрузкой возможно придется
сделать:

#+BEGIN_SRC sh
  sudo chmod 777 /dev/ttyUSB0
#+END_SRC

Чтобы лишний раз не разбирать бутерброд из Arduino Uno и Arduino Relay Shield, я
заливал программатор в удачно нашедшуюся плату Freeduino, поэтому мне пришлось в меню
Tools выставить:
- Processor: atmega328P
- Board: Arduino Diecimila or Duemilanove

[TODO:gmm] Подключение Attiny13 к выводам Arduino
[TODO:gmm] Замыкаем резистором 100 Ом GND и VCC ардуины, чтобы избежать ее сброса

После успешной заливки скетча ArduinoISP идем в ArduinoIDE и меняем тип программатора в
Tools -> Programmer на =Arduino as ISP=

Потом выбираем в Tools -> Board значение =Attiny13=

И определяем частоту работы Tools -> Frequency значением в =1.2 MHz=, которая
соответствует заводским предустановкам

Изменения будут записаны во фьюз биты после нажатия Tools -> Burn bootloader

Теперь можно залить в Attiny13 полученный нами код. Но перед этим придется удалить из
него отладочный вывод и переназначить вывод =bnt_1=, так как шестиногая микросхема
attiny13 не имеет вывода номер восемь, который мы раньше использовали как вход кнопки.

#+NAME: arduino_sketch_for_attiny13
#+BEGIN_SRC c
  const int btn_1 = 3;
  const int relay_1 = 4;

  boolean btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  void setup()
  {
      pinMode(relay_1, OUTPUT);
      pinMode(btn_1,INPUT);
  }

  void loop()
  {
      unsigned long cur_mils = millis();

      if (HIGH == digitalRead(btn_1)) {
          if (btn_1_released) {
              btn_1_released = false;
              delay(100);
              if (HIGH == state_1) {
                  state_1 = LOW;
                  duration_1 = 0;
              } else {
                  state_1 = HIGH;
                  duration_1 = period_1;
              }
          }

      } else {
          if (!btn_1_released) {
              delay(100);
              btn_1_released = true;
          }
          if (state_1 == HIGH) {
              if (cur_mils < prev_mils) {
                  prev_mils = cur_mils;
              } else {
                  unsigned long last_time = cur_mils - prev_mils;
                  if ( last_time >= interval ) {
                      prev_mils = cur_mils;
                      long decremented = duration_1 - interval;
                      if ( decremented < 0 ) {
                          state_1 = LOW;
                      } else {
                          duration_1 = decremented;
                      }
                  }
              }
          }
      }

      latch_1 = state_1;
      if ( latch_1 != prev_latch_1 ) {
          prev_latch_1 = latch_1;
          digitalWrite(relay_1, latch_1);
      }
  }
#+END_SRC

После заливки Arduino IDE сообщает, что:
- Sketch uses 794 bytes (77%) of program storage space. Maximum is 1024 bytes.
- Global variables use 17 bytes of dynamic memory.

Это конечно многовато, особенно если учесть, что в типичных квартирах выключатели
обычно группируются по две (ванная и туалет) или даже четыре (если добавить кухню и
прихожую). Тем не менее все работает:

[TODO:gmm] - video

** C-level

Наша маленькая программа едва влезла в килобайт памяти Attiny13, что может расстроить,
потому что у нас остается еще 4 свободных вывода, что могло бы позволить управлять с
одного микроконтроллера тремя выключателями с задержкой, а не одним.

Правда, один из этих свободных выводов - RESET, и чтобы использовать его нужны
некоторые ухищрения, описанные тут (https://habr.com/ru/post/110894/).

В попытке уменьшить размер программы и получить больший контроль над RESET, мы можем
отказаться от заливки в микроконтроллер Arduino Core и спуститься на уровень ниже,
запрограммировав микроконтроллер на языке Си. А все необходимые для этого вещи мы
сможем подсмотреть в том же Arduino Core.

Но сначала нам надо посмотреть, что конкретно делает Arduino IDE, когда компилирует и
заливает программу в микроконтроллер. Это можно сделать, установив в File ->
Preferences галочки "Show verbose output during compilation & upload"

Теперь при загрузке скетча мы можем получить довольно много информации о том, что
происходит "под капотом". А происходит компиляция и линковка файлов, а потом заливка на
микроконтроллер. Все это Arduino IDE делает своими силами, но мы будем делать старым
дедовским способом - через =Makefile=:

#+NAME: Makefile
#+BEGIN_SRC sh
  ARDUINO_PATH = /home/${USER}/build/arduino-1.8.9
  PROJECT_PATH = ./
  AVRTOOLS_PATH = hardware/tools/avr
  PROGRAM = delay_switch3
  MCU = attiny13
  CC = $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avr-gcc
  OBJCOPY = avr-objcopy
  CFLAGS += -Wall -g -Os -mmcu=$(MCU) -I$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/avr/include
  LDFLAGS +=
  OBJS = $(PROGRAM).o

  all: $(PROGRAM).hex

  $(PROGRAM).elf: $(PROGRAM).o
      $(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

  $(PROGRAM).hex: $(PROGRAM).elf
      $(Q)$(OBJCOPY) -O ihex $< $@

  %.o: %.c
      $(Q)$(CC) $(CFLAGS) -o $@ -c $<

  flash: $(PROGRAM).hex
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:w:$(PROJECT_PATH)/$(PROGRAM).hex:i

  clean:
      $(Q)rm -f $(OBJS)
      $(Q)rm -f *.elf
      $(Q)rm -f *.hex

  objdump:
      avr-objdump -dS $(PROGRAM).elf > $(PROGRAM).asm

  extract:
      $(ARDUINO_PATH)/$(AVRTOOLS_PATH)/bin/avrdude \
      -C$(ARDUINO_PATH)/$(AVRTOOLS_PATH)/etc/avrdude.conf \
      -v               \
      -pattiny13       \
      -carduino        \
      -P/dev/ttyUSB0   \
      -b19200 \
      -Uflash:r:$(PROJECT_PATH)/$(PROGRAM).bin:r

  disasm:
      avrdisas -a1 -o1 -s1 $(PROJECT_PATH)/$(PROGRAM).bin
#+END_SRC

Если вы будете использовать этот Makefile убедитесь, что табуляции в начале строк не
заменены на пробелы, потому что для Makefile они значимы.

Теперь будем менять код, чтобы компилятор Си смог его прожевать.

Для начала я перенес все константы в define. Чтобы сделать задержку, которая
предотвращает "дребезг контактов" я скопировал из Arduino Core функцию =delay=.

Потом я нашел в Arduino Core функцию =millis=, но оказалось, что она зависит от
переменной =ovrf=. Эта переменная инкрементируется каждый раз, когда приходит
прерывание от таймера, поэтому мне пришлось добавить саму переменную и процедуру
обработки прерывания (она начинается с =ISR=).

Также мне потребовалось скопировать в начало =main= процедуру инициализации таймера, в
которой я даже не стал пока разбираться - и после этого я смог заставить этот сишный
код работать:

#+NAME: c_code
#+BEGIN_SRC c :tangle delay_switch2.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3
  #define relay_1 PB4

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  const long interval = 1000;
  unsigned long prev_mils = 0;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif

      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1)) // if (digitalRead(bnt_1) == HIGH)
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }
      }
  }
#+END_SRC

Этот код уже весит 662 байта (а не 794 как предыдущий), что дает нам право на попытку
поуправлять одновременно двумя релешками и двумя кнопками. Я просто скопировал
управляющий код и изменил необходимые имена переменных:

#+NAME: c_code_with_2_ctrls
#+BEGIN_SRC c :tangle delay_switch3.c :noweb tangle :exports code :padline no
  // 1.2 MHz (default) built in resonator
  #define F_CPU 1200000UL
  #define boolean int
  #define true 1
  #define HIGH 1
  #define false 0
  #define LOW 0

  #define btn_1 PB3 // pin2
  #define relay_1 PB4 // pin3

  #define btn_2 PB2 // pin7
  #define relay_2 PB1 //pin6

  #include <avr/io.h>
  #include <util/delay.h>
  #include <avr/interrupt.h>

  volatile unsigned long ovrf=0;
  ISR(TIM0_OVF_vect){
      ovrf++; //Increment counter every 256 clock cycles
  }

  unsigned long millis(){
      unsigned long x;
      asm("cli");
      /*Scale number of timer overflows to milliseconds*/
  #if F_CPU < 150000 && F_CPU > 80000
      x = ovrf * 2;
  #elif F_CPU == 600000
      x = ovrf / 2;
  #elif F_CPU == 1000000
      x = ovrf / 4;
  #elif F_CPU == 1200000
      x = ovrf / 5;
  #elif F_CPU == 4000000
      x = ovrf / 16;
  #elif F_CPU == 4800000
      x = ovrf / 19;
  #elif F_CPU == 8000000
      x = ovrf / 31;
  #elif F_CPU == 9600000
      x = ovrf / 37;
  #elif F_CPU == 10000000
      x = ovrf / 39;
  #elif F_CPU == 12000000
      x = ovrf / 47;
  #elif F_CPU == 16000000
      x = ovrf / 63;
  #else
  #error This CPU frequency is not defined
  #endif
      asm("sei");
      return x;
  }

  void delay(unsigned ms) {
      while(ms--){
          _delay_ms(1);
          //Using the libc routine over and over is non-optimal but it works and is close enough
      } //Note, I may have to reimplement this because the avr-libc delay is too slow *todo*
  }

  const long interval = 1000;
  unsigned long prev_mils = 0;

  int btn_1_released = true;
  boolean state_1 = LOW;
  long duration_1 = 0;
  const long period_1 = 4000;
  boolean prev_latch_1 = LOW;
  boolean latch_1 = LOW;

  int btn_2_released = true;
  boolean state_2 = LOW;
  long duration_2 = 0;
  const long period_2 = 4000;
  boolean prev_latch_2 = LOW;
  boolean latch_2 = LOW;


  int main()
  {
      //Setup timer interrupt and PWM pins
      TCCR0B |= _BV(CS00);
      TCCR0A |= _BV(WGM00)|_BV(WGM01);
      TIMSK0 |= 2;
      TCNT0=0;
      sei();
      ADMUX=0;
      //Set up ADC clock depending on F_CPU
  #if F_CPU <= 200000
      ADCSRA |= _BV(ADEN);
  #elif F_CPU <= 1200000 && F_CPU > 200000
      ADCSRA |= _BV(ADEN) | _BV(ADPS1);
  #elif F_CPU > 1200000 && F_CPU < 6400001
      ADCSRA |= _BV(ADEN) | _BV(ADPS2);
  #else
      ADCSRA |= _BV(ADEN) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADPS2);
  #endif


      DDRB |=  (1 << relay_1);    // pinMode(relay_1, OUTPUT);
      DDRB &= ~(1 << btn_1);      // pinMode(btn_1, INPUT);

      while (1)
      {
          unsigned long cur_mils = millis();

          if(PINB & (1 << btn_1))
          {
              if (btn_1_released) {
                  btn_1_released = false;
                  delay(100);
                  if (HIGH == state_1) {
                      state_1 = LOW;
                      duration_1 = 0;
                  } else {
                      state_1 = HIGH;
                      duration_1 = period_1;
                  }
              }

          } else {
              if (!btn_1_released) {
                  delay(100);
                  btn_1_released = true;
              }
              if (state_1 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_1 - interval;
                          if ( decremented < 0 ) {
                              state_1 = LOW;
                          } else {
                              duration_1 = decremented;
                          }
                      }
                  }
              }
          }

          latch_1 = state_1;
          if ( latch_1 != prev_latch_1 ) {
              prev_latch_1 = latch_1;
              if (latch_1) {
                  PORTB |= (1 << relay_1);    // digitalWrite(relay_1, HIGH);
              } else {
                  PORTB &= ~(1 << relay_1);   // digitalWrite(relay_1, LOW);
              }
          }


          if(PINB & (1 << btn_2))
          {
              if (btn_2_released) {
                  btn_2_released = false;
                  delay(100);
                  if (HIGH == state_2) {
                      state_2 = LOW;
                      duration_2 = 0;
                  } else {
                      state_2 = HIGH;
                      duration_2 = period_2;
                  }
              }

          } else {
              if (!btn_2_released) {
                  delay(100);
                  btn_2_released = true;
              }
              if (state_2 == HIGH) {
                  if (cur_mils < prev_mils) {
                      prev_mils = cur_mils;
                  } else {
                      unsigned long last_time = cur_mils - prev_mils;
                      if ( last_time >= interval ) {
                          prev_mils = cur_mils;
                          long decremented = duration_2 - interval;
                          if ( decremented < 0 ) {
                              state_2 = LOW;
                          } else {
                              duration_2 = decremented;
                          }
                      }
                  }
              }
          }

          latch_2 = state_2;
          if ( latch_2 != prev_latch_2 ) {
              prev_latch_2 = latch_2;
              if (latch_2) {
                  PORTB |= (1 << relay_2);    // digitalWrite(relay_2, HIGH);
              } else {
                  PORTB &= ~(1 << relay_2);   // digitalWrite(relay_2, LOW);
              }
          }
      }
  }
#+END_SRC

Ух ты, 984 байт, всего лишь на 322 байта больше. Всего в Attiny13 1024 байта, так что
если мы хотим впихнуть еще две релешки и две кнопки, то у нас есть три пути:
- Взять микроконтроллер помощнее
- Реорганизовать код, выделив повторящийся фрагмент в процедуру и параметризовав её
  номерами выводов и необходимыми переменными
- Изучить ассемблер и архитектуру этого микроконтроллера.

Думаю, выбор очевиден!
** Asm-level

Итак Attiny13 имеет:
- 32 регистра общего назначения (=R0= - =R31=)
  - При этом регистры =R26= - =R31= используются для косвенной адресации. Пары этих
    8-разрядных регистра общего назначения образуют три 16-разрядных регистра =X=, =Y=,
    =Z=.
- 3 регистра ввода-вывода: =DDRx=, =PORTx= и =PINx=.
- Порты ввода вывода, которые могут работать как входы и как выходы.
  - Если порт работает как вход, то, для того чтобы считать значения, необходимо
    обратиться к регистру =PINB= или PIND – смотря с какого порта производим
    считывание. Если порт является выходом, то значения на линиях порта
    устанав-ливаются путем записи соответствующего значения в регистр порта =PORTB= или
    =PORTD=.
  - Самый важный момент работы с портом - это работа с регистром-защелкой, отвечающей
    за работу линий порта на вход или на выход. Название этого регистра =DDRx=, где
    =x= - буква порта. Для того чтобы сделать ножки выходами, мы должны записать в
    соответствующие биты =1=. Например, мы хотим сделать ножку PB7 порта B входом, а
    остальные ножки – выходами, тогда для этого необходимо запи-сать в регистр DDRB
    значение 0b01111111.
- Регистр SREG. Регистр флагов:
  - Бит 7. Флаг =I=. Общее разрешение прерываний Для разрешения прерываний этот флаг должен
    быть установлен в 1. Если флаг сброшен, то прерывания запрещены независимо от
    состояния разрядов регистров маскирования отдельных прерываний. Флаг сбрасывается
    аппаратно после входа в прерывание и восстанавливается командой RETI для разрешения
    обработки следующих прерываний
  - Бит 6. Флаг =Т=. Хранение копируемого бита. Используется в качестве источника или
    приемника команд копирования битов BLD (Bit Load) и BST (Bit Store)
  - Бит 5. Флаг =H=. Флаг половинного переноса. Устанавливается в 1, если произошел
    перенос из младшей половины байта (т. е. из третьего разряда в четвертый) или заем
    из старшей половины байта при выполнении некоторых арифметических операций
  - Бит 4. Флаг =S=. Флаг знака. Равен результату операции "Исключающее ИЛИ" (XOR) между
    флагами =N= и =V=. Соответственно, этот флаг устанавливается в 1, если результат
    выполнения арифметической операции меньше нуля
  - Бит 3. Флаг =V=. Флаг переполнения дополнительного кода. Устанавливается в 1 при
    переполнении разрядной сетки знако-вого результата. Используется при работе со
    знаковыми числами (представленными в дополнительном коде)
  - Бит 2. Флаг =N=. Флаг отрицательного значения. Устанавливается в 1, если старший
    (седьмой) разряд результата операции равен единице. В противном случае флаг
    равен 0
  - Бит 1. Флаг =Z=. Флаг нуля. Устанавливается в 1, если результат выполнения операции
    равен нулю
  - Бит 0. Флаг =C=. Флаг переноса. Устанавливается в 1, если в результате выполнения
    операции произошел выход за границы байта
