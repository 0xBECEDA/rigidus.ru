* First

book: purely functuonal data structures

#+BEGIN_SRC lisp
  (defun evcond (lst env)
    (cond ((null lst)                     nil)
          ((myeval (car (car lst)) env)   (myeval (car (cdr (car lst))) env))
          (t                              (evcond (cdr lst) env))))

  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2)) alist)
          ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
          (t (cons (cons (car lst1) (car lst2)) (mypairlis (cdr lst1) (cdr lst2) alist)))))

                                          ;(defun mypairlis (lst1 lst2 alist)
                                          ;  (cond ((and (null lst1) (null lst2)) alist)
                                          ;        ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
                                          ;        (t (mypairlis (cdr lst1) (cdr lst2) (cons (cons (car lst1) (car lst2)) alist)))))

  (defun evlis (lst env)
    (cond ((null lst) nil)
          (t (cons (myeval (car lst) env) (evlis (cdr lst) env)))))

  (defun evprogn (lst env)
    (cond ((null lst) nil)
          ((null (cdr lst)) (myeval (car lst) env))
          (t (myeval (car lst) env)
             (evprogn (cdr lst) env))))

  (defun evletstar (varpairs exp env)
    (cond ((null varpairs) (myeval exp env))
          (t (evletstar (cdr varpairs)
                        exp
                        (cons (cons (car (car varpairs))
                                    (myeval (car (cdr (car varpairs))) env))
                              env)))))

  (defun myeval (lst env)
    (cond ((numberp lst)                    lst)
          ((symbolp lst)                    (cdr (assoc lst env)))
          ((equal (car lst) '+)             (+ (myeval (cadr lst) env)
                                               (myeval (caddr lst) env)))
          ((equal (car lst) '*)             (* (myeval (cadr lst) env)
                                               (myeval (caddr lst) env)))
          ((equal (car lst) 'quote)         (cadr lst))
          ((equal (car lst) 'car)           (car (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'cdr)           (cdr (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'cons)          (cons (myeval (car (cdr lst)) env) (myeval (car (cddr lst)) env)))
          ((equal (car lst) 'null)          (null (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'if)            (if (myeval (car (cdr lst)) env)
                                                (myeval (car (cdr (cdr lst))) env)
                                                (myeval (car (cdr (cdr (cdr lst)))) env)))
          ((equal (car lst) 'cond)          (evcond (cdr lst) env))
          ((equal (car lst) 'let)           (evprogn (cdr (cdr lst)) ; implicit progn
                                                     (pairlis (mapcar #'car  (car (cdr lst)))
                                                              (evlis (mapcar #'cadr (car (cdr lst)))
                                                                     env)
                                                              env)))
          ((equal (car lst) 'progn)          (evprogn (cdr lst) env))
          ((equal (car lst) 'print)          (print (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'let*)           (evletstar (car (cdr lst))
                                                        (car (cdr (cdr lst)))
                                                        env))
          ((equal (car (car lst)) 'lambda)   (myeval (car (cddr (car lst)))
                                                     (pairlis (car (cdr (car lst)))
                                                              (evlis (cdr lst) env)
                                                              env)))
          ))


  (print (myeval '(car (quote (1 2 3))) nil))

  (print (myeval '(cond ((null '()) 42) (42 666)) nil))

  (print (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))) ;; -> (( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))

  (print (myeval '((lambda (x y) (+ x y)) 42 13) nil))

  (print (evlis '((+ 1 2) (* 2 3) 42) nil)) ; -> (3 6 42)

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (cons x y))
                 nil))

  (print (myeval '(progn (print (+ 1 4))
                   2)
                 nil))

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (print x)
                   (print y)
                   (cons x y))
                 nil))

  (print (myeval '(let* ((x 42) (y x))
                   y)
                 nil))
#+END_SRC

#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun evcond (lst env)
    (cond ((null lst)                     nil)
          ((myeval (car (car lst)) env)   (myeval (car (cdr (car lst))) env))
          (t                              (evcond (cdr lst) env))))

  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2)) alist)
          ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
          (t (cons (cons (car lst1) (car lst2)) (mypairlis (cdr lst1) (cdr lst2) alist)))))

                                          ;(defun mypairlis (lst1 lst2 alist)
                                          ;  (cond ((and (null lst1) (null lst2)) alist)
                                          ;        ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
                                          ;        (t (mypairlis (cdr lst1) (cdr lst2) (cons (cons (car lst1) (car lst2)) alist)))))

  (defun evlis (lst env)
    (cond ((null lst) nil)
          (t (cons (myeval (car lst) env) (evlis (cdr lst) env)))))

  (defun evprogn (lst env)
    (cond ((null lst) nil)
          ((null (cdr lst)) (myeval (car lst) env))
          (t (myeval (car lst) env)
             (evprogn (cdr lst) env))))

  (defun evletstar (varpairs exp env)
    (cond ((null varpairs) (myeval exp env))
          (t (evletstar (cdr varpairs)
                        exp
                        (cons (cons (car (car varpairs))
                                    (myeval (car (cdr (car varpairs))) env))
                              env)))))

  (defun myapply (fn args env)
    (cond ((equal fn '+)             (+ (car args) (cadr args)))
          ((equal fn '*)             (* (car args) (cadr args)))
          ((equal fn 'car)           (car (car args)))
          ((equal fn 'cdr)           (cdr (car args)))
          ((equal fn 'cons)          (cons (car args) (car (cdr args))))
          ((equal fn 'null)          (null (car args)))
          ((symbolp fn)              (let ((it (lookup fn env)))
                                       (if (null it)
                                           (error (format nil "fn-404: ~A" fn))
                                           (myapply (cdr it) args env))))
          ((equal (car fn) 'lambda)  (myeval (car (cddr fn))
                                             (pairlis (car (cdr fn))
                                                      args
                                                      env)))))

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))

  (defun myeval (lst env)
    (cond ((numberp lst)                    lst)
          ((symbolp lst)                    (cdr (lookup lst env)))
          ((equal (car lst) 'quote)         (cadr lst))
          ((equal (car lst) 'if)            (if (myeval (car (cdr lst)) env)
                                                (myeval (car (cdr (cdr lst))) env)
                                                (myeval (car (cdr (cdr (cdr lst)))) env)))
          ((equal (car lst) 'cond)          (evcond (cdr lst) env))
          ((equal (car lst) 'let)           (evprogn (cdr (cdr lst)) ; implicit progn
                                                     (pairlis (mapcar #'car  (car (cdr lst)))
                                                              (evlis (mapcar #'cadr (car (cdr lst)))
                                                                     env)
                                                              env)))
          ((equal (car lst) 'progn)         (evprogn (cdr lst) env))
          ((equal (car lst) 'print)         (print (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'let*)          (evletstar (car (cdr lst))
                                                       (car (cdr (cdr lst)))
                                                       env))
          ((equal (car lst) 'defun)         (progn
                                              (push (cons (cadr lst)
                                                          `(lambda ,(caddr lst)
                                                             ,(cadddr lst)))
                                                    ,*glob-env*)
                                              (cadr lst)))
          ((equal (car lst) 'setq)          (let ((it (lookup (cadr lst) env))
                                                  (val (myeval (caddr lst) env)))
                                              (if (null it)
                                                  (push (cons (cadr lst) val)
                                                        ,*glob-env*)
                                                  (rplacd it val))
                                              val))
          ((equal (car lst) 'lambda)        lst)
          (t                                (myapply (car lst) (evlis (cdr lst) env) env))))

  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))

  (print (myeval '(car (quote (1 2 3))) nil))

  (print (myeval '(cond ((null '()) 42) (42 666)) nil))

  (print (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77))))
  ;; -> (( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))

  (print (myeval '((lambda (x y) (+ x y)) 42 13) nil))

  (print (evlis '((+ 1 2) (* 2 3) 42) nil)) ; -> (3 6 42)

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (cons x y))
                 nil))

  (print (myeval '(progn (print (+ 1 4))
                   2)
                 nil))

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (print x)
                   (print y)
                   (cons x y))
                 nil))

  (print (myeval '(let* ((x 42) (y x))
                   y)
                 nil))

  (repl)
#+END_SRC

#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defstruct closure
    body
    env
    args)

  (defun evcond (lst env)
    (cond ((null lst)                     nil)
          ((myeval (car (car lst)) env)   (myeval (car (cdr (car lst))) env))
          (t                              (evcond (cdr lst) env))))

  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2)) alist)
          ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
          (t (cons (cons (car lst1) (car lst2)) (mypairlis (cdr lst1) (cdr lst2) alist)))))

                                          ;(defun mypairlis (lst1 lst2 alist)
                                          ;  (cond ((and (null lst1) (null lst2)) alist)
                                          ;        ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
                                          ;        (t (mypairlis (cdr lst1) (cdr lst2) (cons (cons (car lst1) (car lst2)) alist)))))

  (defun evlis (lst env)
    (cond ((null lst) nil)
          (t (cons (myeval (car lst) env) (evlis (cdr lst) env)))))

  (defun evprogn (lst env)
    (cond ((null lst) nil)
          ((null (cdr lst)) (myeval (car lst) env))
          (t (myeval (car lst) env)
             (evprogn (cdr lst) env))))

  (defun evletstar (varpairs exp env)
    (cond ((null varpairs) (myeval exp env))
          (t (evletstar (cdr varpairs)
                        exp
                        (cons (cons (car (car varpairs))
                                    (myeval (car (cdr (car varpairs))) env))
                              env)))))

  (defun myapply (fn args)
    (cond ((equal fn '+)             (+ (car args) (cadr args)))
          ((equal fn '*)             (* (car args) (cadr args)))
          ((equal fn 'car)           (car (car args)))
          ((equal fn 'cdr)           (cdr (car args)))
          ((equal fn 'cons)          (cons (car args) (car (cdr args))))
          ((equal fn 'null)          (null (car args)))
          ((closure-p fn)            (myeval (closure-body fn)
                                             (pairlis (closure-args fn)
                                                      args
                                                      (closure-env fn))))))

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))

  (defun myeval (lst env)
    (cond ((numberp lst)                    lst)
          ((member lst
                   '(+ * car cdr cons null))        lst)
          ((symbolp lst)                    (cdr (lookup lst env)))
          ((equal (car lst) 'quote)         (cadr lst))
          ((equal (car lst) 'if)            (if (myeval (car (cdr lst)) env)
                                                (myeval (car (cdr (cdr lst))) env)
                                                (myeval (car (cdr (cdr (cdr lst)))) env)))
          ((equal (car lst) 'cond)          (evcond (cdr lst) env))
          ((equal (car lst) 'let)           (evprogn (cdr (cdr lst)) ; implicit progn
                                                     (pairlis (mapcar #'car  (car (cdr lst)))
                                                              (evlis (mapcar #'cadr (car (cdr lst)))
                                                                     env)
                                                              env)))
          ((equal (car lst) 'progn)         (evprogn (cdr lst) env))
          ((equal (car lst) 'print)         (print (myeval (car (cdr lst)) env)))
          ((equal (car lst) 'let*)          (evletstar (car (cdr lst))
                                                       (car (cdr (cdr lst)))
                                                       env))
          ((equal (car lst) 'defun)         (progn
                                              (push (cons (cadr lst)
                                                          (make-closure :body (cadddr lst) :env env :args (caddr lst)))
                                                    ,*glob-env*)
                                              (cadr lst)))
          ((equal (car lst) 'setq)          (let ((it (lookup (cadr lst) env))
                                                  (val (myeval (caddr lst) env)))
                                              (if (null it)
                                                  (push (cons (cadr lst) val)
                                                        ,*glob-env*)
                                                  (rplacd it val))
                                              val))
          ((equal (car lst) 'lambda)        (make-closure :body (caddr lst) :env env :args (cadr lst)))
          (t                                (myapply (myeval (car lst) env)
                                                     (evlis (cdr lst) env)))))

  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))

  (print (myeval '(car (quote (1 2 3))) nil))

  (print (myeval '(cond ((null '()) 42) (42 666)) nil))

  (print (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77))))
  ;; -> (( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))

  (print (myeval '((lambda (x y) (+ x y)) 42 13) nil))

  (print (evlis '((+ 1 2) (* 2 3) 42) nil)) ; -> (3 6 42)

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (cons x y))
                 nil))

  (print (myeval '(progn (print (+ 1 4))
                   2)
                 nil))

  (print (myeval '(let ((x (+ 1 2))
                        (y 42))
                   (print x)
                   (print y)
                   (cons x y))
                 nil))

  (print (myeval '(let* ((x 42) (y x))
                   y)
                 nil))

  (repl)
#+END_SRC

Dynamic scope - переменные видны из места вызова функции
Static scop - из места создания функции

CPS преобразование, чтобы не было нехвостовых вызовов

обработка ошибока

block/return catch/trow

defunctionalization VM

trampolines (sec-машина) - избавление от рекурсии, можно реализовать в форт

secd-машина

#+BEGIN_SRC lisp :tangle hello5.lisp
  ;; test function ok
  (defun ok (x)
    (format t "~%ok: ~A" x)
    x)

  ;; test function ok
  (defun err (x)
    (format t "~%err: ~A" x)
    x)


  ;; base assoc
  (defun assoc-1 (key alist)
    (cond ((null alist) nil)
          ((equal key (caar alist)) (car alist))
          (t (assoc-1 key (cdr alist)))))

  ;; semipredicate problem
  (defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of continuations (for lookup comfort)
    (cond ((null alist)              (funcall errcont key))
          ((equal key (caar alist))  (funcall cont    (cdar alist)))
          (t                         (assoc-2 key (cdr alist) cont errcont))))

  ;; test assoc-2
  (assert (equal "ok:123"
                 (assoc-2 'alfa '((alfa . 123)) (lambda (x) (format nil "ok:~A" x)) (lambda (x) (format nil "err:~A" x)))))
  (assert (equal "err:ALFA"
                 (assoc-2 'alfa '((beta . 123)) (lambda (x) (format nil "ok:~A" x)) (lambda (x) (format nil "err:~A" x)))))


  ;; lookup
  (defun lookup (symb env errcont cont)
    (assoc-2 symb env cont
             (lambda (key)
               (assoc-2 key *glob-env* cont
                        (lambda (key)
                          (funcall errcont (format nil "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                                   key env *glob-env*)))))))

  ;; test lookup
  (assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                  (lambda (x) (format nil "err:~A" x))
                                  (lambda (x) (format nil "ok:~A" x)))))
  (assert (equal nil      (lookup 'aaa '((bbb . 123))
                                  (lambda (x) (declare (ignore x)) nil)
                                  (lambda (x) (format nil "ok:~A" x)))))


  ;; global environment
  (defparameter *glob-env* nil)

  ;; closure struct
  (defstruct closure
    body
    env
    args)


  ;; evcond
  (defun evcond (exp env errcont cont)
    (cond ((null exp)  (funcall cont nil))
          (t           (myeval (caar exp) env errcont
                               (lambda (x)
                                 (if x
                                     (myeval (cadar exp) env errcont cont)
                                     (evcond (cdr exp)   env errcont cont)))))))

  ;; tests for envcond
  (assert (equal 2 (evcond '((t 2) (t 1)) nil #'err #'ok)))
  (assert (equal 1 (evcond '((nil 2) (t 1)) nil #'err #'ok)))
  (assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))


  ;; mypairlis
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2)) alist)
          ((or  (null lst1) (null lst2)) (error 'mypairlis-error))
          (t (cons (cons (car lst1) (car lst2)) (mypairlis (cdr lst1) (cdr lst2) alist)))))


  ;; менее эффективный но более понятный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn evaled errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn (cdr unevaled) (append evaled (list x)) env errcont cont))))))


  ;; более эффективный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn (cdr unevaled) (cons x evaled) env errcont cont))))))

  ;; test for evlis
  (assert (equal 4 (evlis '+ '(1 (+ 1 2)) nil nil #'err #'ok)))


  ;; evprogn
  (defun evprogn (lst env errcont cont)
    (cond ((null lst)         (funcall cont nil))
          ((null (cdr lst))   (myeval (car lst) env errcont cont))
          (t                  (myeval (car lst) env errcont
                                      (lambda (x)
                                        (evprogn (cdr lst) env errcont cont))))))

  ;; test for evprogn
  (assert (equal 2 (evprogn '(1 2) nil #'err #'ok)))


  ;; evletstar
  (defun evletstar (varpairs exp env errcont cont)
    (cond ((null varpairs)  (evprogn exp env errcont cont))
          (t                (myeval (cadar varpairs) env errcont
                                    (lambda (x)
                                      (evletstar (cdr varpairs) exp
                                                 (acons (caar varpairs) x env)
                                                 errcont cont))))))

  ;; test for evletstar
  (assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))


  ;; evlet
  (defun evlet (vars exps evald-exps exp env errcont cont)
    (cond ((null exps)  (evprogn exp
                                 (pairlis vars (reverse evald-exps) env)
                                 errcont cont))
          (t            (myeval (car exps) env errcont
                                (lambda (x)
                                  (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))

  ;; test for evlet
  (assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))





  (defmacro foo (a b) `(* (+ ,a ,b) (+ ,a ,a)))

  (let ((target (macro-function 'or)))
    (if (compiled-function-p target)
        (disassemble target)
        (function-lambda-expression target)))

  (defmacro -or (&optional first &rest rest)
    (if (null rest)
        first
        (let ((g (gensym)))
          `(let ((,g ,first))
             (if ,g
                 ,g
                 (-or ,@rest))))))

  (defmacro or* (&body body)
    (cond ((null body)       'nil)
          ((null (cdrbody))  (car body))
          (t                 (let ((temp (gensym)))
                               `(let ((,temp ,(carbody)))
                                  (if ,temp ,temp
                                      (or* ,@(cdrbody))))))))

  ;; (or* a b) expands into
  ;; (let ((#:g24 a))
  ;;   (if #:g24 #:g24 b))


  (defmacro -and (&rest args)
    (cond ((null args)  t)
          ((cdr args)   `(if ,(car args) (-and ,@(cdr args))))
          (t            (car args))))


  (defmacro and* (a b)
    `(let ((temp2 ,b) (temp1 ,a))
       (if (not temp1) nil
           (if (not temp2) nil temp2))))


  ;; myapply
  (defun myapply (fn args errcont cont)
    (cond ((equal fn '+)             (funcall cont (+ (car args) (cadr args))))
          ((equal fn '*)             (funcall cont (* (car args) (cadr args))))
          ((equal fn 'car)           (funcall cont (car (car args))))
          ((equal fn 'cdr)           (funcall cont (cdr (car args))))
          ((equal fn 'cons)          (funcall cont (cons (car args) (car (cdr args)))))
          ((equal fn 'null)          (funcall cont (null (car args))))
          ((equal fn 'print)         (funcall cont (print (car args))))
          ((equal fn 'or)            (funcall cont (or  (car args) (cadr args))))
          ((equal fn 'and)           (funcall cont (and (car args) (cadr args))))
          ((closure-p fn)            (myeval (closure-body fn)
                                             (pairlis (closure-args fn)
                                                      args
                                                      (closure-env fn))
                                             errcont
                                             cont))))

  ;; myeval
  (defun myeval (exp env errcont cont)
    (cond ((numberp exp)                    (funcall cont exp))
          ((member exp '(+ * car cdr cons null print or and))
                                            (funcall cont exp))
          ((equal 't exp)                   (funcall cont 't))
          ((equal 'nil exp)                 (funcall cont 'nil))
          ((symbolp exp)                    (lookup exp env errcont cont))
          ((equal (car exp) 'quote)         (funcall cont (cadr exp)))
          ((equal (car exp) 'if)            (myeval (cadr exp) env errcont
                                                    (lambda (x)
                                                      (if x
                                                          (myeval (caddr exp)  env errcont cont)
                                                          (myeval (cadddr exp) env errcont cont)))))
          ((equal (car exp) 'cond)          (funcall cont (evcond (cdr exp) env errcont cont))) ; ?
          ((equal (car exp) 'let)           (evlet (mapcar #'car (cadr exp))
                                                   (mapcar #'cadr (cadr exp))
                                                   nil
                                                   (cddr exp)
                                                   env
                                                   errcont
                                                   cont))
          ((equal (car exp) 'progn)         (evprogn (cdr exp) env errcont cont))
          ((equal (car exp) 'let*)          (evletstar (cadr exp)
                                                       (cddr exp)
                                                       env
                                                       errcont cont))
          ((equal (car exp) 'defun)         (progn
                                              (push (cons (cadr exp)
                                                          (make-closure :body (cadddr exp) :env env :args (caddr exp)))
                                                    ,*glob-env*)
                                              (funcall cont (cadr exp))))
          ((equal (car exp) 'setq)          (myeval (caddr exp) env errcont
                                                    (lambda (val)
                                                      (let ((it (lookup (cadr exp) env errcont cont)))
                                                        (if (null it)
                                                            (push (cons (cadr exp) val)
                                                                  ,*glob-env*)
                                                            (rplacd it val))
                                                        (funcall cont val)))))
          ((equal (car exp) 'lambda)        (funcall cont (make-closure :body (caddr exp) :env env :args (cadr exp))))
          (t                                (myeval (car exp) env errcont
                                                    (lambda (x)
                                                      (evlis  x  (cdr exp) nil env errcont cont))))))

  ;; test number eval
  (assert (equal 123 (myeval 123 nil #'err #'ok)))

  ;; test autoreferenced functions
  (assert (equal '+ (myeval '+  nil #'err #'ok)))

  ;; test booleans
  (assert (equal 't   (myeval 't    nil #'err #'ok)))
  (assert (equal 'nil (myeval 'nil  nil #'err #'ok)))

  ;; test lookup symbols in local environment
  (assert (equal nil (myeval 'alfa  nil              (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
  (assert (equal 345 (myeval 'alfa  '((alfa . 345))  #'err                                      #'ok)))
  ;; test lookup symbols in global environment
  (let ((*glob-env* '((alfa . 111))))
    (assert (equal 111 (myeval 'alfa  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
    (assert (equal nil (myeval 'beta  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok))))

  ;; test quote
  (assert (equal 'zzz (myeval '(quote zzz)  nil #'err #'ok)))

  ;; test if
  (assert (equal 1 (myeval '(if t 1 2)  nil #'err #'ok)))
  (assert (equal 2 (myeval '(if nil 1 2)  nil #'err #'ok)))


  (assert (equal 1 (myeval '(car (quote (1 2 3))) nil #'err #'ok)))
  (assert (equal 42 (myeval '(cond ((null '()) 42) (42 666)) nil #'err #'ok)))
  (assert (equal 55 (myeval '((lambda (x y) (+ x y)) 42 13) nil #'err #'ok)))
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (cons x y))
                                    nil #'err #'ok)))
  (assert (equal 2 (myeval '(progn (print (+ 1 4))
                             2)
                           nil #'err #'ok)))
  ;; NB:ERR!
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (print x)
                                      (print y)
                                      (cons x y))
                                    nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y x))
                              y)
                            nil #'err #'ok)))

  (assert (equal 84 (myeval '(let* ((x 42) (y (* 2 x)))
                              y)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y (* 2 x)))
                              y
                              x)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let ((x 42) (y 777))
                              y
                              x)
                            nil #'err #'ok)))


  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil #'identity))
    (terpri)
    (finish-output)
    (repl))

  ;; (repl)
#+END_SRC
