#+STARTUP: showall indent hidestars

* План работ

Цель этого этапа - решение semipredicate problem, проблемы полупредикатов.

Полупредикаты - это предикаты, у которых может быть три возможных вида возвращаемых
значений:
- T
- NIL
- Еще один вид, например "элемент не найден"

Например, полупредикатом является ~assoc~. Вот его реализация:

#+BEGIN_SRC lisp
  (defun assoc-1 (key alist)
    (cond ((null alist) nil)
          ((equal key (caar alist)) (car alist))
          (t (assoc-1 key (cdr alist)))))

  ;; (assoc-1 'alfa '((alfa . 1) (beta . 2)))
  ;; => (ALFA . 1)

  ;; (assoc-1 'gamma '((alfa . 1) (beta . 2)))
  ;; => NIL
#+END_SRC

В этой реализации ~assoc-1~ вынужден возвращать точечную пару (имя . значение), ведь
иначе будет невозможно отличить ситуацию "элемент не найден" от ситуации "элемент имеет
значение NIL".

Типичным вариантом использования является проверка на "элемент не найден" возвращаемого
~assoc~ значения. Ее отсутствие, как правило является ошибкой. Так как после решения
funarg-problem мы можем передавать функции, мы могли бы сделать такой вариант ~assoc~,
который принимал бы функцию, которая будет вызвана в ситуации "элемент не найден".

Такая функция называется "продолжением". Следуя далее этим путем, мы могли бы
передавать два продолжения: одно будет вызвано, если элемент не найден, а второе - в
противном случае:

#+NAME: assoc_4
#+BEGIN_SRC lisp
  (defun assoc-2 (key alist cont errcont) ;; NB!: inverted order of
                                          ;; continuations (for lookup)
    (cond ((null alist)              (funcall errcont key))
          ((equal key (caar alist))  (funcall cont    (cdar alist)))
          (t                         (assoc-2 key (cdr alist) cont errcont))))
#+END_SRC

Мы можем протестировать это в обоих случаях:

#+NAME: assoc_4_test
#+BEGIN_SRC lisp
  (assert (equal "ok:123"
                 (assoc-2 'alfa '((alfa . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
  (assert (equal "err:ALFA"
                 (assoc-2 'alfa '((beta . 123))
                          (lambda (x) (format nil "ok:~A" x))
                          (lambda (x) (format nil "err:~A" x)))))
#+END_SRC

* Lookup в глобальном окружении

Используя такой подход мы можем изменить ~lookup~, который у нас выглядел так:

#+NAME: lookup_3
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))
#+END_SRC

Теперь ~lookup~ будет написан в стиле передачи продолжений:

#+NAME: lookup_4
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  ;; lookup
  (defun lookup (symb env errcont cont)
    (assoc-2 symb env cont
             (lambda (key)
               (assoc-2 key *glob-env* cont
                        (lambda (key)
                          (funcall errcont
                                   (format
                                    nil
                                    "UNBOUD VARIABLE [~A] ~%LOCAL ENV: [~A] ~%GLOBAL ENV: [~A]"
                                    key env *glob-env*)))))))
#+END_SRC

Мы можем протестировать его аналогичным образом:

#+NAME: lookup_4_test
#+BEGIN_SRC lisp
  ;; test lookup
  (assert (equal "ok:123" (lookup 'aaa '((aaa . 123))
                                  (lambda (x) (format nil "err:~A" x))
                                  (lambda (x) (format nil "ok:~A" x)))))
  (assert (equal nil      (lookup 'aaa '((bbb . 123))
                                  (lambda (x) (declare (ignore x)) nil)
                                  (lambda (x) (format nil "ok:~A" x)))))
#+END_SRC

* Функции для тестирования

Чтобы удобнее тестироть функции, написанные в стиле передачи продолжений нам стоит
иметь две функции-продолжения, которые будут выводить тестируемы результат:

#+NAME: cps_4_test
#+BEGIN_SRC lisp
  (defun ok (x)
    (format t "~%ok: ~A" x)
    x)

  (defun err (x)
    (format t "~%err: ~A" x)
    x)
#+END_SRC

Мы будем передавать из как ~cont~ и ~errcont~.

* Структура замыкания

Чтобы сделать лексическое окружение, нужно иметь структуру замыкания, тут ничего не изменилось

#+NAME: closure_4
#+BEGIN_SRC lisp
  (defstruct closure
    body
    env
    args)
#+END_SRC

* MyApply

Теперь ~myapply~ принимает два продолжения: ~errcont~ и ~cont~. Кроме того, есть
некоторые добавления, которые нужно будет позже распихать по подразделам.

#+NAME: myapply_4
#+BEGIN_SRC lisp
  (defun myapply (fn args errcont cont)
    (cond
      <<myapply_ariph_4>>
      <<myapply_car_cdr_cons_4>>
      <<myapply_null_4>>
      ((equal fn 'print)         (funcall cont (print (car args))))
      ((equal fn 'or)            (funcall cont (or  (car args) (cadr args))))
      ((equal fn 'and)           (funcall cont (and (car args) (cadr args))))
      ((closure-p fn)            (myeval (closure-body fn)
                                         (pairlis (closure-args fn)
                                                  args
                                                  (closure-env fn))
                                         errcont
                                         cont))
      ))
#+END_SRC

А набор тестов остался без изменений:

#+NAME: myapply_3_test
#+BEGIN_SRC lisp
  <<myapply_ariph_3_test>>
  <<myapply_car_cdr_cons_3_test>>
  <<myapply_null_3_test>>
  <<myapply_func_symb_3_test>>
  ;; TODO : нужен тест для closure в apply
  <<myapply_closure_3_test>>
#+END_SRC

** Встроенные функции арифметики

Арифметические функции теперь вызывают продолжение ~cont~, передавая ему в качестве
параметра результат своих вычислений.

#+NAME: myapply_ariph_4
#+BEGIN_SRC lisp
  ((equal fn '+)               (funcall cont (+ (car args) (cadr args))))
  ((equal fn '*)               (funcall cont (* (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_ariph_3_test
#+BEGIN_SRC lisp
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
#+END_SRC

** Работа с CONS-ячейками

Функции, которые работают с cons-ячейками теперь вызывают продолжение ~cont~, передавая
ему в качестве параметра результат своих вычислений.

#+NAME: myapply_car_cdr_cons_4
#+BEGIN_SRC lisp
  ((equal fn 'car)             (funcall cont (caar args)))
  ((equal fn 'cdr)             (funcall cont (cdar args)))
  ((equal fn 'cons)            (funcall cont (cons (car args) (cadr args))))
#+END_SRC

#+NAME: myapply_car_cdr_cons_3_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
#+END_SRC

** NULL-предикат

~null~ теперь тоже вызывает продолжение ~cont~

#+NAME: myapply_null_4
#+BEGIN_SRC lisp
  ((equal fn 'null)            (funcall cont (null (car args))))
#+END_SRC

#+NAME: myapply_null_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
#+END_SRC

* MyEval

Также как и ~myapply~ теперь ~myeval~ принимает два продолжения: ~errcont~ и ~cont~ и
передает их при рекурсивном вызове внутри лямбды.

Мы переименовыываем ~lst~ в ~exp~.

#+NAME: myeval_4
#+BEGIN_SRC lisp
  <<myeval_evcond_4>>
  <<myeval_mypairlis_4>>
  <<myeval_evlet_4>>
  <<myeval_evprogn_4>>
  <<myeval_evletstar_4>>

  <<myeval_evlis_3>>

  (defun myeval (exp env errcont cont)
    (cond
      <<myeval_number_4>>
      <<myeval_symb_4>>
      <<myeval_quote_4>>
      <<myeval_if_4>>
      <<myeval_cond_4>>
      <<myeval_let_4>>
      <<myeval_progn_4>>
      <<myeval_letstar_4>>
      <<myeval_defun_4>>
      <<myeval_setq_4>>
      <<myeval_lambda_4>>
      (t
       (myeval (car exp) env errcont
               (lambda (x)
                 (evlis  x  (cdr exp) nil env errcont cont))))))
#+END_SRC


#+NAME: myeval_3_test
#+BEGIN_SRC lisp
  <<myeval_number_3_test>>
  <<myeval_symb_3_test>>
  <<myeval_quote_3_test>>
  <<myeval_if_3_test>>
  <<myeval_cond_3_test>>
  <<myeval_let_3_test>>
  <<myeval_progn_3_test>>
  <<myeval_list_3_test>>
  <<myeval_letstar_3_test>>
  <<myeval_defun_3_test>>
  <<myeval_setq_3_test>>
#+END_SRC


** Самовычисляемые формы

теперь используют продолжения

#+NAME: myeval_number_4
#+BEGIN_SRC lisp
  ((null exp)                  (funcall cont 'nil))
  ((equal t exp)               (funcall cont 't))
  ((member exp '(+ * car cdr cons null print or and))  (funcall cont exp))
  ((numberp exp)               (funcall cont exp)
#+END_SRC

#+NAME: myeval_number_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
#+END_SRC

** Вычисление символов

стало проще. Теперь вместо сигнализирования ошибки, когда символ не найден, lookup
просто вызовет другое продолжение. Поэтому класс ошибки нам больше не требуется.

#+NAME: myeval_symb_4
#+BEGIN_SRC lisp
  ((symbolp exp)               (lookup exp env errcont cont))
#+END_SRC

#+NAME: myeval_symb_3_test
#+BEGIN_SRC lisp
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VARIABLE-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** Цитирование

теперь вызывает продолжение

#+NAME: myeval_quote_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'quote)    (funcall cont (cadr exp)))
#+END_SRC

#+NAME: myeval_quote_3_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
#+END_SRC

** Условное выполнение IF

Чтобы сделать IF в CPS-стиле мы вызываем ~myeval~, чтобы вычислить значение
выражения-условия. При этом мы передаем в параметр ~cont~ лямбду, которая в зависимости
от значения вычисления вызовет ту или иную ветку:

#+NAME: myeval_if_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'if)       (myeval (cadr exp) env errcont
                                       (lambda (x)
                                         (if x
                                             (myeval (caddr exp)  env errcont cont)
                                             (myeval (cadddr exp) env errcont cont)))))
#+END_SRC

#+NAME: myeval_if_3_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
#+END_SRC

** COND

модифицируем ~evcond~ в CPS-стиле

#+NAME: myeval_evcond_4
#+BEGIN_SRC lisp
  (defun evcond (exp env errcont cont)
    (cond ((null exp)  (funcall cont nil))
          (t           (myeval (caar exp) env errcont
                               (lambda (x)
                                 (if x
                                     (myeval (cadar exp) env errcont cont)
                                     (evcond (cdr exp)   env errcont cont)))))))
  ;; tests for envcond
  (assert (equal 2 (evcond '((t 2) (t 1)) nil #'err #'ok)))
  (assert (equal 1 (evcond '((nil 2) (t 1)) nil #'err #'ok)))
  (assert (equal nil (evcond '((nil 2) (nil 1)) nil #'err #'ok)))
#+END_SRC

и адаптируем вызов

#+NAME: myeval_cond_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'cond)     (funcall cont (evcond (cdr exp) env errcont cont)))
#+END_SRC

#+NAME: myeval_cond_3_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
#+END_SRC

** LET

Ошибка ~mypairlis-error~ нам все еще нужна

#+NAME: errors_4
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
#+END_SRC

Функция ~mypairlis~ остается без изменений

#+NAME: myeval_mypairlis_4
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC


#+NAME: myeval_mypairlis_3_test
#+BEGIN_SRC lisp
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC

Теперь нам понадобится новая функция ~evlet~. Она рекурсивно вычисляет ~exps~
перебрасывая вычисленные результаты в ~evald-exps~ и по окончании этого процесса
вызывает ~evprogn~ чтобы вычислить тело ~let~ в объединенном окружении.

#+NAME: myeval_evlet_4
#+BEGIN_SRC lisp
  (defun evlet (vars exps evald-exps exp env errcont cont)
    (cond ((null exps)  (evprogn exp
                                 (pairlis vars (reverse evald-exps) env)
                                 errcont cont))
          (t            (myeval (car exps) env errcont
                                (lambda (x)
                                  (evlet vars (cdr exps) (cons x evald-exps) exp env errcont cont))))))

  ;; test for evlet
  (assert (equal 3 (evlet '(a b) '(1 2) nil '(4 (+ a b)) nil #'err #'ok)))
#+END_SRC

используем ~evlet~ чтобы вычислить ~let~

#+NAME: myeval_let_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let)      (evlet (mapcar #'car (cadr exp))
                                      (mapcar #'cadr (cadr exp))
                                      nil
                                      (cddr exp)
                                      env
                                      errcont
                                      cont))
#+END_SRC


#+NAME: myeval_let_3_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
#+END_SRC

** PROGN

cps

#+NAME: myeval_evprogn_4
#+BEGIN_SRC lisp
  (defun evprogn (lst env errcont cont)
    (cond ((null lst)         (funcall cont nil))
          ((null (cdr lst))   (myeval (car lst) env errcont cont))
          (t                  (myeval (car lst) env errcont
                                      (lambda (x)
                                        (evprogn (cdr lst) env errcont cont))))))

  ;; test for evprogn
  (assert (equal 2 (evprogn '(1 2) nil #'err #'ok)))


#+END_SRC

cps

#+NAME: myeval_progn_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'progn)    (evprogn (cdr exp) env errcont cont))
#+END_SRC


#+NAME: myeval_progn_3_test
#+BEGIN_SRC lisp
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

** CANCEL PRINT

Нам больше не нужен?

** LIST

#+NAME: myeval_evlis_3
#+BEGIN_SRC lisp
  ;; менее эффективный но более понятный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn evaled errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn (cdr unevaled) (append evaled (list x)) env errcont cont))))))


  ;; более эффективный вариант evlis
  (defun evlis (fn unevaled evaled env errcont cont)
    (cond ((null unevaled)  (myapply fn (reverse evaled) errcont cont))
          (t                (myeval (car unevaled) env errcont
                                    (lambda (x)
                                      (evlis fn (cdr unevaled) (cons x evaled) env errcont cont))))))

  ;; test for evlis
  (assert (equal 4 (evlis '+ '(1 (+ 1 2)) nil nil #'err #'ok)))
#+END_SRC

#+NAME: myeval_evlis_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC


#+NAME: myeval_list_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'list)     (evlis (cdr lst) env))
#+END_SRC


#+NAME: myeval_list_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

** LET*

cps

#+NAME: myeval_evletstar_4
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env errcont cont)
    (cond ((null varpairs)  (evprogn exp env errcont cont))
          (t                (myeval (cadar varpairs) env errcont
                                    (lambda (x)
                                      (evletstar (cdr varpairs) exp
                                                 (acons (caar varpairs) x env)
                                                 errcont cont))))))

  ;; test for evletstar
  (assert (equal 2 (evletstar '((a 1) (b a)) '(4 (+ a b)) nil  #'err #'ok)))
#+END_SRC

cps

#+NAME: myeval_letstar_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'let*)     (evletstar (cadr exp)
                                          (cddr exp)
                                          env
                                          errcont cont))
#+END_SRC

#+NAME: myeval_letstar_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
#+END_SRC

** DEFUN

При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции.

#+NAME: myeval_defun_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'defun)         (progn
                                      (push (cons (cadr exp)
                                                  (make-closure :body (cadddr exp)
                                                                :env env
                                                                :args (caddr exp)))
                                            ,*glob-env*)
                                      (funcall cont (cadr exp))))
#+END_SRC

Необходимо протестировать новый ~defun~:

#+NAME: myeval_defun_3_test
#+BEGIN_SRC lisp
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (prog1 (myeval '(alfa 8) nil)
                        (setf *glob-env* nil)))))
#+END_SRC

** SETQ

#+NAME: myeval_setq_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'setq)     (myeval (caddr exp) env errcont
                                       (lambda (val)
                                         (let ((it (lookup (cadr exp) env errcont cont)))
                                           (if (null it)
                                               (push (cons (cadr exp) val)
                                                     ,*glob-env*)
                                               (rplacd it val))
                                           (funcall cont val)))))
#+END_SRC

#+NAME: myeval_setq_3_test
#+BEGIN_SRC lisp
  (assert (equal 1 (myeval '(let ((alfa 2))
                             (setq alfa 1)
                             alfa)
                           nil)))
  (assert (equal '((ALFA . 1))
               (progn
                 (setf *glob-env* nil)
                 (myeval '(setq alfa 1) nil)
                 (prog1 *glob-env*
                   (setf *glob-env* nil)))))
#+END_SRC

** LAMBDA

csp

#+NAME: myeval_lambda_4
#+BEGIN_SRC lisp
  ((equal (car exp) 'lambda)   (funcall cont (make-closure :body (caddr exp)
                                                           :env env
                                                           :args (cadr exp))))
#+END_SRC

* OldTests

#+BEGIN_SRC lisp :tangle hello5.lisp
  ;; test number eval
  (assert (equal 123 (myeval 123 nil #'err #'ok)))

  ;; test autoreferenced functions
  (assert (equal '+ (myeval '+  nil #'err #'ok)))

  ;; test booleans
  (assert (equal 't   (myeval 't    nil #'err #'ok)))
  (assert (equal 'nil (myeval 'nil  nil #'err #'ok)))

  ;; test lookup symbols in local environment
  (assert (equal nil (myeval 'alfa  nil              (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
  (assert (equal 345 (myeval 'alfa  '((alfa . 345))  #'err                                      #'ok)))
  ;; test lookup symbols in global environment
  (let ((*glob-env* '((alfa . 111))))
    (assert (equal 111 (myeval 'alfa  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok)))
    (assert (equal nil (myeval 'beta  nil (lambda (x) (format t "~%err: ~A" x) nil)  #'ok))))

  ;; test quote
  (assert (equal 'zzz (myeval '(quote zzz)  nil #'err #'ok)))

  ;; test if
  (assert (equal 1 (myeval '(if t 1 2)  nil #'err #'ok)))
  (assert (equal 2 (myeval '(if nil 1 2)  nil #'err #'ok)))


  (assert (equal 1 (myeval '(car (quote (1 2 3))) nil #'err #'ok)))
  (assert (equal 42 (myeval '(cond ((null '()) 42) (42 666)) nil #'err #'ok)))
  (assert (equal 55 (myeval '((lambda (x y) (+ x y)) 42 13) nil #'err #'ok)))
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (cons x y))
                                    nil #'err #'ok)))
  (assert (equal 2 (myeval '(progn (print (+ 1 4))
                             2)
                           nil #'err #'ok)))
  ;; NB:ERR!
  (assert (equal '(3 . 42)  (myeval '(let ((x (+ 1 2))
                                           (y 42))
                                      (print x)
                                      (print y)
                                      (cons x y))
                                    nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y x))
                              y)
                            nil #'err #'ok)))

  (assert (equal 84 (myeval '(let* ((x 42) (y (* 2 x)))
                              y)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let* ((x 42) (y (* 2 x)))
                              y
                              x)
                            nil #'err #'ok)))

  (assert (equal 42 (myeval '(let ((x 42) (y 777))
                              y
                              x)
                            nil #'err #'ok)))


  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil #'identity))
    (terpri)
    (finish-output)
    (repl))
  ;; (repl)
#+END_SRC

* Итоги

#+BEGIN_SRC lisp :tangle lisp-4.lisp :noweb tangle :exports code :padline no :comments none
  <<errors_4>>

  <<lookup_4>>

  <<lookup_4_test>>

  <<closure_4>>

  <<myapply_4>>

  <<myeval_4>>

  ;; <<myapply_3_test>>

  ;; <<myeval_3_test>>

  ;; <<repl_4>>
#+END_SRC

Получиться должен вот такой результат:
