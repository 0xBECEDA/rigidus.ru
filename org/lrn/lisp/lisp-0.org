#+STARTUP: showall indent hidestars

* План работ

Начнем с реализации системы, которая позволит вычислять списковые формы.

Важнейшая часть интерпретатора Лисп - функция, называемая ~eval~, принимает на вход
список, представляющий собой программу, а на выходе возвращает результат её исполнения.

Так как мы пишем интерпретатор Lisp на лиспе, то наша функция будет называться
~myeval~.

Для того, чтобы писать минимально осмысленные, программмы мы должны реализовать базовый
набор примитивов (pure lisp):
- cons
- car
- cdr
- null
- consp
- define
- lambda
- functionp
- numberp
- eq
- сравнение чисел (=)
- if (или cond)

Имея функцию сравнения на равенстрво чисел и функции ~car~ и ~cdr~ можно определить
функцию, которая сравнивает списки, состоящие из чисел.  Поэтому база сранений - ~eq~
(сравнение символов) и ~=~.

В целях тренировки (на первом этапе) мы реализуем несколько отличающийся набор:
- вычисление самовычисляемых форм, таких как числа (и nil)
- арифметические вычисления: + (add) и * (mul)
- quote
- car
- cdr
- cons
- null
- if
- cond
- progn
- print
- list
- and
- or

Можно построить ~myeval~ с помощью ~cond~, тогда его структура будет такой:

#+BEGIN_SRC lisp
  (defun myeval (lst)
    (cond
      ;; Какие-то действия в зависимости от того какая форма
      ;; ...
      (t (error 'unknown-form))))
#+END_SRC

* Самовычисляемые формы

Первые случаи, которые мы можем реализовать - это самовычисляемые формы, такие,
например, как nil, T и числа, которые вычисляются сами в себя:

#+NAME: number_0
#+BEGIN_SRC lisp
  ((null lst)                  nil)
  ((equal t lst)               t)
  ((numberp lst)               lst)
#+END_SRC

#+NAME: number_0_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T)))
  (assert (equal NIL (myeval 'NIL)))
  (assert (equal 999 (myeval 999)))
#+END_SRC

* Встроенные функции арифметики

Теперь мы можем сделать функции сложения и умножения. Для простоты они будут принимать
только два аргумента (не так как в Common Lisp), но и первый и второй аргумент будет
рекурсивно вычислен:

#+NAME: ariph_0
#+BEGIN_SRC lisp
  ((equal (car lst) '+)        (+ (myeval (cadr lst))
                                  (myeval (caddr lst))))
  ((equal (car lst) '*)        (* (myeval (cadr lst))
                                  (myeval (caddr lst))))
#+END_SRC

Теперь мы можем протестировать то, что у нас получилось:

#+NAME: ariph_0_test
#+BEGIN_SRC lisp
  (assert (equal 7 (myeval 7)))
  (assert (equal 3 (myeval '(+ 1 2))))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)))))
#+END_SRC

* Цитирование

Следующая важная вещь - специальная форма QUOTE. Она возвращает свое содержимое без
вычисления:

#+NAME: quote_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'quote)    (cadr lst))
#+END_SRC

Протестируем её:

#+NAME: quote_0_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)))))
#+END_SRC

* Работа с CONS-ячейками

Теперь определим CAR и CDR:

#+NAME: car_cdr_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'car)      (car (myeval (cadr lst))))
  ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst))))
#+END_SRC

Мы пока не можем протестировать их работу, потому что у нас нет CONS. Исправим это:

#+NAME: cons_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'cons)     (cons (myeval (cadr lst))
                                     (myeval (caddr lst))))
#+END_SRC

Теперь можно протестировать создание cons-ячеек и получение правой и левой части ячейки

#+NAME: car_cdr_cons_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(cons 1 2))))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)))))
  (assert (equal 2 (myeval '(car (cons 2 3)))))
  (assert (equal 3 (myeval '(cdr (cons 2 3)))))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))))))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))))))
#+END_SRC

* NULL-предикат

Следующий этап - функция проверки на пустой список:

#+NAME: null_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'null)     (null (myeval (cadr lst))))
#+END_SRC

Тест

#+NAME: tests
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()))))
#+END_SRC

* Условное выполнение (IF)

Теперь мы можем создать IF. Он принимает три аргумента и в зависимости от результата
вычисления первого вычисляет второй или третий:

#+NAME: if_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'if)       (if (myeval (cadr lst))
                                   (myeval (caddr lst))
                                   (myeval (cadddr lst))))
#+END_SRC

Проверим, правильно ли вычисляется IF:

#+NAME: if_0_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2))))
  (assert (equal 1 (myeval '(if (null ()) 1 2))))
#+END_SRC

* COND

Определив IF, мы можем заняться и более сложной управляющей формой - COND. Для ее
реализации потребуется вспомогательная функция, которая будет рекурсивно исполнять
аргументы COND. Назовем ее EVCOND:

#+NAME: evcond_0
#+BEGIN_SRC lisp
  (defun evcond (lst)
    (cond ((null lst)               nil)
          ((myeval (caar lst))      (myeval (cadar lst)))
          (t                        (evcond (cdr lst)))))
#+END_SRC

С использованием EVCOND определить COND довольно просто:

#+NAME: cond_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'cond)     (evcond (cdr lst)))
#+END_SRC

Протестируем правильность работы COND:

#+NAME: cond_0_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2)))))
#+END_SRC

* PROGN

Далее нам понадобится PROGN. Снова будем использовать вспомогательную функцию EVPROGN:

#+NAME: evprogn_0
#+BEGIN_SRC lisp
  (defun evprogn (lst)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst)))
          (t                 (myeval (car lst))
                             (evprogn (cdr lst)))))
#+END_SRC

с ее помощью определим PROGN:

#+NAME: progn_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'progn)    (evprogn (cdr lst)))
#+END_SRC

И проверим:

#+NAME: tests
#+BEGIN_SRC lisp
  (assert (equal 3 (myeval '(progn 1 2 3))))
#+END_SRC

* PRINT

Для того, чтобы иметь возможность отладочной печати, определим PRINT:

#+NAME: print_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'print)    (print (myeval (cadr lst))))
#+END_SRC

* LIST

List - это функция, которая вычисляет свои аргументы и формирует из результатов
вычисления список. Для ее определения нам понадобится вспомогательная функция
EVLIS. Она рекурсивно испольняет список, полученный в первом аргументе, применяя к
результатам исполнения CONS, чтобы получить список результатов:

#+NAME: evlis_0
#+BEGIN_SRC lisp
  (defun evlis (lst)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst))
                             (evlis (cdr lst))))))
#+END_SRC

Протестируем ~evlis~:

#+NAME: evlis_0_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42))))
#+END_SRC

Теперь мы можем определить LIST:

#+NAME: list_0
#+BEGIN_SRC lisp
  ((equal (car lst) 'list)     (evlis (cdr lst)))
#+END_SRC

Протестируем ~list~

#+NAME: list_0_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42))))
#+END_SRC

* TODO AND
* TODO OR
* Итоги

Соберем простой интерпретатор из ~myeval~ и вспомогательных функций и запишем его файл:

#+NAME: simple
#+BEGIN_SRC lisp :tangle lisp-0.lisp :noweb tangle :exports code :padline no :comments none
  <<evcond_0>>
  <<evprogn_0>>
  <<evlis_0>>
  (defun myeval (lst)
    (cond
      <<number_0>>
      <<ariph_0>>
      <<quote_0>>
      <<car_cdr_0>>
      <<cons_0>>
      <<null_0>>
      <<if_0>>
      <<cond_0>>
      <<progn_0>>
      <<print_0>>
      <<list_0>>
      (t (error 'unknown-form))))

  <<number_0_test>>
  <<ariph_0_test>>
  <<quote_0_test>>
  <<car_cdr_cons_test>>
  <<if_0_test>>
  <<cond_0_test>>
  <<evlis_0_test>>
  <<list_0_test>>
#+END_SRC


Мы должны получить следующий результат:


#+BEGIN_SRC lisp
  (defun evcond (lst)
    (cond ((null lst)               nil)
          ((myeval (caar lst))      (myeval (cadar lst)))
          (t                        (evcond (cdr lst)))))
  (defun evprogn (lst)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst)))
          (t                 (myeval (car lst))
                             (evprogn (cdr lst)))))
  (defun evlis (lst)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst))
                             (evlis (cdr lst))))))
  (defun myeval (lst)
    (cond
      ((null lst)                  nil)
      ((equal t lst)               t)
      ((numberp lst)               lst)
      ((equal (car lst) '+)        (+ (myeval (cadr lst))
                                      (myeval (caddr lst))))
      ((equal (car lst) '*)        (* (myeval (cadr lst))
                                      (myeval (caddr lst))))
      ((equal (car lst) 'quote)    (cadr lst))
      ((equal (car lst) 'car)      (car (myeval (cadr lst))))
      ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst))))
      ((equal (car lst) 'cons)     (cons (myeval (cadr lst))
                                         (myeval (caddr lst))))
      ((equal (car lst) 'null)     (null (myeval (cadr lst))))
      ((equal (car lst) 'if)       (if (myeval (cadr lst))
                                       (myeval (caddr lst))
                                       (myeval (cadddr lst))))
      ((equal (car lst) 'cond)     (evcond (cdr lst)))
      ((equal (car lst) 'progn)    (evprogn (cdr lst)))
      ((equal (car lst) 'print)    (print (myeval (cadr lst))))
      ((equal (car lst) 'list)     (evlis (cdr lst)))
      (t (error 'unknown-form))))

  (assert (equal T (myeval 'T)))
  (assert (equal NIL (myeval 'NIL)))
  (assert (equal 999 (myeval 999)))
  (assert (equal 7 (myeval 7)))
  (assert (equal 3 (myeval '(+ 1 2))))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)))))
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)))))
  (assert (equal '(1 . 2) (myeval '(cons 1 2))))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)))))
  (assert (equal 2 (myeval '(car (cons 2 3)))))
  (assert (equal 3 (myeval '(cdr (cons 2 3)))))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))))))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))))))
  (assert (equal 2 (myeval '(if () 1 2))))
  (assert (equal 1 (myeval '(if (null ()) 1 2))))
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2)))))
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42))))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42))))
#+END_SRC
