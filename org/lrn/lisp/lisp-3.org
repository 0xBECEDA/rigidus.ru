#+STARTUP: showall indent hidestars

* План работ

Цель этого этапа - создание лексического окружения (в дополнение к динамическому
окружению и глобальному окружению, которые у нас уже есть). Так мы решаем
~funarg-problem~, проблему функционального аргумента. Проблема возникает в программах
на языках, которые поддерживают функции как объекты первого класса (first-class
sitizens): позволяюn передавать функции в качестве параметров и возвращать функции из
функций.

~funarg problem~ возникает, когда тело определяемой функции ссылается на
идентификаторы, которые определены в окружении, где функция определяется. В то время
как мы бы хотели, чтобы ссылки вели на окружение, в котором функция вызывается.

Есть 2 типа этой проблемы:
- downward - когда в функцию передается функция [TODO:gmm] Подробнее, с примером
- upward - когда вызывающая функция ссылается на окружение вызываемой после завершения
  вызова

В качестве примера ~upward~ возьмем такой код:

#+BEGIN_SRC lisp
  ;; UPWARD FUNARG PROBLEM

  ;; Создадим функцию F, которая возвращает функцию в замыкании по X
  (setq f (lambda (x)
             (lambda (y)
               (+ x y))))

  ;; С помощью F создадим функцию G
  (setq g (funcall f 5))

  ;; В этой функции X ссылается на 10, но после возврата из FUNCALL окружение, где X=10
  ;; уже не существует

  ;; тут при вызове Y=10, а X ссылается на несуществующее окружение
  (funcall g 10)

  ;; Чтобы получить верный ответ (15) нужно сохранять окружение в момент создания замыкания
  ;; тогда даже такой код будет давать 15
  (let ((x 30))
    (funcall g 10))
#+END_SRC

Еще один интересный пример ~upward~ funarg problem:

#+BEGIN_SRC lisp
  (defun compose (f g)
    (lambda (x) (funcall f (funcall g x))))

  (funcall (compose #'car #'cdr) '(1 2 3 4))

  ;; Более развернутый вариант этого:

  ;; Создадим функцию COMPOSE, возвращую лямбду, которая
  ;; примененяет первый функциональный аргумент ко второму.
  (setq compose (lambda (f g)
                  (lambda (x)
                    (funcall f (funcall g x)))))

  ;; Создадим функцию F, которая является функцией,
  ;; применяющий CAR к CDR
  (setq f (funcall compose #'car #'cdr))

  ;; Вызовем полученную функцию F от списка (хотим получить 2)
  (funcall f '(1 2 3 4))
#+END_SRC

Когда мы возвращаем лямбду из ~compose~ мы теряем окружение (динамическое окружение,
содержащее ~f~ и ~g~ осталось в месте где лямбда определялась) и у нас нет никакого
способа применить ~f~ к ~(funcall g x)~, так как у нас уже нет ~g~ в окружении.

Таким образом это ~upward~ funarg problem [TODO:gmm] Правильно рассуждаю?
[TODO:gmm] Нужен корректный пример ~downward~ funarg problem

Нам нужно уметь замыкать окружение лексически, тогда лямбда возвратит замыкание, где у
нас будут связанные ~f~ и ~g~.

Трассировка выполнения еще более наглядно поясняет ~upward~

#+BEGIN_SRC lisp
  ;; Трассируем такой код:
  (((lambda (x)
      (lambda (y) x))
    1)
   2)

  0: (MYEVAL (((LAMBDA (X) (LAMBDA (Y) X)) 1) 2) NIL)
    1: (MYEVAL ((LAMBDA (X) (LAMBDA (Y) X)) 1) NIL)
      2: (MYEVAL (LAMBDA (X) (LAMBDA (Y) X)) NIL)       ;; вычисляем car формы
      2: MYEVAL returned (LAMBDA (X) (LAMBDA (Y) X))    ;; lambda вычисляется в себя
      2: (MYEVAL 1 NIL)                                 ;; вычисляем первый аргумет 1
      2: MYEVAL returned 1                              ;; числа самовычислимы
      2: (MYAPPLY (LAMBDA (X) (LAMBDA (Y) X)) (1) NIL)  ;; применяем первую лямбду
        3: (MYEVAL (LAMBDA (Y) X) ((X . 1)))            ;; тело первой лямбды -- вторая лямбда  -> тут будет замыкание
        3: MYEVAL returned (LAMBDA (Y) X)               ;; лямбда вычисляется в себя
      2: MYAPPLY returned (LAMBDA (Y) X)
    1: MYEVAL returned (LAMBDA (Y) X)
    1: (MYEVAL 2 NIL)                                   ;; вычисляем второй аргумент
    1: MYEVAL returned 2                                ;; он самовычислим
    1: (MYAPPLY (LAMBDA (Y) X) (2) NIL)                 ;; применяем лямбду (вторую), но обрати внимание на окружение
      2: (MYEVAL X ((Y . 2)))                           ;; окуржение ((x . 1)) пропало

  ;; CL-вариант
  (defun mymapcar (fn lst)
    (cond ((null lst) nil)
          (t (cons (funcall fn (car lst))
                   (mymapcar fn (cdr lst))))))


  ;; MICROLISP-вариант
  (defun mymapcar (fn lst)
    (cond ((null lst) nil)
          (t (cons (fn (car lst))
                   (mymapcar fn (cdr lst))))))


  (defun foo (lst)
      (mymapcar (lambda (i) (cons i lst)) '(1 2 3)))

  (foo '(a b c))

  CL-USER>
  ((1 a b c)
   (2 a b c)
   (3 a b c))

  microlisp>
  ((1 1 2 3) (2 2 3) (3 3))
#+END_SRC

Теперь рассмотрим ~downward~

#+BEGIN_SRC lisp
  ;; DOWNWARD FUNARG PROBLEM

  ;; Создадим свой mapcar
  (defun mymapcar (fn lst)
    (cond ((null lst) nil)
          (t (cons (funcall fn (car lst))
                   (mymapcar fn (cdr lst))))))

  ;; Создадим функцию FOO, которая принимает список LST и использует
  ;; MYMAPCAR чтобы сконсить его с каждым из элементов списка (1 2 3)
  (defun foo (lst)
    (mymapcar (lambda (i)
                (cons i lst))
              '(1 2 3)))

  ;; Когда мы вызовем ... TODO
  (foo '(a b c))

  => ((1 A B C)
      (2 A B C)
      (3 A B C))
#+END_SRC

* Окружения и MyApply

Это глобальное окружение, которое было сделано на предыдущем этапе и функция поиска в
нем (~lookup~), тут ничего не поменялось.

#+NAME: lookup_3
#+BEGIN_SRC lisp
  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))
#+END_SRC

Чтобы сделать лексическое окружение, нужно создать структуру замыкания:

#+NAME: closure_3
#+BEGIN_SRC lisp
  (defstruct closure
    body
    env
    args)
#+END_SRC

Когда нам нужно передать лямбду в функцию ~apply~ мы будем оборачивать ее в замыкание,
сохраняя окружение функции в нем:

#+NAME: myapply_closure_3
#+BEGIN_SRC lisp
  ((closure-p fn)              (myeval (closure-body fn)
                                       (pairlis (closure-args fn)
                                                args
                                                (closure-env fn))))
#+END_SRC

Этим куском кода мы заменяем обработку ~lambda~ внутри ~myapply~.

#+NAME: myapply_3
#+BEGIN_SRC lisp
  <<evaddmul_3>>
  (defun myapply (fn args env)
    (cond
      <<myapply_car_cdr_cons_3>>
      <<myapply_null_3>>
      <<myapply_ariph_3>>
      <<myapply_closure_3>>
      ))
#+END_SRC

И отдельно вынесем тесты:

#+NAME: myapply_3_test
#+BEGIN_SRC lisp
  <<myapply_car_cdr_cons_3_test>>
  <<myapply_null_3_test>>
  <<myapply_ariph_3_test>>
  <<myapply_func_symb_3_test>>
  ;; TODO : нужен тест для closure в apply
  <<myapply_closure_3_test>>
#+END_SRC

** Работа с CONS-ячейками

#+NAME: myapply_car_cdr_cons_3
#+BEGIN_SRC lisp
  ((equal fn 'car)             (caar args))
  ((equal fn 'cdr)             (cdar args))
  ((equal fn 'cons)            (cons (car args) (cadr args)))
#+END_SRC

#+NAME: myapply_car_cdr_cons_3_test
#+BEGIN_SRC lisp
  ;; Тесты для cons-ячеек
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  ;; Тесты для cons-ячеек, вычисляемых в окружении
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
#+END_SRC

** NULL-предикат

#+NAME: errors_3
#+BEGIN_SRC lisp
  (define-condition invalid-number-of-arguments (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
               (fn condition)))))
#+END_SRC

#+NAME: myapply_null_3
#+BEGIN_SRC lisp
  ((equal fn 'null)            (if (null (cdr args))
                                   (null (car args))
                                   (error 'invalid-number-of-arguments :fn fn)))
#+END_SRC

#+NAME: myapply_null_3_test
#+BEGIN_SRC lisp
  ;; Тесты для NULL
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null nil) nil)))
  (assert (equal NIL (myeval '(null T) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  ;; Тесты для NULL, с аргументом, вычисляемые в окружении
  (assert (equal NIL (myeval '(null a) '((a . T)))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
#+END_SRC

** Встроенные функции арифметики

#+NAME: evaddmul_3
#+BEGIN_SRC lisp
  (defun evadd (lst env)
    (cond ((null lst)        (+))
          ((null (cdr lst))  (+ (myeval (car lst) env)))
          (t                 (+ (myeval (car lst) env)
                                (evadd (cdr lst) env)))))
  (defun evmul (lst env)
    (cond ((null lst)        (*))
          ((null (cdr lst))  (* (myeval (car lst) env)))
          (t                 (* (myeval (car lst) env)
                                (evmul (cdr lst) env)))))
#+END_SRC

#+NAME: evaddmul_3_test
#+BEGIN_SRC lisp
  ;; Тесты для EVADD и EVMUL
  (assert (equal (+ 2 3 4) (evadd '(2 3 4) nil)))
  (assert (equal (* 2 3 4) (evmul '(2 3 4) nil)))
  ;; Тесты для EVADD и EVMUL в окружении
  (assert (equal (+ 2 3 4) (evadd '(2 3 4) '((c . 2) (c . 3) (c . 4)))))
  (assert (equal (* 2 3 4) (evmul '(2 3 4) '((c . 2) (c . 3) (c . 4)))))
#+END_SRC


#+NAME: myapply_ariph_3
#+BEGIN_SRC lisp
  ((equal fn '+)               (evadd args env))
  ((equal fn '*)               (evmul args env))
#+END_SRC


#+NAME: myapply_ariph_3_test
#+BEGIN_SRC lisp
  ;; Тесты для арифметических функций
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 33 (myeval '(* (+ 1 2) (+ 3 4 4)) nil)))
  ;; Тесты для арифметических функций в окружении
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 120 (myeval '(+ a b c) '((a . 45) (b . 2) (c . 73)))))
#+END_SRC

** CANCEL Вычисление символов-функций

#+NAME: errors_3
#+BEGIN_SRC lisp
  (define-condition function-not-found-error (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: function not found: ~A"
               (fn condition)))))

#+END_SRC

Этот кейс удаляем, потому что у нас это вычисление теперь производится в myeval

#+NAME: myapply_func_symb_3_DELETED
#+BEGIN_SRC lisp
  ((symbolp fn)                (let ((it (lookup fn env)))
                                 (if (null it)
                                     (error 'function-not-found-error :fn fn)
                                     (myapply (cdr it) args env))))
#+END_SRC

И тест видоизменяется, чтобы проверить вычисление в глобальном окружении
[TODO:gmm] Тут я не уверен что правильный тест

#+NAME: myapply_func_symb_3_test
#+BEGIN_SRC lisp
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (myeval '(setq beta 7) nil)
                      (prog1 (myeval '(alfa beta) nil)
                        (setf *glob-env* nil)))))
  ;; (assert (equal "error"
  ;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
  ;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** CANCEL LAMBDA

Этот код больше не используется, и будет удален в следующем файле. Вместо него мы
создаем замыкания

#+NAME: myapply_lambda_3
#+BEGIN_SRC lisp
  ((equal (car fn) 'lambda)    (myeval (car (cddr fn))
                                       (pairlis (car (cdr fn))
                                                args
                                                env)))
#+END_SRC

#+NAME: myapply_lambda_3_test
#+BEGIN_SRC lisp
  (assert (equal '(42 . 42) (myeval '((lambda (x)
                                        (cons x x))
                                      42) nil)))
  (assert (equal '(42 . 17) (myeval '((lambda (x y)
                                        (cons x y))
                                      42 17) nil)))
#+END_SRC

* MyEval

Добавляем вычисление головы формы в конце

#+NAME: myeval_3
#+BEGIN_SRC lisp
  <<myeval_evcond_3>>
  <<myeval_evprogn_3>>
  <<myeval_evlis_3>>
  ;;evand
  ;;evor
  <<myeval_mypairlis_3>>
  <<myeval_evletstar_3>>

  (defun myeval (lst env)
    (cond
      <<myeval_number_3>>
      <<myeval_symb_3>>
      <<myeval_quote_3>>
      <<myeval_if_3>>
      <<myeval_cond_3>>
      <<myeval_progn_3>>
      <<myeval_print_3>>
      <<myeval_list_3>>
      ;; and
      ;; or
      <<myeval_let_3>>
      <<myeval_letstar_3>>
      <<myeval_defun_3>>
      <<myeval_setq_3>>
      <<myeval_lambda_3>>
      (t
       (myapply (myeval (car lst) env)
                (evlis (cdr lst) env)
                env))))
#+END_SRC



#+NAME: myeval_3_test
#+BEGIN_SRC lisp
  <<myeval_number_3_test>>
  <<myeval_symb_3_test>>
  <<myeval_quote_3_test>>
  <<myeval_if_3_test>>
  <<myeval_cond_3_test>>
  <<myeval_progn_3_test>>
  ;; print
  ;; evlis
  <<myeval_list_3_test>>
  ;; evand
  ;; evor
  <<myeval_let_3_test>>
  <<myeval_letstar_3_test>>
  <<myeval_defun_3_test>>
  <<myeval_setq_3_test>>
  ;; lambda?
#+END_SRC

** Самовычисляемые формы

#+NAME: myeval_number_3
#+BEGIN_SRC lisp
  ((null lst)                  nil)
  ((equal t lst)               t)
  ((member lst '(+ * car cdr cons null))  lst)
  ((numberp lst)               lst)
#+END_SRC

#+NAME: myeval_number_3_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
#+END_SRC

** Вычисление символов

#+NAME: errors_3
#+BEGIN_SRC lisp
  (define-condition var-not-found-error (error)
    ((vari :initarg :vari  :reader vari))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: variable not found: ~A"
               (vari condition)))))
#+END_SRC

#+NAME: myeval_symb_3
#+BEGIN_SRC lisp
  ((symbolp lst)               (let ((it (lookup lst env)))
                                 (if (null it)
                                     (error 'var-not-found-error :vari lst)
                                     (cdr it))))
#+END_SRC

#+NAME: myeval_symb_3_test
#+BEGIN_SRC lisp
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VAR-NOT-FOUND-ERROR (condition) "error"))))
#+END_SRC

** Цитирование

#+NAME: myeval_quote_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'quote)    (cadr lst))
#+END_SRC

#+NAME: myeval_quote_3_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
#+END_SRC

** Условное выполнение IF

#+NAME: myeval_if_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                   (myeval (caddr lst) env)
                                   (myeval (cadddr lst) env)))
#+END_SRC

#+NAME: myeval_if_3_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
#+END_SRC

** COND

#+NAME: myeval_evcond_3
#+BEGIN_SRC lisp
  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
#+END_SRC

#+NAME: myeval_cond_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'cond)     (evcond (cdr lst) env))
#+END_SRC

#+NAME: myeval_cond_3_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
#+END_SRC

** PROGN

#+NAME: myeval_evprogn_3
#+BEGIN_SRC lisp
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
#+END_SRC


#+NAME: myeval_progn_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
#+END_SRC


#+NAME: myeval_progn_3_test
#+BEGIN_SRC lisp
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

** PRINT

Без изменений

#+NAME: myeval_print_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
#+END_SRC

** LIST

#+NAME: myeval_evlis_3
#+BEGIN_SRC lisp
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
#+END_SRC

#+NAME: myeval_evlis_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC


#+NAME: myeval_list_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'list)     (evlis (cdr lst) env))
#+END_SRC


#+NAME: myeval_list_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

** LET

#+NAME: errors_3
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))
#+END_SRC


#+NAME: myeval_mypairlis_3
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC


#+NAME: myeval_mypairlis_3_test
#+BEGIN_SRC lisp
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC


#+NAME: myeval_let_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                        (pairlis (mapcar #'car (cadr lst))
                                                 (evlis (mapcar #'cadr (cadr lst))
                                                        env)
                                                 env)))
#+END_SRC


#+NAME: myeval_let_3_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
#+END_SRC

** LET*

#+NAME: myeval_evletstar_3
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))
#+END_SRC

#+NAME: myeval_letstar_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                          (caddr lst)
                                          env))
#+END_SRC

#+NAME: myeval_letstar_3_test
#+BEGIN_SRC lisp
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
#+END_SRC

** DEFUN

При создании функции мы создаем замыкание, в которое кладем тело функции, текущее
окружение и аргументы функции.

#+NAME: myeval_defun_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'defun)         (progn
                                      (push (cons (cadr lst)
                                                  (make-closure :body (cadddr lst)
                                                                :env env
                                                                :args (caddr lst)))
                                            ,*glob-env*)
                                      (cadr lst)))
#+END_SRC

Необходимо протестировать новый ~defun~:

#+NAME: myeval_defun_3_test
#+BEGIN_SRC lisp
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (prog1 (myeval '(alfa 8) nil)
                        (setf *glob-env* nil)))))
#+END_SRC

** SETQ

#+NAME: myeval_setq_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                     (val (myeval (caddr lst) env)))
                                 (if (null it)
                                     (push (cons (cadr lst) val)
                                           ,*glob-env*)
                                     (rplacd it val))
                                 val))
#+END_SRC

#+NAME: myeval_setq_3_test
#+BEGIN_SRC lisp
  (assert (equal 1 (myeval '(let ((alfa 2))
                             (setq alfa 1)
                             alfa)
                           nil)))
  (assert (equal '((ALFA . 1))
               (progn
                 (setf *glob-env* nil)
                 (myeval '(setq alfa 1) nil)
                 (prog1 *glob-env*
                   (setf *glob-env* nil)))))
#+END_SRC

** LAMBDA

При обработке формы, начинающейся с вызова ~lambda~ мы должны создать замыкание:

#+NAME: myeval_lambda_3
#+BEGIN_SRC lisp
  ((equal (car lst) 'lambda)   (make-closure :body (caddr lst) :env env :args (cadr lst)))
#+END_SRC

* Repl

#+NAME: repl_3
#+BEGIN_SRC lisp
  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))
#+END_SRC

* Итоги

#+BEGIN_SRC lisp :tangle lisp-3.lisp :noweb tangle :exports code :padline no :comments none
  <<errors_3>>

  <<lookup_3>>

  <<closure_3>>

  <<myapply_3>>

  <<myeval_3>>

  <<myapply_3_test>>

  <<myeval_3_test>>

  <<repl_3>>
#+END_SRC

Получиться должен вот такой результат:

#+BEGIN_SRC lisp
  (define-condition invalid-number-of-arguments (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: invalid-number-of-arguments: ~A"
               (fn condition)))))
  (define-condition function-not-found-error (error)
    ((fn :initarg :fn  :reader fn))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYAPPLY: function not found: ~A"
               (fn condition)))))

  (define-condition var-not-found-error (error)
    ((vari :initarg :vari  :reader vari))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: vari not found: ~A"
               (vari condition)))))
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))

  (defparameter *glob-env* nil)

  (defun lookup (symb env)
    (let ((it (assoc symb env)))
      (if (not (null it))
          it
          (assoc symb *glob-env*))))

  (defstruct closure
    body
    env
    args)

  (defun evadd (lst env)
    (cond ((null lst)        (+))
          ((null (cdr lst))  (+ (myeval (car lst) env)))
          (t                 (+ (myeval (car lst) env)
                                (evadd (cdr lst) env)))))
  (defun evmul (lst env)
    (cond ((null lst)        (*))
          ((null (cdr lst))  (* (myeval (car lst) env)))
          (t                 (* (myeval (car lst) env)
                                (evmul (cdr lst) env)))))
  (defun myapply (fn args env)
    (cond
      ((equal fn 'car)             (caar args))
      ((equal fn 'cdr)             (cdar args))
      ((equal fn 'cons)            (cons (car args) (cadr args)))
      ((equal fn 'null)            (if (null (cdr args))
                                       (null (car args))
                                       (error 'invalid-number-of-arguments :fn fn)))
      ((equal fn '+)               (evadd args env))
      ((equal fn '*)               (evmul args env))
      ((closure-p fn)              (myeval (closure-body fn)
                                           (pairlis (closure-args fn)
                                                    args
                                                    (closure-env fn))))
      ))

  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
  ;;evand
  ;;evor
  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))

  (defun myeval (lst env)
    (cond
      ((null lst)                  nil)
      ((equal t lst)               t)
      ((member lst '(+ * car cdr cons null))  lst)
      ((numberp lst)               lst)
      ((symbolp lst)               (let ((it (lookup lst env)))
                                     (if (null it)
                                         (error 'var-not-found-error :vari lst)
                                         (cdr it))))
      ((equal (car lst) 'quote)    (cadr lst))
      ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                       (myeval (caddr lst) env)
                                       (myeval (cadddr lst) env)))
      ((equal (car lst) 'cond)     (evcond (cdr lst) env))
      ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
      ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
      ((equal (car lst) 'list)     (evlis (cdr lst) env))
      ;; and
      ;; or
      ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                            (pairlis (mapcar #'car (cadr lst))
                                                     (evlis (mapcar #'cadr (cadr lst))
                                                            env)
                                                     env)))
      ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                              (caddr lst)
                                              env))
      ((equal (car lst) 'defun)         (progn
                                          (push (cons (cadr lst)
                                                      (make-closure :body (cadddr lst)
                                                                    :env env
                                                                    :args (caddr lst)))
                                                ,*glob-env*)
                                          (cadr lst)))
      ((equal (car lst) 'setq)     (let ((it (lookup (cadr lst) env))
                                         (val (myeval (caddr lst) env)))
                                     (if (null it)
                                         (push (cons (cadr lst) val)
                                               ,*glob-env*)
                                         (rplacd it val))
                                     val))
      ((equal (car lst) 'lambda)   (make-closure :body (caddr lst) :env env :args (cadr lst)))
      (t
       (myapply (myeval (car lst) env)
                (evlis (cdr lst) env)
                env))))

  ;; Тесты для cons-ячеек
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  ;; Тесты для cons-ячеек, вычисляемых в окружении
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
  ;; Тесты для NULL
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null nil) nil)))
  (assert (equal NIL (myeval '(null T) nil)))
  (assert (equal T (myeval '(null a) '((a . ())))))
  ;; Тесты для NULL, с аргументом, вычисляемые в окружении
  (assert (equal NIL (myeval '(null a) '((a . T)))))
  (assert (equal NIL (myeval '(null a) '((a . 1)))))
  ;; Тесты для арифметических функций
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 33 (myeval '(* (+ 1 2) (+ 3 4 4)) nil)))
  ;; Тесты для арифметических функций в окружении
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 120 (myeval '(+ a b c) '((a . 45) (b . 2) (c . 73)))))
  (assert (equal 49 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (myeval '(setq beta 7) nil)
                      (prog1 (myeval '(alfa beta) nil)
                        (setf *glob-env* nil)))))
  ;; (assert (equal "error"
  ;;                (handler-case (myeval '(alfa beta) '((beta . 7)))
  ;;                  (FUNCTION-NOT-FOUND-ERROR (condition) "error"))))
  ;; TODO : нужен тест для closure в apply


  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal "error"
                 (handler-case (myeval 'b nil)
                   (VAR-NOT-FOUND-ERROR (condition) "error"))))
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
  ;; print
  ;; evlis
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
  ;; evand
  ;; evor
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
  (assert (equal 64 (progn
                      (setf *glob-env* nil)
                      (myeval '(defun alfa (x) (* x x)) nil)
                      (prog1 (myeval '(alfa 8) nil)
                        (setf *glob-env* nil)))))
  (assert (equal 1 (myeval '(let ((alfa 2))
                             (setq alfa 1)
                             alfa)
                           nil)))
  (assert (equal '((ALFA . 1))
                 (progn
                   (setf *glob-env* nil)
                   (myeval '(setq alfa 1) nil)
                   (prog1 *glob-env*
                     (setf *glob-env* nil)))))
  ;; lambda?

  (defun repl ()
    (princ "microlisp>")
    (princ (myeval (read) nil))
    (terpri)
    (finish-output)
    (repl))
#+END_SRC
