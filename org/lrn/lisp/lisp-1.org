#+STARTUP: showall indent hidestars

* План работ

Теперь добавим к нашей реализации окружения. Для этого, у ~myeval~ появляется еще один
параметр ~env~. В параметре ~env~ передается окружение, которое у нас будет реализовано
как ассоциативный список вида:

#+BEGIN_SRC lisp
  ((a . 1) (b . 42) (c . somesymbol))
#+END_SRC

Таким образом, ~myeval~ становится таким:

#+BEGIN_SRC lisp
  (defun myeval (lst env)
    (cond
      ;; Какие-то действия в зависимости от того какая форма
      ;; ...
      (t (error 'eval-unknown-form-error :form lst :env env))))
#+END_SRC

Соотвественно все вызовы ~myeval~ изменяются, чтобы использовать ~env~. Кроме того мы
добавим классы ошибок, чтобы упростить отладку.

* Самовычисляемые формы

Здесь ничего не меняется

#+NAME: number_1
#+BEGIN_SRC lisp
  ((null lst)                  nil)
  ((equal t lst)               t)
  ((numberp lst)               lst)
#+END_SRC

#+NAME: number_1_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
#+END_SRC

* Встроенные функции арифметики

Вызов ~my-eval~ использует дополнительный параметр ~env~

#+NAME: ariph_1
#+BEGIN_SRC lisp
  ((equal (car lst) '+)        (+ (myeval (cadr lst) env)
                                  (myeval (caddr lst) env)))
  ((equal (car lst) '*)        (* (myeval (cadr lst) env)
                                  (myeval (caddr lst) env)))
#+END_SRC

К старым тестам (изменным, чтобы принимать пустое окружение) добавляем новые, которые
используют окружение в виде ассоциативного списка, которое пока мы формируем вручную.

#+NAME: ariph_1_test
#+BEGIN_SRC lisp
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
#+END_SRC

* Цитирование

Без изменений

#+NAME: quote_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'quote)    (cadr lst))
#+END_SRC

Без изменений

#+NAME: quote_1_test
#+BEGIN_SRC lisp
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
#+END_SRC

* Работа с CONS-ячейками

Добавляем параметр ~env~ в вызовы ~myeval~

#+NAME: car_cdr_cons_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'car)      (car (myeval (cadr lst) env)))
  ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst) env)))
  ((equal (car lst) 'cons)     (cons (myeval (cadr lst) env)
                                     (myeval (caddr lst) env)))
#+END_SRC

Добавляем тесты, которые работают с cons-ячейками, полученными из окружения

#+NAME: car_cdr_cons_1_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
#+END_SRC

* NULL-предикат

Без изменений

#+NAME: null_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'null)     (null (myeval (cadr lst) env)))
#+END_SRC

Добавляем тесты, проверящие символ в окружении, равный nil и не nil

#+NAME: null_1_test
#+BEGIN_SRC lisp
  (assert (equal T (myeval '(null ()) nil)))
  (assert (equal T (myeval '(null nil) nil)))
  (assert (equal NIL (myeval '(null T) nil)))
  (assert (equal T (myeval '(null a)) '((a . ()))))
  (assert (equal NIL (myeval '(null a)) '((a . T))))
  (assert (equal NIL (myeval '(null a)) '((a . 1))))
#+END_SRC

* Условное выполнение IF

Без изменений

#+NAME: if_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                   (myeval (caddr lst) env)
                                   (myeval (cadddr lst) env)))
#+END_SRC

Добавляем тесты, где условие вычисляется с использованием окружения

#+NAME: if_1_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
#+END_SRC

* COND

Без изменений

#+NAME: evcond_1
#+BEGIN_SRC lisp
  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
#+END_SRC

Без изменений

#+NAME: cond_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'cond)     (evcond (cdr lst) env))
#+END_SRC

Добавляем тесты для окружений

#+NAME: cond_1_test
#+BEGIN_SRC lisp
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                           (a 1)
                           (b 2))
                         '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
#+END_SRC

* PROGN

Без изменений

#+NAME: evprogn_1
#+BEGIN_SRC lisp
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
#+END_SRC

Без изменений

#+NAME: progn_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
#+END_SRC

Добавляем тесты в окружении

#+NAME: progn_1_test
#+BEGIN_SRC lisp
  (assert (equal 3 (myeval '(progn 1 2 3) nil)))
  (assert (equal 3 (myeval '(progn a b c) '((a . 1) (b . 2) (c . 3)))))
#+END_SRC

* PRINT

Без изменений

#+NAME: print_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
#+END_SRC

* LIST

Без изменений

#+NAME: evlis_1
#+BEGIN_SRC lisp
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                       (evlis (cdr lst) env)))))
#+END_SRC

Добавляем тесты в окружении

#+NAME: evlis_1_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

LIST определяем почти без изменений:

#+NAME: list_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'list)     (evlis (cdr lst) env))
#+END_SRC

Протестируем ~list~ (добавляя тесты в окружении)

#+NAME: list_1_test
#+BEGIN_SRC lisp
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
#+END_SRC

* Вычисление символов

С этого момента мы начинаем расширять возможности интерпретатора.

Если мы встречаем символ, то мы должны найти его в нашем окружении. Мы можем достичь
этого следующим образом:

#+NAME: symb_1
#+BEGIN_SRC lisp
  ((symbolp lst)               (cdr (assoc lst env)))
#+END_SRC

Важно поместить этот кусок ближе к началу ~myeval~, чтобы избежать попыток выполнять
над символом те операции, которые выполняются над списковыми формами.

Протестируем

#+NAME: symb_1_test
#+BEGIN_SRC lisp
  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
#+END_SRC

* LET

Теперь мы можем заняться более сложной частью - работой с окружениями. Чтобы добавить
переменную в окружение нам понадобятся вспомогательных функции. Первая из них: EVLIS
(Evaluate List) уже у нас есть (мы определили ее в разделе, где определен LIST).

Вторая вспомогательная функция: PAIRLIS. Мы будем использовать ее для работы с
окружениями. Она принимает список ключей ~lst1~, список значений ~lst2~ и ассоциативный
список результатов ~alist~. В процессе своей работы из первых двух списков она
формирует пары "ключ-значение" и добавляет их в ~alist~.

#+NAME: mypairlis_example
#+BEGIN_SRC lisp
  (defun mypairlis (lst1 lst2 alist)
   (cond ((and (null lst1) (null lst2))  alist)
         ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
         (t                              (mypairlis (cdr lst1)
                                                    (cdr lst2)
                                                    (cons (cons (car lst1)
                                                                (car lst2))
                                                          alist)))))
#+END_SRC

Вариант с хвостовой рекурсией будет эффективнее. Кроме того есть различие в семантике,
которое проявляется, если разрешены дубли в lambda-list. Если дубли запрещены, то
неважно, какой ~pairlis~ использовать.

#+NAME: mypairlis_1
#+BEGIN_SRC lisp
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))

  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
#+END_SRC

Протестируем ~mypairlis~:

#+NAME: mypairlis_1_test
#+BEGIN_SRC lisp
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
#+END_SRC

Имея эти функции мы можем определить LET:

#+NAME: let_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                        (mypairlis (mapcar #'car (cadr lst))
                                                   (evlis (mapcar #'cadr (cadr lst))
                                                          env)
                                                   env)))
#+END_SRC

и проверить его:

#+NAME: let_1_test
#+BEGIN_SRC lisp
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
#+END_SRC

* LET*

Определение LET* потребует одну дополнительную функцию, которую назовем EVLETSTAR. Она
принимает три аргумента. Первый, ~varpairs~, представляет собой пары "ключ-значение",
которые на каждом шаге по одной будут добавлены в окружение ~env~. Второй параметр,
~EXP~, представляет собой тело выражения, которое должно быть вычислено, когда все
varpairs будут добавлены в окончательное окружение.

#+NAME: evletstar_1
#+BEGIN_SRC lisp
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))
#+END_SRC

Теперь мы можем определить LET*:

#+NAME: letstar_1
#+BEGIN_SRC lisp
  ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                          (caddr lst)
                                          env))
#+END_SRC

и протестировать его:

#+NAME: letstar_1_test
#+BEGIN_SRC lisp
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
#+END_SRC

* LAMBDA

Последняя форма, которую мы реализуем - LAMBDA. В нашем интерпретаторе она вычисляется
при вызове, являясь первым аргументом вычисляемого списка: ~((lambda (x) (cons x x))
42)~ Кроме того, LAMBDA формирует свое окружение из своих параметров:

#+NAME: lambda_1
#+BEGIN_SRC lisp
  ((equal (caar lst) 'lambda)  (myeval (car (cddar lst))
                                       (mypairlis (cadar lst)
                                                  (evlis (cdr lst) env)
                                                  env)))
#+END_SRC

Проверим работу LAMBDA:

#+NAME: lambda_1_test
#+BEGIN_SRC lisp
  (assert (equal '(42 . 42) (myeval '((lambda (x)
                                        (cons x x))
                                      42) nil)))
  (assert (equal '(42 . 17) (myeval '((lambda (x y)
                                        (cons x y))
                                      42 17) nil)))
#+END_SRC

* TODO AND
* TODO OR
* Итоги

Добавляем обработку ошибок, чтобы получать более ясные сообщения при отладке.

Соберем простой интерпретатор из ~myeval~ и вспомогательных функций и запишем его файл:

#+NAME: simple
#+BEGIN_SRC lisp :tangle lisp-1.lisp :noweb tangle :exports code :padline no :comments none
  <<evcond_1>>
  <<evprogn_1>>
  <<evlis_1>>
  <<mypairlis_1>>
  <<evletstar_1>>
  (define-condition eval-unknown-form-error (error)
    ((form :initarg :form  :reader form)
     (env  :initarg :env   :reader env))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: Unknown form~%'~A~%can not be evaluated in environment~%'~A"
               (form condition) (env condition)))))

  (defun myeval (lst env)
    (cond
      <<number_1>>
      <<symb_1>>
      <<ariph_1>>
      <<quote_1>>
      <<car_cdr_cons_1>>
      <<null_1>>
      <<if_1>>
      <<cond_1>>
      <<progn_1>>
      <<print_1>>
      <<list_1>>
      <<let_1>>
      <<letstar_1>>
      <<lambda_1>>
      (t (errort 'eval-unknown-form-error :form lst :env env))))

  <<symb_1_test>>
  <<number_1_test>>
  <<ariph_1_test>>
  <<quote_1_test>>
  <<car_cdr_cons_1_test>>
  <<if_1_test>>
  <<cond_1_test>>
  <<evlis_1_test>>
  <<list_1_test>>
  <<mypairlis_1_test>>
  <<let_1_test>>
  <<letstar_1_test>>
  <<lambda_1_test>>
#+END_SRC

Мы должны получить следующий результат:

#+BEGIN_SRC lisp
  (defun evcond (lst env)
    (cond ((null lst)               nil)
          ((myeval (caar lst) env)  (myeval (cadar lst) env))
          (t                        (evcond (cdr lst) env))))
  (defun evprogn (lst env)
    (cond ((null lst)        nil)
          ((null (cdr lst))  (myeval (car lst) env))
          (t                 (myeval (car lst) env)
                             (evprogn (cdr lst) env))))
  (defun evlis (lst env)
    (cond ((null lst)  nil)
          (t           (cons (myeval (car lst) env)
                             (evlis (cdr lst) env)))))
  (define-condition mypairlis-error (error)
    ((lst1 :initarg :lst1  :reader lst1)
     (lst2 :initarg :lst2  :reader lst2))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYPAIRLIS: wrong params:~%'~A~%'~A"
               (lst1 condition) (lst2 condition)))))

  (defun mypairlis (lst1 lst2 alist)
    (cond ((and (null lst1) (null lst2))  alist)
          ((or  (null lst1) (null lst2))  (error 'mypairlis-error :lst1 lst1 :lst2 lst2))
          (t                              (cons (cons (car lst1)
                                                      (car lst2))
                                                (mypairlis (cdr lst1)
                                                           (cdr lst2)
                                                           alist)))))
  (defun evletstar (varpairs exp env)
    (cond ((null varpairs)  (myeval exp env))
          (t                (evletstar (cdr varpairs)
                                       exp
                                       (cons (cons (caar varpairs)
                                                   (myeval (cadar varpairs) env))
                                             env)))))
  (define-condition eval-unknown-form-error (error)
    ((form :initarg :form  :reader form)
     (env  :initarg :env   :reader env))
    (:report
     (lambda (condition stream)
       (format stream "Error in MYEVAL: Unknown form~%'~A~%can not be evaluated in environment~%'~A"
               (form condition) (env condition)))))

  (defun myeval (lst env)
    (cond
      ((null lst)                  nil)
      ((equal t lst)               t)
      ((numberp lst)               lst)
      ((symbolp lst)               (cdr (assoc lst env)))
      ((equal (car lst) '+)        (+ (myeval (cadr lst) env)
                                      (myeval (caddr lst) env)))
      ((equal (car lst) '*)        (* (myeval (cadr lst) env)
                                      (myeval (caddr lst) env)))
      ((equal (car lst) 'quote)    (cadr lst))
      ((equal (car lst) 'car)      (car (myeval (cadr lst) env)))
      ((equal (car lst) 'cdr)      (cdr (myeval (cadr lst) env)))
      ((equal (car lst) 'cons)     (cons (myeval (cadr lst) env)
                                         (myeval (caddr lst) env)))
      ((equal (car lst) 'null)     (null (myeval (cadr lst) env)))
      ((equal (car lst) 'if)       (if (myeval (cadr lst) env)
                                       (myeval (caddr lst) env)
                                       (myeval (cadddr lst) env)))
      ((equal (car lst) 'cond)     (evcond (cdr lst) env))
      ((equal (car lst) 'progn)    (evprogn (cdr lst) env))
      ((equal (car lst) 'print)    (print (myeval (cadr lst)  env)))
      ((equal (car lst) 'list)     (evlis (cdr lst) env))
      ((equal (car lst) 'let)      (evprogn (cddr lst) ; implicit progn
                                            (mypairlis (mapcar #'car (cadr lst))
                                                       (evlis (mapcar #'cadr (cadr lst))
                                                              env)
                                                       env)))
      ((equal (car lst) 'let*)     (evletstar (cadr lst)
                                              (caddr lst)
                                              env))
      ((equal (caar lst) 'lambda)  (myeval (car (cddar lst))
                                           (mypairlis (cadar lst)
                                                      (evlis (cdr lst) env)
                                                      env)))
      (t (errort 'eval-unknown-form-error :form lst :env env))))

  (assert (equal 6 (myeval 'b '((a . 3) (b . 6)))))
  (assert (equal T (myeval 'T nil)))
  (assert (equal NIL (myeval 'NIL nil)))
  (assert (equal 999 (myeval 999 nil)))
  (assert (equal 7 (myeval 7 nil)))
  (assert (equal 3 (myeval '(+ 1 2) nil)))
  (assert (equal 21 (myeval '(* (+ 1 2) (+ 3 4)) nil)))
  (assert (equal 2 (myeval 'a '((a . 2)))))
  (assert (equal 47 (myeval '(+ a b) '((a . 45) (b . 2)))))
  (assert (equal '(+ 1 2) (myeval '(quote (+ 1 2)) nil)))
  (assert (equal '(1 . 2) (myeval '(cons 1 2) nil)))
  (assert (equal '((1 . 2) 3 . 4) (myeval '(cons (cons 1 2) (cons 3 4)) nil)))
  (assert (equal 2 (myeval '(car (cons 2 3)) nil)))
  (assert (equal 3 (myeval '(cdr (cons 2 3)) nil)))
  (assert (equal '(1 . 2) (myeval '(car (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal '(3 . 4) (myeval '(cdr (cons (cons 1 2) (cons 3 4))) nil)))
  (assert (equal 1 (myeval '(car a) '((a . (1 . 2))))))
  (assert (equal 2 (myeval '(cdr a) '((a . (1 . 2))))))
  (assert (equal 3 (myeval '(car b) '((a . (1 . 2)) (b . (3 . 4))))))
  (assert (equal 2 (myeval '(if () 1 2) nil)))
  (assert (equal 1 (myeval '(if (null ()) 1 2) nil)))
  (assert (equal 2 (myeval '(if a 1 2) '((a . ())))))
  (assert (equal 1 (myeval '(if a 1 2) '((a . 1)))))
  (assert (equal 2 (myeval '(cond
                             (() 1)
                             (1 2))
                           nil)))
  (assert (equal 2 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . ()) (b . 1)))))
  (assert (equal 1 (myeval '(cond
                             (a 1)
                             (b 2))
                           '((a . 1) (b . ())))))
  (assert (equal '(3 6 42)
                 (evlis '((+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (evlis '((+ a b) (* b c) 42) '((a . 1) (b . 2) (c . 3) (d . 4)))))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ 1 2) (* 2 3) 42) nil)))
  (assert (equal '(3 6 42)
                 (myeval '(list (+ a b) (* b c) 42)
                         '((a . 1) (b . 2) (c . 3) (d . 4)))))
  (assert (equal '(( a . 1) (b . 2) ( c . 3) (z . 6) (y . 77))
                 (mypairlis '(a b c) '(1 2 3) '((z . 6) (y . 77)))))
  (assert (equal "error"
                 (handler-case (mypairlis '(a b c) nil '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal "error"
                 (handler-case (mypairlis nil '(1 2 3) '((z . 6) (y . 77)))
                   (MYPAIRLIS-ERROR (condition) "error"))))
  (assert (equal '(1 . 2) (myeval '(let ((a 1)
                                         (b 2))
                                    (cons a b)) nil)))
  (assert (equal '(3 1 . 2) (myeval '(let* ((a 1)
                                            (b 2)
                                            (c (+ a b)))
                                      (cons c (cons a b))) nil)))
  (assert (equal '(42 . 42) (myeval '((lambda (x)
                                        (cons x x))
                                      42) nil)))
  (assert (equal '(42 . 17) (myeval '((lambda (x y)
                                        (cons x y))
                                      42 17) nil)))
#+END_SRC
