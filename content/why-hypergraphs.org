http://blog.opencog.org/2013/03/24/why-hypergraphs/

OpenCog использует =гиперграфы= для представления информации. Почему?
Я не думаю что кто-то ясно и лаконично объяснил это где-то в другом
месте, так что я попытаюсь сделать это здесь.

Это очень важный момент: я не могу сказать вам как много раз я
отправлялся на поиски какой-нибудь крутой системы логического
программирования или логического вывода или автоматического
доказательства теорем или =graph-rewritin-engine= или =системы
вероятносного программирования= и потом опускал руки и понимал, что
после множества потерянных часов ничего из этого не делает то, что я
хочу. Если вы заинтересованы в AGI позвольте мне заверить вас: это не
делает то что вы хотите, или погодите-ка... Что я, собственно, хочу
чтобы они делали и почему?

Итак, давайте начнем с простого: с системы, переписывающей
граф. Сегодня почти каждый согласится с тем, что лучший путь
представления знаний – это граф. Структура IsA(Cat, Animal) выглядит
как граф с двумя вершинами: Саt и Animal, и помеченным ребром IsA,
между ними. Если я также знаю, что IsA(Binky, Cat), то, в принципе, я
могу быть в состоянии вывести, что IsA(Binky, Animal). Это простые
транзитивные отношения, и действие логической дедукции, в данном
примере, представляет собой простой правило переписывания графа: если
вы видите два IsA-ребра в строке, вы должны нарисовать третью
IsA-ребро между первой и последней вершинами. Легко, верно?

Поэтому, возможно, вы подумаете, что все логические индукции и системы
вывода имеют систему переписывания графов в основе, так? На самом
деле, почти никто из них так не делает. А те, что делают, делают
этокаким-то внутренним, специальным, непубличным, недокументированным
способом: нет там никакого API, это не показывается; это в не
"официальной" части системы, пока вы ее используете или переделываете.

Окей, так зачем мне нужны графы? Ну, я работаю над синтактическим
парсингом естествнного языка, так называемого Viterbi decoder for Link
Grammar. Мой первоначальный граф – это строка слов:
предложение. Вершинами являются слова, а ребрами - стрелки, называемые
"следующее слово". Очень просто. Чтобы проанализировать это
предложение, я хочу применить определенный набор простых правил,
переписывающих граф: например, если слово =x= - существительное, то
надо создать стрелку, называемую "части речи" (part-of-speech, POS),
от слова =X= к специальной вершине "имя существительное". Если слово,
стоящее перед словом =X= - это прилагательное (т. е. если оно имеет
POS-стрелку "прилагательное"), тогда создать новую стрелку
"модификатор существительного", направленной от =X= к этому слову,
которое стоит до него. Этот вид графа называется "dependency parsing",
и очень популярен, чтоб делать анализ естественного обычного
языка. Итак, вы думаете, что все dependency parsers используют системы
переписывающие графы в своем ядре? Вряд ли. Если они это делают, то
являются незадокументированными, сломанными и т.д... Идея понятна.

Единственный dependency parser, который я знаю, явно использующий в
себе явно систему, переписывающую граф, и открытую для модификации, и
даже документированную (!) - это RelEx. И это прекрасно! Хотя RelEx
использует свою самоизобретенную кастомную систему переписывания
графов, я думаю, он мог бы использовать некоторые другие, уже
существующие систему чтобы сделать это. (На самом деле нет, потому что
в 2005-ом не было систем переписывания графов с открытым исходным
кодом. Неважно).

Что еще я хочу? Ну, я мечтаю о том, чтобы с помощью машинного обучения
обучать систуму новым правилам! Я имею в виду, это и есть цель AGI да?
Иметь машину, которая может учиться новым вещам? Окей, для изучения
новых вещей, как мы видим, я должен иметь какой-то простой синтаксис
для представления правил. Базирующийся на простом языке графов. Вы
думаели, что все системы переписывающие графы имеют какой-то простой в
использовании язык, правильно? Нет. Решительно, черт возьми, нет. С
одним исключением, может быть, вам придется программировать на Java
или C++ или C#.net. К сожалению, моя система машинного обучения еще не
знает, как программировать на этих языках.

Здесь я прихожу к озарению: Было бы удобно, если бы я мог выразить
правила переписывающие графы - как сами графы. Было бы удобно, если бы
я мог выразить логические импликации, как сами графы. Было бы удобно
если мой язык программирования графов, мог быть сам записан в виде
графа. Да, это возможно. Пока что самый простой способ сделать это, если
граф на самом деле - гиперграф. Я объясню почему в в абзаце ниже.

Если я имею систему, переписывающую гиперграф, тогда я могу иметь
место, где я могу объединить обрабоку естественного языка, логический
вывод и машинное обучение в одном месте. Итак я думаю что любой, кто
пробовал построить AGI систему основывал бы ее на гиперграфе, верно?
Нет, вы ошибаетесь. Видимо, OpenCog единственная система, которая это
делает. Сейчас OpenCog реализация имеет много дизайнерских
нагромождений и архитектурных недостатков. Его трудно понять и трудно
использовать. Но теперь, возможно, теперь вы понимаете, почему я
клялся в верности этой системе, вместо того, чтобы сбежать с какой-то
другой системе рассуждений или к парсеру или Байесовской сети или
любой другой.

Математическое основание.

В данном разделе, я постараюсь применить все вышеописанные замечания
на прочной математической основе, с привлечением теории моделей,
теории категорий, (и даже N-категорий!), и теории типов.  Результатом
всего этого станет самый простой способ для представления структур
данных, так что алгоритмы машинного обучения могут обучаться им, а
затем применить их к парсингу естественного языка, логическому выводу
представлению структур данных как гиперграфов.

Из model theory и computer science мы знаем понятие цифровой подписи:
набор функций, который берет некоторое количество аргументов и
возвращает какое-то значение (как подпись в Java или C++). Если на
секунду прогнорировать типы (что делает lisp и scheme), то, в
принципе, можно передать любые значения в любом порядке любой функции,
и укладывать их как угодно, даже рекурсивно. Это называется "алгебра
термов" или точнее "алгебра свободных термов" или “free theory”. Если
функции не имеют имен, они анонимны, тогда это лямбда-исчисление.

Один из способов представить себе элемент алгебры термов - это
ориентированный древовидный граф. Итак, если мы имеем две функции
=f(х,у)= и =g(х,y)= и три константы =а=, =b=, =c=, то =f(a, g(b,c))= -
это двоичное дерево, с =f= в верхнем узле, =g= – в левом узле, и =a=,
=b= и =c=, в качестве листьев. Термин "алгебра" тогда просто
совокупность всех таких деревьев. Ни больше, ни меньше.

Для того чтобы запрограммировать что-то полезное необходимы в
предикаты или отношения: вещи, которые имеют значения истинности и
упорядочивают термы. Таким образом, "больше чем" - это отношение и
"a>b" может быт истинно или ложно. Отношения могут быть также IsA,
HasA, BelongTo, LivesIn, EmployedAt. Последние два примера долдны
очистить эти "реляционные алгебры" от от реляционных базы данных,
таких как SQL или NoSQL. Отношения комбинируются с логическими
операторами: (employee X LivesIn city Y AND ReportsTo dept Z в
качестве текстового примера.

В целом, это сочетает в себе алгебру термов и реляционную алгебру,
так, что можно записать =3<f(x,y)= где =f(x,y)= это терм, =<= это
отношение, =3= - это константа. Добавив к этому специальные
свободные переменные связанные с опреаторами ForAll и ThereExists
получим логику первого порядка. К примеру: =ForAll x ThereExists y
such that 3<f(x,y)=.

Особый случаей отношений - это правило переписывания термов. Это
отношение берет терм и заменяет его на другой терм, например: =ab->c=,
говоря "всегда, когда ты видишь строку "ab" замени ее на
"с". BNF-нотация компьютерных языков - это просто коллекция термов,
переписывающих отношения. Она использует term rewriting system чтобы
парсить (формальные) языки. Переписывание графов - это просто вариация
этого - всегда, когда ты видишь граф =X= замени его на граф -Y=.

До сих пор я избегал вопроса о типах. В программировании типы
позволяют типобезопасность. Типа делают код более читабельным:
=f(string, int)= менее мистично, чем =f(x,y)=. Типы решают некоторые
абстрактные проблемы лямбда-исчисления. Правила переписывания в
BNF-нотации типизированыые: подстановка =а->bc= имеет место не для
любого =а=, а только когда =а= - веб-страница или IP-аддрес или
URL. Правило переписывания графов говорит: "всегда, когда ты видишь
=x=, замени его на "y" неявно завися от того что =x= типизировано: =x=
не может быть просто любым, оно имеет специфический вид графа, имеет
специфическую форму и связь. Правила применяется для всех графов,
которые имеют эту форму, этот вид или тип. Итак, правило переписывания
=x->y= на самом деле (type x)->(type y). Графически это остается двумя
точками, =x= и =y= с направленным ребром между ними, Ой, подождите,
=x= и =y= не точки, =x= и =y= - графы. Какой граф имеет графы в
качестве точек? Какой вид графа имеет ребра между графами? А-аа,
гиперграф!

И это главный "Aга!"-момент
