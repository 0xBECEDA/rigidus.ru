[Оригинал (на английском), за авторством Линаса Вепстаса:] (http://blog.opencog.org/2013/03/24/why-hypergraphs/)


* Почему гиперграфы

  OpenCog использует =гиперграфы= для представления информации. Почему?  Я не думаю что кто-то ясно и лаконично объяснил
  это где-то в другом месте, так что я попытаюсь сделать это здесь.

  Это очень важный момент: я не могу передать вам, как много раз я отправлялся на поиски какой-нибудь крутой системы логического программирования или логического вывода или автоматического    доказательства теорем или =движка переписывания графов= или =системы вероятностного программирования= и потом опускал руки и понимал, что
  после множества потерянных часов ничего из этого не делает то, что я хочу. Если вы заинтересованы в AGI, позвольте мне заверить вас: того, что вы хотите, оно тоже не делает.
  Что я, собственно, хочу, чтобы они делали, и почему?

Ладно, начнём с простого -- систем переписывания графов. В наши дни почти все согласны, что перкрасный способ представлять знания -- использовать графы. Структура IsA(Cat, Animal) выглядит как граф с двумя вершинами, Cat и Animal, и подписанным ребром, IsA, между ними. Если помимо этого известно, что IsA(Binky, Cat), то я, в принципе, должен мочь вывести, что IsA(Binky, Animal). Это простое транзитивное отношение, и логическая дедукция в данном примере -- простое правило переписывания графа: если видишь подряд два IsA между первой и последней вершинами нарисуй третье IsA ребро. Просто, да?
И вот вы могли вообразить, что все движки логической индукции и рассуждений в ядрах своих содержат системы переписывания графов, правда? Так вы могли бы подумать. На самом деле, практически нет. А те, что всё же содержат, делают это каким-нибудь внутренним, придуманным на месте, не публичным, недокументированным образом; API нет, наружу оно не выставлено; это не "официальная" часть системы, с которой вы могли бы повозиться.

Ладно, так зачем мне системы переписывания графов? Ну, я работал над парсером естественных языков, так называемым декодером Витерби для Link Grammar. Мой изначальный граф -- цепочка слов, т.е. предложение. Слова -- вершины, а рёбра -- стрелочки, которые называются "следующее слово". Правда просто. Для парсинга предложения я хочу применить определённый набор простых правил переписывания графа: к примеру, если слово X существительное, создать стрелочку "часть речи" (POS) от слова X к особой вершине "существительное". Если слово непосредственно перед X -- прилагательное, (в смысле, у него есть стрелочка типа POS, указывающая на "прилагательное"), создать новую стрелочку, называющуюся "модификатор существительного", указывающую из X на это слово перед ним. Такая разметка графа называется "парсинг зависимостей", и является очень распространённым способом парсинга естественных языков. Так что вы могли бы подумать, что все парсеры зависимостей в ядрах своих содержат систему преписывания графов, да? Едва ли. На самом деле, рпактически ни один. А если и да, то они огорожены, являются сборищами хаков, недокументированы... Ну вы поняли.

Единственный известный мне парсер зависимостей, явным образом работающий на системе переписывания графов, открытой для эспериментов и документированной(!), -- это RelEx. Ух ты! Хотя RelEx изобрёл и использует свою собственную
 кастомную систему переписывания графов, полагаю, что в принципе он мог использовать какую-нибудь другую, уже существующую систему для этих целей ( Ну, вообще не мог, потому что в 2005 никаких устойчивых системы переписывания графов с открытым кодом не было. Ну да ладно.)

Чего ещё я хочу сделать? Ну, я мечтаю об использовании системы машинного обучения для разучивания новых правил! В смысле, цель AGI же в этом, правильно? Иметь машину, могущую изучать новые штуки? Так, чтобы изучать новые правила, посмотрим-ка, нужен простой синтаксис для представления правил. В общем-то, просто графовый язык. И вот вы могли бы подумать, что все системы переписывания графов имеют какой-нибудь простой для понимания и использования графовый язык, да? Ан нет. Подчёркиваю -- чёрта с два. За одним возможным исключением, приходится писать на Джаве или C++ или C#. К сожалению, моя система машинного обучения поа не умеет программировать на этих языках.

Вот прыжок на доверие, на логику, к которому я пришёл: было бы удобно, моги я выразить сами правила переписывания графов как графы. Было бы удобно, если бы я мог выразить логические следствия как графы. Было бы удобно, если бы сам мой графический язык программирования мог быть записан как граф. Вообще, он может. На самом деле, проще всего это сделать, если граф -- гиперграф. В следующем разделе я напишу, почему. Если бы у меня была система переписывания гиперграфов, у меня было бы место, где я мог бы  объединить обработку естественных языков, логические рассуждения и машинное обучение, все в одном. 
И вот вы могли бы подумать, что каждый, старающийся построить систему AGI, писал бы её на основе системы переписывания графов, правильно? Но вы бы ошиблись. Похоже, OpenCog -- единственная система, которая так поступает.
Да, в реализации OpenCog'а куча косяков разработки и архитектурных недостатков. Её трудно понять и трудно использовать. Но теперь, быть может, вы понимаете, почему я присягнул ему на верность вместо того, чтобы убежаь с какой-нибудь ещё системой рассуждений или парсером или байесовой сетью или чем бы то ни было.

Математические основания 

В этом разделе я попытаюсь укрепить все вышеизложенные замечания на прочном математическом основании, воззвав к теории моделей, теории категорий (и даже n-категорий!) и теории типов. Благом от этого будет то, что простейший способ представить структуры данных так, чтобы алгоритмы машинного обучения могли их выучить и затем применить их к парсингу естественных языков и логическим рассуждениям, является представление структур данных гиперграфами.

В теории моделей и информатике есть идея сигнатуры: множества функций, принимающих некоторое количество аргуметов и возвращающих некоторое значение (совсем как сигнатура в Джаве или C++). Если на минуточку перестать обращать внимание на типы (как это делают lisp и scheme), то, в приницпе, можно подавать любое значение в люой позиции в люой функции, и класть их на стек произвольно, даже рекурсивно. Это называется алгебра термов, или свободная алгебра термов, или "свободная теория". Если функции не имеют имён (являются анонимными), получаем лямбда исчисление.

Один из способ представить эелмент алгебры термов -- в виде графа, а именно направленного дерева. Таким образом, если у нас есть две функции, f(x,y) и g(x,y), и три постоянных a,b,c, то  f(a, g(b,c)) -- двоичное дерево, с f в верхнем узле, g в левом узле и листьями a, b,c. Алгбера терминов тоогда есть просто собрание всех таких деревьев. Ни больше, ни меньше.

Чтобы заниматься полезным программированием, также нужны предикаты или отношения -- штуки со значениями истинности, и термы упорядченности. Так, "больше чем" -- отношение, и "a>b" либо истинно, либо ложно. Отношениями также бывают штуки вроде Является, Имеет, Принадлежит, ЖивётВ, РаботаетВ. Последние два примера должны прояснить, что реляционные алгебры составляют основу баз данных, SQL и noSQL. Отношения совмещаются с логическими операциями (employee X LivesIn city Y AND ReportsTo dept Z  -- классический пример).
