http://blog.opencog.org/2013/03/24/why-hypergraphs/

OpenCog использует =гиперграфы= для представления информации. Почему?
Я не думаю что кто-то ясно и лаконично объяснил это где-то в другом
месте, так что я попытаюсь сделать это здесь.

Это очень важный момент: я не могу сказать вам как много раз я
отправлялся на поиски какой-нибудь крутой системы логического
программирования или логического вывода или автоматического
доказательства теорем или =graph-rewritin-engine= или =системы
вероятносного программирования= и потом опускал руки и понимал, что
после множества потерянных часов ничего из этого не делает то, что я
хочу. Если вы заинтересованы в AGI позвольте мне заверить вас: это не
делает то что вы хотите, или погодите-ка... Что я, собственно, хочу
чтобы они делали и почему?

Итак, давайте начнем с простого: с системы, переписывающей
граф. Сегодня почти каждый согласится с тем, что лучший путь
представления знаний – это граф. Структура IsA(Cat, Animal) выглядит
как граф с двумя вершинами: Саt и Animal, и помеченным ребром IsA,
между ними. Если я также знаю, что IsA(Binky, Cat), то, в принципе, я
могу быть в состоянии вывести, что IsA(Binky, Animal). Это простые
транзитивные отношения, и действие логической дедукции, в данном
примере, представляет собой простой правило переписывания графа: если
вы видите два IsA-ребра в строке, вы должны нарисовать третью
IsA-ребро между первой и последней вершинами. Легко, верно?

Поэтому, возможно, вы подумаете, что все логические индукции и
осмысленные логические выводы на основе графо-переписывающих систем,
да? На самом деле, нет. А то, что было,делалось каким-то внутренним,
специальным, непубличным, недокументированным способом: нет там
никакого API, это не показывается; это в не "официальной" части
системы, пока вы ее используете или переделываете.

Зачем мне(автору) нужны графы? Ну, я работаю на parser (парсере?)
естественного языка, так называемого Viterbi decoder for Link
Grammar. Мой первоначальный граф – это строка слов:
предложение. Vertex (вершинами?) являются слова, а arrows (стрелки?)
называются “ следующее слово”. Очень просто. Чтобы проанализировать
это предложение, я хочу применить определенный набор простых
графо-переписывающих правил: например, если слово x - существительное,
то создайте стрелку, называется ‘части речи’ (part-of-speech, далее
POS), от слова х специальной вершине ‘имя существительное’. Если
слово, стоящее перед словом " x " - это прилагательное (т. е. если он
имеет POS - стрелку ‘прилагательное’), затем создать новую стрелку ‘
модификатор существительного’, направленной от х к этому слову, до
него. Этот вид графа называется “зависимость синтаксического анализа”
(dependency parsing), и очень популярен, чтоб сделать natural language
parcing (анализ обычного языка?). Вы думаете, что все зависимые
парсеры ( dependency parsers) используют графо-переписывающие системы
в своем ядре? Вряд ли. Если они это делают, то являются
незадокументированными, выкинутыми и т.д... Идея понятна.

Единственный зависимый парсер, который я знаю, использующий в себе
явно графо-переписывающую систему , то есть открытый и
задокументированный(!) - это RelEx. Хотя RelEx изобретен и
эксплуатируется своим клиентом, графо-переписывающая система, я
предполагаю, могла бы иметь немного другую, предшесвствующую систему
для осуществления этого. (На самом деле нет, в 2005ом не было
графо-переписывающих систем с открытым кодом. Неважно).

Что еще я хочу? Ну, я мечтаю о том, чтобы с помощью машинного обучения
обучать систуму новым правилам! Я имею в виду, это и есть цель AGI да?
Есть машины, которые могут узнать новые вещи? Для изучения новых
правил нужен простой синтаксис. Просто графо-язык. Вы думаете, что
графо-переписывающие системы имеют простой для использования язык?
Категорически нет. С одним исключением, может быть, вам придется
программировать на Java или C++ или C#.net. К сожалению, моя система
машинного обучения еще не знает, как программировать на этих языках.

Было бы удобно, если бы я мог выразить графо-переписывающие правила
как сами графы. Было бы удобно, если бы я мог выразить логические
значения, как сами графы. Было бы удобно если сам графо-язык
программирующий сам себя,может быть записан в виде графа. Может
быть. Пока что самый простой способ сделать это, если граф становится
hypergraph (гиперграф?). Если бы у меня была гиперграфо-переписывающая
система,я мог бы объединить обработки естественного языка, логического
мышления и машинного обучения, все в одном месте. Так вы думаете, что
все, кто пытался построить систему AGI будет писать ее фундамент в
графо-переписывающей системе, верно? Нет, вы ошибаетесь. Видимо,
OpenCog единственная система, которая это делает. Сейчас воплощение
OpenCog имеет много дизайнерских нагромождений и архитектурных
недостатков. Его трудно понять и трудно использовать. Но теперь,
возможно, теперь вы понимаете, почему я клялся в верности этой
системе, вместо того, чтобы сбежать с какой-то другой системе
рассуждений или к парсер или Байесовской сети или любой другой.

Математическое основание.

В данном разделе, я постараюсь применить все вышеописанные замечания
на прочной математической основе, прибегая теории моделей, теории
категорий, (и даже N-категорий!), и теории типа (model theory,
category theory, ( n-categories!), type theory).

Из теории моделей и компьютерных наук, (model theory and computer
science) мы имеем понятие подписи: набор функций, который берет
некоторое количество параметров и возвращает какое-то значение ( как
подпись в Java или C++). Если на секунду прогнорировать тыпи (что
делает lisp и scheme), то, в принципе, можно передать любое значение в
любом положении любой функции, и укладывать их как угодно, даже
рекурсивно. Это называется терпином “алгебра” или более свободным
вариантом “свободная теория”. Если функции не имеют имен, они
анонимны, тогда они имеют лямбда-исчисление.

Один из способов представить себе элемент термина “алгебра” как
направленное (ориентированное) дерево графов. Так, если мы имеем две
функции f(х,у) и G(х,Y) и три константы а,b,c, то F(a, g(b,c)) - это
двоичное дерево, с F в верхнем узле(top node), g – в левом узле, и a,
b и c, как листва.Термин “алгебра “тогда просто совокупность всех
таких деревьев. Ни больше, ни меньше.
