-*- mode: org; fill-column: 95 -*-
@title ООП. Оборачиваем ошибки полиэтиленом
@category arch
@sort arch001

В мире программирования серебряной пули нет, поэтому за неимением ее
приходится использовать более или менее удовлетворяющие
заменители. Там где получается об этом громко говорят и стараются
"продвинуть идею в массы", после чего идея начинает жить сама, часто в
довольно извращенной форме.

Последнее время я ни разу не прошел ни одного собеседования, где меня
бы не спросили про ООП, поэтому надо констатировать - это как раз тот
случай. Меж тем, большинство спрашивающих не всегда понимает, что это
такое, как это использовать и где оно дает сбои. Особенно, где дает
сбои - во всех "успешных историях" про проблемы стараются не
упоминать. А между тем - это самое важное. Итак, прежде чем вляпаться
в ООП - слова Пола Грэма:

"В восьмидесятых годах метод повторного использования каким-то неясным
мне образом связали с объектно-ориентированным программированием, и
сколь угодно многочисленные имеющиеся доказательства обратного,
по-видимому, уже не избавят этот метод от этого клейма. Хотя иногда
объектно-ориентированный код действительно годится для повторного
использования, таким его делает вовсе не объектно-ориентированность, а
программирование в стиле "снизу вверх". Возьмём, например, библиотеки:
их можно подгружать и повторно использовать сколько угодно, потому
что, по сути, они представляют собой отдельный язык. И при этом,
совсем неважно, написаны ли они в объектно-ориентированном стиле или
нет."

Сторонники ООП высказывыаются в том духе, что ООП - это не провал,
потому что много людей используют Java. Миллионы мух не могут
ошибаться! Объектно-ориентированное программирование объединяет данные
вместе с кодом, который их обрабатывает и это продается как
преимущество. Обычно сравнивнение идет с процедурным
программированием. На практике оказывается, что для многих предметных
областей стремление выразить все сущности объектами, похоже на попытку
натянуть грелку на член - а что: тоже ведь резиновое изделие!

Для вещей вроде игр или оконных интерфейсов, где данные можно выразить
как объект, обложить методами их обработки это действительно работает
до определенного момента. Особенно в том случае, когда потом
предполагается расширение в виде добавления методов или применение уже
написанных классов в сходном проекте. Но и там при усложнении проекта
программист однажды обнаруживает себя обслуживающим грандиозную по
объему структуру связанных между собой классов. Так как уже никто не
помнит, почему это было так спроектировано все ориентируются по
висящей на стене "диаграмме классов", которая производит большое
впечатление на руководство, хоть и давно не соответствует
действительности. При применении в приложении реляционных баз данных
часто на соседней стене висит такая же "схема данных", настолько же
неактуальная и оставляющая новичкам возможность в качестве развлечения
"найти 10 отличий".

В попытке справиться с монструозным результатом ООП-проектирования и
взять проект под контроль самые смелые архитекторы пытаются надстроить
еще один уровень - например сделать некоторые "метаданные", которые
будут генерировать и схему данных и код, в который уже можно будет
добавлять логику. Поскольку не у каждого такого архитектора за плечами
успешно сданный курс "Компиляторы", обычно это оканчивается фэйлом,
после чего руководство решает, что без архитекторов живется как-то
проще и в дальнейшем проект переходит в стадию гниения - программисты
что-то пишут, какие-то фичи реализуются, но в целом уже никто ничего
не понимает.

О том что вместо - несколько позже, ок?

P.S. Дополняя вышесказанное еще немного мыслей о ООП:

- Модульность гораздо эффективнее, чем инкапсуляция, решает задачу
  изоляции сложности в кусках доступных для понимания программистом.

- Повторное использование, которое обещает ООП - в реальной жизни
  скорее исключение чем правило. На практике библиотеки являются
  механизмами повторного использования кода, а не классы.

- Широкое использование наследования в стиле - "если у двух классов
  есть общий функционал - давайте выделим его в суперкласс" приводит к
  созданию монструозных иерархий классов, что выносит сложность на
  архитектурный уровень и противоречит принципу изоляции сложности.

- ООП не предоставляет средств автоматического поддержания проектов в
  "управляемом" состоянии. Поэтому приходится использовать
  описательные средства вроде UML, причем постоянно предпринимаются
  попытки генерировать из них код. Потому что в противном случае
  расхождения между кодом и его описанием становятся все больше и больше.

<a href="-*- mode: org; fill-column: 95 -*-
@title ООП. Оборачиваем ошибки полиэтиленом
@category arch
@sort arch001

В мире программирования серебряной пули нет, поэтому за неимением ее
приходится использовать более или менее удовлетворяющие
заменители. Там где получается об этом громко говорят и стараются
"продвинуть идею в массы", после чего идея начинает жить сама, часто в
довольно извращенной форме.

Последнее время я ни разу не прошел ни одного собеседования, где меня
бы не спросили про ООП, поэтому надо констатировать - это как раз тот
случай. Меж тем, большинство спрашивающих не всегда понимает, что это
такое, как это использовать и где оно дает сбои. Особенно, где дает
сбои - во всех "успешных историях" про проблемы стараются не
упоминать. А между тем - это самое важное. Итак, прежде чем вляпаться
в ООП - слова Пола Грэма:

"В восьмидесятых годах метод повторного использования каким-то неясным
мне образом связали с объектно-ориентированным программированием, и
сколь угодно многочисленные имеющиеся доказательства обратного,
по-видимому, уже не избавят этот метод от этого клейма. Хотя иногда
объектно-ориентированный код действительно годится для повторного
использования, таким его делает вовсе не объектно-ориентированность, а
программирование в стиле "снизу вверх". Возьмём, например, библиотеки:
их можно подгружать и повторно использовать сколько угодно, потому
что, по сути, они представляют собой отдельный язык. И при этом,
совсем неважно, написаны ли они в объектно-ориентированном стиле или
нет."

Сторонники ООП высказывыаются в том духе, что ООП - это не провал,
потому что много людей используют Java. Миллионы мух не могут
ошибаться! Объектно-ориентированное программирование объединяет данные
вместе с кодом, который их обрабатывает и это продается как
преимущество. Обычно сравнивнение идет с процедурным
программированием. На практике оказывается, что для многих предметных
областей стремление выразить все сущности объектами, похоже на попытку
натянуть грелку на член - а что: тоже ведь резиновое изделие!

Для вещей вроде игр или оконных интерфейсов, где данные можно выразить
как объект, обложить методами их обработки это действительно работает
до определенного момента. Особенно в том случае, когда потом
предполагается расширение в виде добавления методов или применение уже
написанных классов в сходном проекте. Но и там при усложнении проекта
программист однажды обнаруживает себя обслуживающим грандиозную по
объему структуру связанных между собой классов. Так как уже никто не
помнит, почему это было так спроектировано все ориентируются по
висящей на стене "диаграмме классов", которая производит большое
впечатление на руководство, хоть и давно не соответствует
действительности. При применении в приложении реляционных баз данных
часто на соседней стене висит такая же "схема данных", настолько же
неактуальная и оставляющая новичкам возможность в качестве развлечения
"найти 10 отличий".

В попытке справиться с монструозным результатом ООП-проектирования и
взять проект под контроль самые смелые архитекторы пытаются надстроить
еще один уровень - например сделать некоторые "метаданные", которые
будут генерировать и схему данных и код, в который уже можно будет
добавлять логику. Поскольку не у каждого такого архитектора за плечами
успешно сданный курс "Компиляторы", обычно это оканчивается фэйлом,
после чего руководство решает, что без архитекторов живется как-то
проще и в дальнейшем проект переходит в стадию гниения - программисты
что-то пишут, какие-то фичи реализуются, но в целом уже никто ничего
не понимает.

О том что вместо - несколько позже, ок?

P.S. Дополняя вышесказанное еще немного мыслей о ООП:

- Модульность гораздо эффективнее, чем инкапсуляция, решает задачу
  изоляции сложности в кусках доступных для понимания программистом.

- Повторное использование, которое обещает ООП - в реальной жизни
  скорее исключение чем правило. На практике библиотеки являются
  механизмами повторного использования кода, а не классы.

- Широкое использование наследования в стиле - "если у двух классов
  есть общий функционал - давайте выделим его в суперкласс" приводит к
  созданию монструозных иерархий классов, что выносит сложность на
  архитектурный уровень и противоречит принципу изоляции сложности.

- ООП не предоставляет средств автоматического поддержания проектов в
  "управляемом" состоянии. Поэтому приходится использовать
  описательные средства вроде UML, причем постоянно предпринимаются
  попытки генерировать из них код. Потому что в противном случае
  расхождения между кодом и его описанием становятся все больше и больше.

<a href="http://rigidus.livejournal.com/102679.html" rel="nofollow">Обсуждение</a>
